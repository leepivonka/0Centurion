ca65 V2.19 - Git d3cd668
Main file   : Forth.txt
Current file: Forth.txt

000000r 1               ; Subroutine threaded version of FIG FORTH for Centurion CPU6.
000000r 1               ;	CPU6 is a follow-on from "Eldorado ee200"
000000r 1               ; https://github.com/Nakazoto/CenturionComputer/
000000r 1               ; See also: "Starting FORTH" https://www.forth.com/starting-forth/
000000r 1               ; See also: https://forth-standard.org
000000r 1               ; See also: http://uefi.org
000000r 1               
000000r 1               ; by Lee Pivonka
000000r 1               
000000r 1               ; Based on FIG FORTH 6502 from http://6502.org/source/ .
000000r 1               
000000r 1               ;			 Through the courtesy of
000000r 1               ;
000000r 1               ;			  FORTH INTEREST GROUP
000000r 1               ;			     P.O. BOX  2154
000000r 1               ;			  OAKLAND, CALIFORNIA
000000r 1               ;				 94621
000000r 1               ;
000000r 1               ;
000000r 1               ;			      Release 1.1
000000r 1               ;
000000r 1               ;			 with compiler security
000000r 1               ;				   and
000000r 1               ;			 variable length names
000000r 1               ;
000000r 1               ;    Further distribution must include the above notice.
000000r 1               ;    The FIG installation Manual is required as it contains
000000r 1               ;    the model of FORTH and glossary of the system.
000000r 1               ;    Available from FIG at the above address for **.** postpaid.
000000r 1               ;
000000r 1               ;    Translated from the FIG model by W.F. Ragsdale with input-
000000r 1               ;    output given for the Rockwell System-65. Transportation to
000000r 1               ;    other systems requires only the alteration of :
000000r 1               ;		  EmitA KeyA QTerminalA RSlashW Mon
000000r 1               
000000r 1               ; This version has 2 major modifications from the FIG version:
000000r 1               ; * Subroutine threaded code.  There is no DoCol or other colon routines - it's all CPU6 code.
000000r 1               ;	There is no PFA or CFA - words start with CPU6 code.
000000r 1               ;	Words that use the CFA PFA model start with a JSR to the code, followed by the parameters.
000000r 1               ; * Word headers are remodeled.  There are no NFA PFA CFA versions - there is a single pointer to the
000000r 1               ;	CPU6 code, & header fields are at negative offsets from that.
000000r 1               
000000r 1               ; This file includes machine code definitions of all of the core words.
000000r 1               ; When this code is running, additional definitions can be typed in or compiled from disk.
000000r 1               
000000r 1               ; Standard CPU6 register usage:
000000r 1               ; A	scratch
000000r 1               ; B	scratch
000000r 1               ; X	CPU6, scratch
000000r 1               ; Y	scratch
000000r 1               ; Z	FORTH parameter stack pointer
000000r 1               ; S	CPU6, FORTH return stack pointer
000000r 1               ; C	CPU6
000000r 1               ; P	CPU6
000000r 1               
000000r 1               ; Compile with ca65 from cc65 - https://cc65.github.io/
000000r 1               
000000r 1               	.list on
000000r 1               	.listbytes unlimited ;include all object bytes in listing (since we load the listing file)
000000r 1               	.feature loose_string_term ; used to put quotes in strings
000000r 1               
000000r 1               	.include "0instructions.txt"  ; define Centurion CPU6 instructions
000000r 2               ; CA65 macro package for Centurion CPU6 (& EE 200) code.
000000r 2               ; https://github.com/Nakazoto/CenturionComputer/wiki/Instructions
000000r 2               
000000r 2               ; per yaros
000000r 2                .feature ubiquitous_idents
000000r 2                .setcpu "none"
000000r 2               
000000r 2               ; There are a few gotchas with this setup:
000000r 2               ;
000000r 2               ; * 6502 opcodes cannot be disabled in CA65.  If a 6502 opcode is used in a CPU6 program,
000000r 2               ;       it'll compile fine, but have strange & bad runtime behavior.
000000r 2               ;	Fortunately there are only a few collisions between 6502 & CPU6 opcodes:
000000r 2               ;		NOP  INX
000000r 2               ;	The CPU6 macro name has an appended C (for Centurion) in these cases.
000000r 2               ;
000000r 2               ; * Relative addresses aren't checked for out-of-range.  i havent' figured out how to
000000r 2               ;	explain this nicely to CA65.  There must be a way, 6502 branches do it nicely.
000000r 2               ;     Currently there are to versions of BRel:
000000r 2               ;     * The 1st one checks the range but generates a bad listing.
000000r 2               ;     * The 2nd one generates a correct listing but doesn't check range.
000000r 2               ;     It is useful to compile with the range check version enabled to check range,
000000r 2               ;	then compile with the other to generate a correct listing.
000000r 2               ;     I assume the object code file is correct in either case, but I'm currently
000000r 2               ;	report scraping the listing file to load it in my simulator.
000000r 2               
000000r 2               ; Instructions
000000r 2               ; This is a list of the available registers, OpCodes / Instructions, and what they mean.
000000r 2               ; These were all reverse engineered by just looking at existing code and recognizing patterns.
000000r 2               ; As such, this list may be incomplete or full of errors.
000000r 2               ; Any resemblance to the mnemonics or syntax used by other processors, such as the 8086, is simply because we borrowed existing syntax where it seemed fit.
000000r 2               ; The processor itself shares no design or architecture with any other documented existing processors we're aware of.
000000r 2               ; It is based upon the CPU4 and CPU5 earlier Warrex designs, and apparently the CD 200 before that, but we have no documentation for those either.
000000r 2               ; See ee 200.
000000r 2               
000000r 2               ; Registers
000000r 2               ; There are eight registers available.
000000r 2               ;	 Name	Usage			Notes
000000r 2               AW = $0 ; A	Primary Accumulator	Primary register, commonly used in implicit operations
000000r 2               AH = $0
000000r 2               AL = $1
000000r 2               BW = $2 ; B	Secondary Accumulator	Primary register, commonly used in implicit operations
000000r 2               BH = $2
000000r 2               BL = $3
000000r 2               XW = $4 ; X	Primary Index		Can only do word operations (Not true for CPU6?)
000000r 2               YW = $6 ; Y	Index or Working	Index registers or working storage registers
000000r 2               YH = $6
000000r 2               YL = $7
000000r 2               ZW = $8 ; Z	Index or Working	Index registers or working storage registers
000000r 2               ZH = $8
000000r 2               ZL = $9
000000r 2               SW = $a ; S	Stack pointer		Global among all interrupt levels
000000r 2               SH = $a
000000r 2               SL = $b
000000r 2               CW = $c ; C	Context			Contains the status condition indicators (fault, link, minus, and value) and preceding interrupt level
000000r 2               PW = $e ; P	Program Counter Base	Contains initial program counter value to be used when starting up or returning from interrupt
000000r 2               
000000r 2               ; Contexts
000000r 2               ; Each register and the flags appears to exist in 16 contexts and these contexts are mapped between 0x0000 and 0x00FF
000000r 2               ; 16 bytes per context starting with context 0 and working upwards.
000000r 2               ; The registers are stored in the memory in the order given above. Writing to the memory of another context updates the registers for that context.
000000r 2               ; Writing to the memory for your own context appears to change the register value except for PC and the unknown extra register.
000000r 2               ; Possibly PC is cached/reloaded on a context switch.
000000r 2               
000000r 2               ; The processor starts in context 0.
000000r 2               ; Context 15 is used by what appears to be a syscall instruction.
000000r 2               ; context 6 is used by the MUX interrupt test.
000000r 2               ; context 1 is used programatically during MMU testing.
000000r 2               
000000r 2               ; Interrupts are processed by a hardware triggered context switch, the execution of code in the new context,
000000r 2               ; and then an RI or RIM instruction.
000000r 2               
000000r 2               ; Instruction Organization
000000r 2               ; Instructions are constructed a nibble at a time, like a Build a Bear. The high nibble of the high byte determines what kind of operation is being executed. It should be noted that the lowest bit of the high nibble determines whether we are doing a byte operation or a word operation (excluding Control, Branch, X register and Jump operations). For example, 0x8 is 1000 in binary and is a byte operation. 0x9 is 1001 in binary and is a word operation. Both operation load the A register, but the low bit being either "0" or "1" is what determines whether we are loading a byte or word.
000000r 2               
000000r 2               ; High nibble	Operation type
000000r 2               ; 0x0	Control instructions
000000r 2               ; 0x1	Conditional branch instructions
000000r 2               ; 0x2	Single Register byte operations
000000r 2               ; 0x3	Single register word operations
000000r 2               ; 0x4	Double register byte operations
000000r 2               ; 0x5	Double register word operations
000000r 2               ; 0x6	X register memory reference operations
000000r 2               ; 0x7	Jump operations
000000r 2               ; 0x8	A register load byte operations
000000r 2               ; 0x9	A register load word operations
000000r 2               ; 0xA	A register store byte operations
000000r 2               ; 0xB	A register store word operations
000000r 2               ; 0xC	B register load byte operations
000000r 2               ; 0xD	B register load word operations
000000r 2               ; 0xE	B register store byte operations
000000r 2               ; 0xF	B register store word operations
000000r 2               
000000r 2               ; Addressing Modes
000000r 2               ; Instructions can be either 1-byte, 2-byte or 3-byte depending on the type of instruction.
000000r 2               ; The second or third byte (if present) are related to addressing, or directing the instruction as to which location in memory to act upon.
000000r 2               ; Addressing can be either implicit or explicit.
000000r 2               ; Implicit means that no addressing is specified, and that specific instruction operates on only one specific location.
000000r 2               ; Explicit means the programmer must state which location they will perform the operation on.
000000r 2               
000000r 2               ; In the chart below, the addressing mode and what is expected at each nibble of each operation is shown.
000000r 2               
000000r 2               ; HB = High Byte; MB = Mid Byte; LB = Low Byte
000000r 2               
000000r 2               ; HN = High Nibble; LN = Low Nibble
000000r 2               
000000r 2               ; HB_HN      	HB_LN      	MB_HN  	MB_LN  	LB_HN  	LB_LN  	Note
000000r 2               ; 0	Op (0-F)					Control Operations
000000r 2               ; 1	Op (0-F)	Displace	Displace			Branch Operations
000000r 2               ; 2	Op (0-7)	Source Reg.				Single Register Explicit Byte Operation
000000r 2               ; 2	Op (8-F)					Single Register Implicit Byte Operation
000000r 2               ; 3	Op (0-7)	Source Reg.				Single Register Explicit Word Operation
000000r 2               ; 3	Op (8-F)					Single Register Implicit Word Operation
000000r 2               ; 4	Op (0-7)	Source Reg.	Dest. Reg.			Double Register Explicit Byte Operation
000000r 2               ; 4	Op (8-F)					Double Register Implicit Byte Operation
000000r 2               ; 5	Op (0-7)	Source Reg.	Dest. Reg.			Double Register Explicit Word Operation
000000r 2               ; 5	Op (8-F)					Double Register Implicit Word Operation
000000r 2               ; Op (6-F)	0	Literal	Literal			Literal Memory Address Byte Operation
000000r 2               ; Op (6-F)	0	Literal	Literal	Literal	Literal	Literal Memory Address Word Operation
000000r 2               ; Op (6-F)	1	Direct	Direct	Direct	Direct	Direct Memory Address Operation
000000r 2               ; Op (6-F)	2	Indirect	Indirect	Indirect	Indirect	Indirect Memory Address Operation
000000r 2               ; Op (6-F)	3	Displace	Displace			Relative to Current Location Memory Address Operation
000000r 2               ; Op (6-F)	4	Displace	Displace			Indirect Relative to Current Location Memory Address Operation
000000r 2               ; Op (6-F)	5	Register	Modifier	Displace	Displace	Indexed Addressing (Modifier Table Below)
000000r 2               ; Op (6-F)	8-F					Implicit Indexing (8 - F => A - P Reg.)
000000r 2               
000000r 2               ; These strange names aren't so strange if you think of the 1st letter of each part
000000r 2               ; of the expression:
000000r 2               ;  ModBRPB is Mod Bracket Register Plus Bracket
000000r 2               ;
000000r 2               ; Modifier	Note
000000r 2               ModBRB    =  0 ; (r)	Index
000000r 2               ModBRPB   =  1 ; (r+)	Index; Index returned, incremented by ^
000000r 2               ModBMRB   =  2 ; (-r)	Decrement and Index
000000r 2               ModABRB   =  4 ; @(r)	Index indirect
000000r 2               ModABRPB  =  5 ; @(r+)	Index indirect; Index returned, incremented by ^
000000r 2               ModABMRB  =  6 ; @(-r)	Decrement and index indirect
000000r 2               ModNBRB   =  8 ; n(r)	Index with displacement
000000r 2               ModNBRPB  =  9 ; n(r+)	Index with displacement; Index returned, incremented by ^
000000r 2               ModNBMRB  = $A ; n(-r)	Decrement and index with displacement
000000r 2               ModANBRB  = $C ; @n(r)	Index with displacement indirect
000000r 2               ModANBRPB = $D ; @n(r+)	Index with displacement indirect, Index returned, incremented by ^
000000r 2               ModANBMRB = $E ; @n(-r)	Decrement and index with displacement indirect
000000r 2               
000000r 2                 .macro ModBytes WReg,Mod,Offset
000000r 2               	.if (WReg&$fff1)<>0
000000r 2               	  .error "WReg must be a word register"
000000r 2               	 .endif
000000r 2               	.if (Mod=ModBRB) | (Mod=ModBRPB) | (Mod=ModBMRB) | (Mod=ModABRB) | (Mod=ModABRPB) | (Mod=ModABMRB)
000000r 2               	  .byte (WReg<<4)|Mod
000000r 2               	 .else
000000r 2               	  .if (Mod=ModNBRB) | (Mod=ModNBRPB) | (Mod=ModNBMRB) | (Mod=ModANBRB) | (Mod=ModANBRPB) | (Mod=ModANBMRB)
000000r 2               	    .byte (WReg<<4)|Mod,Offset ; is offset signed or unsigned???
000000r 2                          .else
000000r 2               	    .error "Unknown Mod"
000000r 2               	   .endif
000000r 2               	 .endif
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro HLT ; Wait for Interrupt (Halt)
000000r 2               	.byte $00
000000r 2               	.endmacro
000000r 2                 .macro NOPC ; No Operation
000000r 2               	.byte $01
000000r 2               	.endmacro
000000r 2                 .macro SF ; Set Fault flag
000000r 2               	.byte $02
000000r 2               	.endmacro
000000r 2                 .macro RF ; Reset Fault flag
000000r 2               	.byte $03
000000r 2               	.endmacro
000000r 2                 .macro EI ; Enable the Interrupt System (allow interrupts)
000000r 2               	.byte $04
000000r 2               	.endmacro
000000r 2                 .macro DI ; Disable the Interrupt System (disable interrupts)
000000r 2               	.byte $05
000000r 2               	.endmacro
000000r 2                 .macro SL ; Set the Link (carry) Flag
000000r 2               	.byte $06
000000r 2               	.endmacro
000000r 2                 .macro RL ; Reset the Link (carry) Flag
000000r 2               	.byte $07
000000r 2               	.endmacro
000000r 2                 .macro CL ; Complement Link flag
000000r 2               	.byte $08
000000r 2               	.endmacro
000000r 2                 .macro RSR ; Return from subroutine
000000r 2               	.byte $09
000000r 2               	.endmacro
000000r 2                 .macro RI ; Return from interrupt
000000r 2               	.byte $0A
000000r 2               	.endmacro
000000r 2                 .macro RIM ; Return from Interrupt Modified
000000r 2               	.byte $0B
000000r 2               	.endmacro
000000r 2                 .macro ELO ; Enable Link Out - teletype_tx=Link
000000r 2               	.byte $0C
000000r 2               	.endmacro
000000r 2                 .macro PCX ; Transfer PC to X - X=address of next instruction
000000r 2               	.byte $0D
000000r 2               	.endmacro
000000r 2                 .macro DLY ; Delay 4.55 ms - for TTY bit timing
000000r 2               	.byte $0E
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; Return from Syscall or similar (pops a byte, then the new value of rt, then a byte, then the new ipl)
000000r 2               ;	.byte $0F
000000r 2               ;	.endmacro
000000r 2               
000000r 2                 .macro BRel op,adr ; Build branch offset byte (correct listing, no range check)
000000r 2               ;	.local @L1
000000r 2               ;@L1	= adr-*		; PC+N
000000r 2               ;	.if L1<-$82 || L1>=$82  ; this chokes on fwd refs, so we can't check the range
000000r 2               ;	  .error "Branch out of range"
000000r 2               ;	 .endif
000000r 2               	.byte op,.lobyte(adr-*-1)
000000r 2               	.endmacro
000000r 2                 .macro BRel3 op,adr ; Build branch offset byte (bad listing, does range check)
000000r 2               	bne adr
000000r 2               	.org *-2  ; this doesn't show up right in the listing (that we load!)
000000r 2               	.byte op
000000r 2               	.org *+1
000000r 2               	.endmacro
000000r 2                 .macro BL adr ; Branch if Link (Carry) Set
000000r 2               	BRel $10,adr
000000r 2               	.endmacro
000000r 2                 .macro BNL adr ; Branch if Link (Carry) not Set
000000r 2               	BRel $11,adr
000000r 2               	.endmacro
000000r 2                 .macro BF adr ; Branch if Fault Set
000000r 2               	BRel $12,adr
000000r 2               	.endmacro
000000r 2                 .macro BNF adr ; Branch if Fault not Set
000000r 2               	BRel $13,adr
000000r 2               	.endmacro
000000r 2                 .macro BZ adr ; Branch if V (Z) flag set
000000r 2               	BRel $14,adr
000000r 2               	.endmacro
000000r 2                 .macro BNZ adr ; Branch if V (Z) flag clear
000000r 2               	BRel $15,adr
000000r 2               	.endmacro
000000r 2                 .macro BM adr ; Branch if Minus flag set
000000r 2               	BRel $16,adr
000000r 2               	.endmacro
000000r 2                 .macro BP adr ; Branch on Positive (Minus flag clear)
000000r 2               	BRel $17,adr
000000r 2               	.endmacro
000000r 2                 .macro BGZ adr ; Branch if Greater Than 0 (!V && !Minus)
000000r 2               	BRel $18,adr
000000r 2               	.endmacro
000000r 2                 .macro BLE adr ; Branch if Less Than or Equal to 0 (V | Minus)
000000r 2               	BRel $19,adr
000000r 2               	.endmacro
000000r 2                 .macro BS1 adr ; Branch if Sense Switch 1 Set
000000r 2               	BRel $1a,adr
000000r 2               	.endmacro
000000r 2                 .macro BS2 adr ; Branch if Sense Switch 2 Set
000000r 2               	BRel $1b,adr
000000r 2               	.endmacro
000000r 2                 .macro BS3 adr ; Branch if Sense Switch 3 Set
000000r 2               	BRel $1c,adr
000000r 2               	.endmacro
000000r 2                 .macro BS4 adr ; Branch if Sense Switch 4 Set
000000r 2               	BRel $1d,adr
000000r 2               	.endmacro
000000r 2                 .macro BTM Rel ; Branch on TTY Mark (Changed for CPU6?)
000000r 2               	BRel $1e,Rel
000000r 2               	.endmacro
000000r 2                 .macro BEP Rel ; Branch on Even Parity (Changed for CPU6?)
000000r 2               	BRel $1f,adr
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro RegW OpWord,Reg,Const
000000r 2               ;	.if (Reg&$fff0)=$40  ; word register?
000000r 2               	  .byte OpWord,((Reg&$f)<<4)+(Const&$f)
000000r 2               ;	 .else
000000r 2               ;	  .error "Strange register"
000000r 2               ;	 .endif
000000r 2               	.endmacro
000000r 2                 .macro RegB OpByte,Reg
000000r 2               ;	.if (Reg&$fff0)=$60  ; byte register?
000000r 2               	  .byte OpByte,(Reg&$f)<<4
000000r 2               ;	 .else
000000r 2               ;	  .error "Strange register"
000000r 2               ;	 .endif
000000r 2               	.endmacro
000000r 2                 .macro INR WReg,Const	; increment register word
000000r 2               	RegW $30,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro INRB BReg	; increment register upper byte or lower byte
000000r 2               	RegB $20,BReg
000000r 2               	.endmacro
000000r 2                 .macro INAB		; Increment AL register
000000r 2               	.byte $28
000000r 2               	.endmacro
000000r 2                 .macro INA		; Increment AW register
000000r 2               	.byte $38
000000r 2               	.endmacro
000000r 2                 .macro DCR WReg,Const	; decrement register word
000000r 2               	RegW $31,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro DCRB BReg	; decrement register upper byte or lower byte
000000r 2               	RegB $21,BReg
000000r 2               	.endmacro
000000r 2                 .macro DCAB		; Decrement AL register
000000r 2               	.byte $29
000000r 2               	.endmacro
000000r 2                 .macro DCA		; Decrement AW register
000000r 2               	.byte $39
000000r 2               	.endmacro
000000r 2                 .macro CLR WReg,Const	; clear register word
000000r 2               	RegW $32,WReg,Const
000000r 2               	.endmacro
000000r 2                 .macro CLRB BReg	; clear register upper byte or lower byte
000000r 2               	RegB $22,BReg
000000r 2               	.endmacro
000000r 2                 .macro CLAB		; Clear AL register
000000r 2               	.byte $2A
000000r 2               	.endmacro
000000r 2                 .macro CLA		; Clear AW register
000000r 2               	.byte $3A
000000r 2               	.endmacro
000000r 2                 .macro IVR WReg,Const	; invert register word
000000r 2               	RegW $33,WReg,Const
000000r 2               	.endmacro
000000r 2                 .macro IVRB BReg	; invert register byte
000000r 2               	RegB $23,BReg
000000r 2               	.endmacro
000000r 2                 .macro IVAB		; Invert AL register
000000r 2               	.byte $2B
000000r 2               	.endmacro
000000r 2                 .macro IVA		; Invert AW register
000000r 2               	.byte $3B
000000r 2               	.endmacro
000000r 2                 .macro SRR WReg,Const	; shift register right (sign extend)
000000r 2               	RegW $34,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro SRRB BReg	; shift register byte right (sign extend)
000000r 2               	RegB $24,BReg
000000r 2               	.endmacro
000000r 2                 .macro SRAB		; Shift AL register right (sign extend)
000000r 2               	.byte $2C
000000r 2               	.endmacro
000000r 2                 .macro SRA		; Shift AW register right (sign extend)
000000r 2               	.byte $3C
000000r 2               	.endmacro
000000r 2                 .macro SLR WReg,Const	; shift register left (0 shifted in)
000000r 2               	RegW $35,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro SLRB BReg	; shift register byte left (0 shifted in)
000000r 2               	RegBW $25,BReg
000000r 2               	.endmacro
000000r 2                 .macro SLAB		; Shift AL register left (0 shifted in)
000000r 2               	.byte $2D
000000r 2               	.endmacro
000000r 2                 .macro SLA		; Shift AW register left (0 shifted in)
000000r 2               	.byte $3D
000000r 2               	.endmacro
000000r 2                 .macro RRR WReg,Const	; rotate register right (thru link flag)
000000r 2               	RegW $36,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro RRRB BReg	; rotate register byte right (thru link flag)
000000r 2               	RegB $26,BReg
000000r 2               	.endmacro
000000r 2                 .macro RLR WReg,Const	; rotate register left (thru link flag)
000000r 2               	RegW $37,WReg,Const-1
000000r 2               	.endmacro
000000r 2                 .macro RLRB BReg
000000r 2               	RegBW $27,BReg
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; Memory mapping?
000000r 2               ;	.byte $2E
000000r 2               ;	.endmacro
000000r 2               ;  .macro ?? ; DMA?
000000r 2               ;	.byte $2F
000000r 2               ;	.endmacro
000000r 2               
000000r 2                 .macro INXC		; Increment XW register
000000r 2               	.byte $3E
000000r 2               	.endmacro
000000r 2                 .macro DCX		; Decrement XW register
000000r 2               	.byte $3F
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ADD DestReg,SrcReg ; Add word Src to Dest
000000r 2               	.byte $50,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro ADDB DestReg,SrcReg ; Add byte Src to Dest
000000r 2               	.byte $40,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro AABB		; BL+=AL
000000r 2               	.byte $48
000000r 2               	.endmacro
000000r 2                 .macro AAB		; BW+=AW
000000r 2               	.byte $58
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro SUB DestReg,SrcReg ; Subtract byte Src to Dest
000000r 2               	.byte $51,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro SUBB DestReg,SrcReg ; Subtract byte Src to Dest
000000r 2               	.byte $41,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro SABB		; BL=AL-BL
000000r 2               	.byte $49
000000r 2               	.endmacro
000000r 2                 .macro SAB		; BW=AW-BW
000000r 2               	.byte $59
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ANDC DestReg,SrcReg ; AND word Src to Dest
000000r 2               	.byte $52,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro ANDB DestReg,SrcReg ; AND byte Src to Dest
000000r 2               	.byte $42,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro NABB		; BL&=AL
000000r 2               	.byte $4A
000000r 2               	.endmacro
000000r 2                 .macro NAB		; BW&=AW
000000r 2               	.byte $5A
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ORI DestReg,SrcReg ; OR word Src to Dest
000000r 2               	.byte $53,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro ORIB DestReg,SrcReg ; OR byte Src to Dest
000000r 2               	.byte $43,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro ORE DestReg,SrcReg ; XOR word Src to Dest
000000r 2               	.byte $54,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro OREB DestReg,SrcReg ; XOR byte Src to Dest
000000r 2               	.byte $44,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro XFR DestReg,SrcReg ; Copy Src register into Dest register
000000r 2               	.byte $55,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2                 .macro XFRB DestReg,SrcReg ; Copy byte of Src register into byte of Dest register
000000r 2               	.byte $45,((SrcReg&$f)<<4)+(DestReg&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ??
000000r 2               ;	.byte $46
000000r 2               ;	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; Execute micro code?
000000r 2               ;	.byte $47
000000r 2               ;	.endmacro
000000r 2               
000000r 2               
000000r 2                 .macro XAXB	; XL=AL  ???
000000r 2               	.byte $4B
000000r 2               	.endmacro
000000r 2                 .macro XAX	; XW=AW
000000r 2               	.byte $5B
000000r 2               	.endmacro
000000r 2                 .macro XAYB	; YL=AL
000000r 2               	.byte $4C
000000r 2               	.endmacro
000000r 2                 .macro XAY	; YW=AW
000000r 2               	.byte $5C
000000r 2               	.endmacro
000000r 2                 .macro XABB	; BL=AL
000000r 2               	.byte $4D
000000r 2               	.endmacro
000000r 2                 .macro XAB	; BW=AW
000000r 2               	.byte $5D
000000r 2               	.endmacro
000000r 2                 .macro XAZB	; ZL=AL
000000r 2               	.byte $4E
000000r 2               	.endmacro
000000r 2                 .macro XAZ	; ZW=AW
000000r 2               	.byte $5E
000000r 2               	.endmacro
000000r 2                 .macro XASB	; SL=AL
000000r 2               	.byte $4F
000000r 2               	.endmacro
000000r 2                 .macro XAS	; SW=AW
000000r 2               	.byte $5F
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro PUSH BeginReg,RegCount
000000r 2               	.byte $7e,(BeginReg<<4)+((RegCount-1)&$f)
000000r 2               	.endmacro
000000r 2                 .macro POP BeginReg,RegCount
000000r 2               	.byte $7f,(BeginReg<<4)+((RegCount-1)&$f)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ??	; 56	0101 0110	??
000000r 2               
000000r 2               ;  .macro ??	; 57	0101 0111	??			Execute micro code?
000000r 2               
000000r 2               
000000r 2                 .macro LDABL Lit ; Load literal address into AL register
000000r 2               	.byte $80,Lit
000000r 2               	.endmacro
000000r 2                 .macro LDAL Lit ; Load literal address into full word of AW register
000000r 2               	.byte $90
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro LDABD Direct ; Load direct address into AL register
000000r 2               	.byte $81
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDAD Direct ; Load direct address into full word of AW register
000000r 2               	.byte $91
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDABI Indirect ; Load indirect address into AL register
000000r 2               	.byte $82
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDAI Indirect ; Load indirect address into full word of AW register
000000r 2               	.byte $92
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDABR Rel ; Load direct Program Counter offset by N address into AL register
000000r 2               	BRel $83,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDAR Rel ; Load direct Program Counter offset by N address into full word of AW register
000000r 2               	BRel $93,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDABRI Rel ; Load indirect Program Counter offset by N address into byte of AL register
000000r 2               	BRel $84,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDARI Rel ; Load indirect Program Counter offset by N address into full word of AW register
000000r 2               	BRel $94,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDABX WReg,Mod,Offset ; Load indexed register into byte of AL register
000000r 2               	.byte $85
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro LDAX WReg,Mod,Offset ; Load indexed register into full word of AW register
000000r 2               	.byte $95
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; 86	1000 0110	??
000000r 2               ;  .macro ?? ; 87	1000 0111	??
000000r 2                 .macro LDABA WReg ; Load byte from memory address stored in WReg into AL register
000000r 2               	.byte $88+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro LDAA WReg ; Load byte from memory address stored in WReg into AL register
000000r 2               	.byte $98+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; 96	1001 0110	??
000000r 2               ;  .macro ?? ; 97	1001 0111	??
000000r 2               
000000r 2                 .macro STABL Lit ; Store byte of AL register into literal address (Not possible?)
000000r 2               	.byte $A0
000000r 2               	.byte Lit
000000r 2               	.endmacro
000000r 2                 .macro STAL Lit ; Store word of AW register into literal address (Not possible?)
000000r 2               	.byte $B0
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro STABD Direct ; Store byte of AL register into direct address
000000r 2               	.byte $A1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STAD Direct ; Store word of AW register into direct address
000000r 2               	.byte $B1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STABI Indirect ; Store byte of AL register into indirect address
000000r 2               	.byte $A2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STAI Indirect ; Store word of AW register into indirect address
000000r 2               	.byte $B2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STABR Rel ; Store byte of AL register into direct Program Counter offset by N address
000000r 2               	BRel $a3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STAR Rel ; Store word of AW register into direct Program Counter offset by N address
000000r 2               	BRel $b3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STABRI Rel ; Store byte of AL register into indirect Program Counter offset by N address
000000r 2               	BRel $a4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STARI Rel ; Store word of AW register into indirect Program Counter offset by N address
000000r 2               	BRel $b4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STABX WReg,Mod,Offset ; Store byte of AL register into indexed register
000000r 2               	.byte $A5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro STAX WReg,Mod,Offset ; Store word of AW register into indexed register
000000r 2               	.byte $B5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; A6	1010 0110	??
000000r 2               ;  .macro ?? ; A7	1010 0111	??
000000r 2                 .macro STABA WReg ; Store AL register to memory address stored in WReg
000000r 2               	.byte $A8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro STAA WReg ; Store AW register to memory address stored in WReg
000000r 2               	.byte $B8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ; .macro ?? ; B6	1011 0110	??
000000r 2               ; .macro ?? ; B7	1011 0111	??
000000r 2               
000000r 2               
000000r 2                 .macro LDBBL Lit ; Load literal address into BL register
000000r 2               	.byte $C0
000000r 2               	.byte Lit
000000r 2               	.endmacro
000000r 2                 .macro LDBL Lit ; Load literal address into BW register
000000r 2               	.byte $D0
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro LDBBD Direct ; Load direct address into BL register
000000r 2               	.byte $C1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDBD Direct ; Load direct address into BW register
000000r 2               	.byte $D1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDBBI Indirect ; Load indirect address into BL register
000000r 2               	.byte $C2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDBI Indirect ; Load indirect address into BW register
000000r 2               	.byte $D2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDBBR Rel ; Load direct Program Counter offset by N address into BL register
000000r 2               	BRel $c3,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBR Rel ; Load direct Program Counter offset by N address into BW register
000000r 2               	BRel $d3,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBBRI Rel ; Load indirect Program Counter offset by N address into BL register
000000r 2               	BRel $c4,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBRI Rel ; Load indirect Program Counter offset by N address into BW register
000000r 2               	BRel $d4,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDBBX WReg,Mod,Offset ; Load indexed register into BL register
000000r 2               	.byte $C5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro LDBX WReg,Mod,Offset ; Load indexed register into BW register
000000r 2               	.byte $D5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; C6	1100 0110	??
000000r 2               ;  .macro ?? ; C7	1100 0111	??
000000r 2               
000000r 2                 .macro LDBBA WReg ; Load byte from memory address stored in WReg into BL register
000000r 2               	.byte $C8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro LDBA WReg ; Load word from memory address stored in WReg into BW register
000000r 2               	.byte $D8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; D6	1101 0110	??
000000r 2               ;  .macro ?? ; D7	1101 0111	??
000000r 2               
000000r 2                 .macro STBBL Lit ; Store byte of BL register into literal address (Not possible?)
000000r 2               	.byte $E0
000000r 2               	.byte Lit
000000r 2               	.endmacro
000000r 2                 .macro STBL Lit ; Store BW into literal address (Not possible?)
000000r 2               	.byte $F0
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro STBBD Direct ; Store BL into direct address
000000r 2               	.byte $E1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STBD Direct ; Store BW into direct address
000000r 2               	.byte $F1
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STBBI Indirect ; Store BL into indirect address
000000r 2               	.byte $E2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STBI Indirect ; Store BW into indirect address
000000r 2               	.byte $F2
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STBBR Rel ; Store BL into direct Program Counter offset by N address
000000r 2               	BRel $e3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBR Rel ; Store BW into direct Program Counter offset by N address
000000r 2               	BRel $f3,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBBRI Rel ; Store BL into indirect Program Counter offset by N address
000000r 2               	BRel $e4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBRI Rel ; Store BW into indirect Program Counter offset by N address
000000r 2               	BRel $f4,Rel
000000r 2               	.endmacro
000000r 2                 .macro STBBX WReg,Mod,Offset ; Store BL into indexed register
000000r 2               	.byte $E5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro STBX WReg,Mod,Offset ; Store BW into indexed register
000000r 2               	.byte $F5
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; E6	1110 0110	??
000000r 2               ;  .macro ?? ; E7	1110 0111	??
000000r 2                 .macro STBBA WReg ; Store byte from BL register to memory address stored in WReg
000000r 2               	.byte $E8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2                 .macro STBA WReg ; Store BW to memory address stored in WReg
000000r 2               	.byte $F8+((WReg/2)&7)
000000r 2               	.endmacro
000000r 2               
000000r 2               ;  .macro ?? ; F6	1111 0110	??
000000r 2               ;  .macro ?? ; F7	1111 0111	??
000000r 2               
000000r 2               
000000r 2                 .macro LDXL Lit ; Load immediate into XW
000000r 2               	.byte $60
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro LDXD Direct ;	Load direct address into XW
000000r 2               	.byte $61
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro LDXI Indirect ; Load indirect address into XW
000000r 2               	.byte $62
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro LDXR Rel ; Load direct Program Counter offset by N address into XW
000000r 2               	BRel $63,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDXRI Rel ; Load indirect Program Counter offset by N address into XW
000000r 2               	BRel $64,Rel
000000r 2               	.endmacro
000000r 2                 .macro LDXX WReg,Mod,Offset ; Load indexed mode register into XW
000000r 2               	.byte $65
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ??	; 66	0110 0110	??
000000r 2               ;  .macro ??	; 67	0110 0111	??
000000r 2                 .macro STXL Lit ; Store XW into literal address (Not possible?)
000000r 2               	.byte $68
000000r 2               	.dbyt Lit
000000r 2               	.endmacro
000000r 2                 .macro STXD Direct ; Store XW into direct address
000000r 2               	.byte $69
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro STXI Indirect ; Store XW into indirect address
000000r 2               	.byte $6A
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro STXR Rel ; Store XW into direct Program Counter offset by N address
000000r 2               	BRel $6b,Rel
000000r 2               	.endmacro
000000r 2                 .macro STXRI Rel ; Store XW into indirect Program Counter offset by N address
000000r 2               	BRel $6c,Rel
000000r 2               	.endmacro
000000r 2                 .macro STXX WReg,Mod,Offset ; Store XW into indexed register
000000r 2               	.byte $6D
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               ;  .macro ??	; 6E	0110 1110	??
000000r 2               ;  .macro ??	; 6F	0110 1111	??
000000r 2               
000000r 2               ;  .macro ??	; $70
000000r 2                 .macro JMPD Direct ; Jump to direct address
000000r 2               	.byte $71
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro JMPI Indirect ; Jump to indirect address
000000r 2               	.byte $72
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro JMPR Rel ; Jump to direct Program Counter offset by N address
000000r 2               	BRel $73,Rel
000000r 2               	.endmacro
000000r 2                 .macro JMPRI Rel ; Jump to indirect Program Counter offset by N address
000000r 2               	BRel $74,Rel
000000r 2               	.endmacro
000000r 2                 .macro JMPX WReg,Mod,Offset ;Jump to indexed mode register
000000r 2               	.byte $75
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2                 .macro SYSCALL	; Call interrupt level 15
000000r 2               	.byte $76
000000r 2               	.endmacro
000000r 2               ;  .macro ?? ; 77	0111 0111	??
000000r 2               
000000r 2               ;  .macro ?? ; 78 ??
000000r 2                 .macro JSRD Direct ; Jump to subroutine at direct address
000000r 2               	.byte $79
000000r 2               	.dbyt Direct
000000r 2               	.endmacro
000000r 2                 .macro JSRI Indirect ; Jump to subroutine at indirect address
000000r 2               	.byte $7A
000000r 2               	.dbyt Indirect
000000r 2               	.endmacro
000000r 2                 .macro JSRR Rel ; Jump to subroutine at Program Counter offset by N address
000000r 2               	BRel $7b,Rel
000000r 2               	.endmacro
000000r 2                 .macro JSRRI Rel ; Jump to subroutine at indirect Program Counter offset by N address
000000r 2               	BRel $7c,Rel
000000r 2               	.endmacro
000000r 2                 .macro JSRX WReg,Mod,Offset ; Jump to subroutine at indexed mode register
000000r 2               	.byte $7D
000000r 2               	ModBytes WReg,Mod,Offset
000000r 2               	.endmacro
000000r 2               
000000r 2                 .macro MEMCPY
000000r 2               	.byte $f7
000000r 2               	.endmacro
000000r 2               
000000r 2               
000000r 1               
000000r 1               
000000r 1               ; handy constants
000000r 1               
000000r 1               ; Sector size is a bit of a mess on Centurion.  Many devices use 400 byte sectors.
000000r 1               ;   How to map that to FORTH 1024 byte screens is unfinished.
000000r 1               SectorSize =256		; sector size in bytes
000000r 1               NBUF =1024/SectorSize	; number of buffers desired in RAM
000000r 1               			;     (SectorSize*NBUF >= 1024 bytes)
000000r 1               Sectors	=800		; sectors per drive
000000r 1               			;    forcing high drive to zero
000000r 1               SECTL	=2*Sectors	; sector limit for two drives
000000r 1               
000000r 1               
000000r 1               ; Error, Warning, and other messages - external text starting on on screens 4
000000r 1               Err_0			=  0 ; abort with no message
000000r 1               Err_StackUnderflow	=  1 ; EMPTY STACK
000000r 1               Err_DictionaryFull	=  2 ; DICTIONARY FULL
000000r 1               ; Err_3			=  3 ; HAS INCORRECT ADDRESS MODE
000000r 1               Err_IsntUnique		=  4 ; ISN'T UNIQUE
000000r 1               ;  5
000000r 1               ; Err_06 		=  6 ; DISC RANGE
000000r 1               Err_StackOverflow	=  7 ; stack overflow
000000r 1               Err_8			=  8 ; disk i/o error
000000r 1               ;  9
000000r 1               ; 10
000000r 1               ; 11
000000r 1               ; 12
000000r 1               ; 13
000000r 1               ; 14
000000r 1               Err_TriadFooter		  = 15  ; TRIAD footer message
000000r 1               ; 16
000000r 1               Err_CompileOnly		  = $11 ; COMPILATION ONLY, USE IN DEFINITION
000000r 1               Err_ExecuteOnly		  = $12 ; EXECUTION ONLY
000000r 1               Err_ConditionalsNotPaired = $13 ; CONDITIONALS NOT PAIRED
000000r 1               Err_DefinitionNotFinished = $14 ; DEFINITION NOT FINISHED
000000r 1               Err_InProtectedDictionary = $15 ; IN PROTECTED DICTIONARY
000000r 1               Err_UseOnlyWhenLoading    = $16 ; USE ONLY WHEN LOADING
000000r 1               ; $17
000000r 1               ; $18 DECLARE VOCABULARY
000000r 1               
000000r 1               
000000r 1               	.org $7000 ; more uninitialized RAM
007000  1               
007000  1               DictTop:	; From here downward to the top of the dictionary is free
007000  1               		; space where the user's applications are compiled.
007000  1               
007000  1  xx xx        VUse:	.res 2		; the address of the block buffer to use next, as the least recently written.
007002  1  xx xx        VPrev:	.res 2		; the address of the disc buffer most recently referenced.
007004  1               			;   The UPDATE command marks this buffer to be later written to disc.
007004  1               
007004  1  xx xx xx xx  TIBX:	.res 86		; terminal input buffer
007008  1  xx xx xx xx  
00700C  1  xx xx xx xx  
007010  1  xx xx xx xx  
007014  1  xx xx xx xx  
007018  1  xx xx xx xx  
00701C  1  xx xx xx xx  
007020  1  xx xx xx xx  
007024  1  xx xx xx xx  
007028  1  xx xx xx xx  
00702C  1  xx xx xx xx  
007030  1  xx xx xx xx  
007034  1  xx xx xx xx  
007038  1  xx xx xx xx  
00703C  1  xx xx xx xx  
007040  1  xx xx xx xx  
007044  1  xx xx xx xx  
007048  1  xx xx xx xx  
00704C  1  xx xx xx xx  
007050  1  xx xx xx xx  
007054  1  xx xx xx xx  
007058  1  xx xx        
00705A  1               
00705A  1  xx xx        RamDiskStart: .res 2	; RAM disk: start of memory buffer
00705C  1  xx xx        RamDiskCount: .res 2	; RAM disk: count of 256 byte blocks
00705E  1               
00705E  1               UArea:
00705E  1               VUser: ; user area variables, partially initialized from ORIG
00705E  1  xx xx        	.res 2	;+00:	ptr latest ROM word
007060  1  xx xx        VBS:	.res 2	;+02:	backspace char
007062  1  xx xx        VUA:	.res 2	;+04:	ptr user area (direct page IS the user area)
007064  1  xx xx        VS0:	.res 2	;+06:	initial value for the parameter stack index
007066  1  xx xx        VR0:	.res 2	;+08:	initial value of the return stack ptr
007068  1  xx xx        VTIB:	.res 2	;+0a:	Address of the terminal input buffer.
00706A  1  xx xx        VWidth:	.res 2	;+0c:	Maximum number of letters saved in the compilation of a definitions' name.
00706C  1               		;	It must be 1 thru 31, with a default of 31.
00706C  1               		;	The name char cound and its natural chars are saved, up to the value in WIDTH.
00706C  1               		;	The value may be changed at any time within the above limits.
00706C  1  xx xx        VWarning: .res 2 ;+0e:	Value controlling messages.  If =1 disc is present,
00706E  1               		;	and screen 4 of drive 0 is the base location for messages.
00706E  1               		;	If =0, no disc is present and messages will be presented by number.
00706E  1               		;	if =-1, execute (ABORT) for a user specified procedure.
00706E  1               		;	See MESSAGE ERROR
00706E  1  xx xx        VFence:	.res 2	;+10:	Address below which FORGETting is trapped.
007070  1               		;	To forget below this point the user must alter the contents of FENCE .
007070  1  xx xx        VDP:	.res 2	;+12:	ptr next available dictionary memory location
007072  1               		;	The value may be read by HERE and altered by ALLOT.
007072  1               
007072  1  xx xx        VVoc_Link: .res 2 ;+14:	Containing the address of a field in the definition of the most
007074  1               		;	recently created vocabulary.  All vocabulary names are linked by these fields
007074  1               		;	to allow control for FORGETting thru multiple vocabularys.
007074  1               
007074  1  xx xx        VBlk:	.res 2	;+16:	Block (not screen) number being interpreted.
007076  1               		;	If 0, input is being taken from the terminal input buffer.
007076  1               		;	https://forth-standard.org/standard/block/BLK
007076  1  xx xx        VIn:	.res 2	;+18:	Byte offset within the current input text buffer (terminal or disc)
007078  1               		;	from which the next text will be accepted.
007078  1               		;	WORD uses and moves the value of IN .
007078  1  xx xx        VOut:	.res 2	;+1A:	A value incremented by EMIT .
00707A  1               		;	The user may alter and examine OUT to control display formatting.
00707A  1  xx xx        VScr:	.res 2	;+1C:	the screen number most recently referenced by LIST .
00707C  1               		;	https://forth-standard.org/standard/block/SCR
00707C  1  xx xx        VOffset: .res 2	;+1E:	disc block offset in 1024 byte blocks
00707E  1               		;	The contents of OFFSET is added to the block number in BLOCK
00707E  1               		;	to allow for this selection.
00707E  1               		;	May contain a block offset to disc drives.  The contents
00707E  1               		;	of OFFSET is added to the stack number by BLOCK .
00707E  1               		;	Messages by MESSAGE are independent of OFFSET .
00707E  1               		;	See BLOCK DR0 DR1 MESSAGE
00707E  1               
00707E  1  xx xx        VContext: .res 2 ;+20:	pointer to the vocabulary within which dictionary searching will first begin.
007080  1               		;	ptr to dictionary head in vocabulary word
007080  1  xx xx        VCurrent: .res 2 ;+22:	ptr to dictionary head in vocabulary word
007082  1  xx xx        VState:	.res 2	;+24:	compilation state.  A non-zero value indicates compilation.
007084  1               		;	The value itself may be implementation dependent.
007084  1               		;	Contains the compilation-state flag.
007084  1               		;	STATE is true when in compilation state, false otherwise.
007084  1               		;	The true value in STATE is non-zero, but is otherwise implementation-defined.
007084  1               		;	Only the following standard words alter the value in STATE:
007084  1               		;		: (colon), ; (semicolon), ABORT, QUIT, :NONAME, [ (left-bracket), ] (right-bracket).
007084  1               		;	Note: A program shall not directly alter the contents of STATE.
007084  1  xx xx        VBase:	.res 2	;+26:	the current number base used for input and output conversion; 2..36
007086  1  xx xx        VDPL:	.res 2	;+28:	number of digits to the rights of the decimal on double integer input.
007088  1               		;	It may also be used to hold output column location of a decimal point,
007088  1               		;	in user generated formatting.
007088  1               		;	The default value on signel number input is -1 (none).
007088  1  xx xx        VFld:	.res 2	;+2A:	for control of number output field width. Presently unused in fig-FORTH.
00708A  1  xx xx        VCSP:	.res 2	;+2C:	temporarily store the stack pointer position, for compilation error checking.
00708C  1  xx xx        VRNum:	.res 2	;+2E:	may contain the location of an editing cursor, or other file related function.
00708E  1  xx xx        VHld:	.res 2	;+30:	holds the address of the latest char of text during numeric output conversion.
007090  1  xx           VLineComment: .res 1	; ignore remainder of line
007091  1               
007091  1               
007091  1  xx xx        VFPtr:	.res 2	;	Floating-point stack ptr
007093  1  xx xx        VFpLo:	.res 2	;	"                " lo limit
007095  1  xx xx        VFpHi:	.res 2	;	"                " hi limit
007097  1               
007097  1  xx xx xx xx  BOS:	.res $7e	; parameter (data) stack
00709B  1  xx xx xx xx  
00709F  1  xx xx xx xx  
0070A3  1  xx xx xx xx  
0070A7  1  xx xx xx xx  
0070AB  1  xx xx xx xx  
0070AF  1  xx xx xx xx  
0070B3  1  xx xx xx xx  
0070B7  1  xx xx xx xx  
0070BB  1  xx xx xx xx  
0070BF  1  xx xx xx xx  
0070C3  1  xx xx xx xx  
0070C7  1  xx xx xx xx  
0070CB  1  xx xx xx xx  
0070CF  1  xx xx xx xx  
0070D3  1  xx xx xx xx  
0070D7  1  xx xx xx xx  
0070DB  1  xx xx xx xx  
0070DF  1  xx xx xx xx  
0070E3  1  xx xx xx xx  
0070E7  1  xx xx xx xx  
0070EB  1  xx xx xx xx  
0070EF  1  xx xx xx xx  
0070F3  1  xx xx xx xx  
0070F7  1  xx xx xx xx  
0070FB  1  xx xx xx xx  
0070FF  1  xx xx xx xx  
007103  1  xx xx xx xx  
007107  1  xx xx xx xx  
00710B  1  xx xx xx xx  
00710F  1  xx xx xx xx  
007113  1  xx xx        
007115  1  xx xx xx xx  TOS:	.res 8		; top of parameter stack, with extra padding
007119  1  xx xx xx xx  
00711D  1               
00711D  1               ;N:	.res 8		; scratch workspace.
00711D  1               
00711D  1  xx xx xx xx  RStack:	.res 128	; return stack
007121  1  xx xx xx xx  
007125  1  xx xx xx xx  
007129  1  xx xx xx xx  
00712D  1  xx xx xx xx  
007131  1  xx xx xx xx  
007135  1  xx xx xx xx  
007139  1  xx xx xx xx  
00713D  1  xx xx xx xx  
007141  1  xx xx xx xx  
007145  1  xx xx xx xx  
007149  1  xx xx xx xx  
00714D  1  xx xx xx xx  
007151  1  xx xx xx xx  
007155  1  xx xx xx xx  
007159  1  xx xx xx xx  
00715D  1  xx xx xx xx  
007161  1  xx xx xx xx  
007165  1  xx xx xx xx  
007169  1  xx xx xx xx  
00716D  1  xx xx xx xx  
007171  1  xx xx xx xx  
007175  1  xx xx xx xx  
007179  1  xx xx xx xx  
00717D  1  xx xx xx xx  
007181  1  xx xx xx xx  
007185  1  xx xx xx xx  
007189  1  xx xx xx xx  
00718D  1  xx xx xx xx  
007191  1  xx xx xx xx  
007195  1  xx xx xx xx  
007199  1  xx xx xx xx  
00719D  1               RStackE:
00719D  1               
00719D  1               UserSize: ; end of user ara variables
00719D  1               ;	.assert <*<$100, error, "user area overflowed"
00719D  1               
00719D  1               
00719D  1               
00719D  1  xx xx xx xx  RndState: .res 4	; random # state
0071A1  1               
0071A1  1  xx xx xx xx  DArea:	.res (SectorSize+4)*NBUF ; disk buffer space.
0071A5  1  xx xx xx xx  
0071A9  1  xx xx xx xx  
0071AD  1  xx xx xx xx  
0071B1  1  xx xx xx xx  
0071B5  1  xx xx xx xx  
0071B9  1  xx xx xx xx  
0071BD  1  xx xx xx xx  
0071C1  1  xx xx xx xx  
0071C5  1  xx xx xx xx  
0071C9  1  xx xx xx xx  
0071CD  1  xx xx xx xx  
0071D1  1  xx xx xx xx  
0071D5  1  xx xx xx xx  
0071D9  1  xx xx xx xx  
0071DD  1  xx xx xx xx  
0071E1  1  xx xx xx xx  
0071E5  1  xx xx xx xx  
0071E9  1  xx xx xx xx  
0071ED  1  xx xx xx xx  
0071F1  1  xx xx xx xx  
0071F5  1  xx xx xx xx  
0071F9  1  xx xx xx xx  
0071FD  1  xx xx xx xx  
007201  1  xx xx xx xx  
007205  1  xx xx xx xx  
007209  1  xx xx xx xx  
00720D  1  xx xx xx xx  
007211  1  xx xx xx xx  
007215  1  xx xx xx xx  
007219  1  xx xx xx xx  
00721D  1  xx xx xx xx  
007221  1  xx xx xx xx  
007225  1  xx xx xx xx  
007229  1  xx xx xx xx  
00722D  1  xx xx xx xx  
007231  1  xx xx xx xx  
007235  1  xx xx xx xx  
007239  1  xx xx xx xx  
00723D  1  xx xx xx xx  
007241  1  xx xx xx xx  
007245  1  xx xx xx xx  
007249  1  xx xx xx xx  
00724D  1  xx xx xx xx  
007251  1  xx xx xx xx  
007255  1  xx xx xx xx  
007259  1  xx xx xx xx  
00725D  1  xx xx xx xx  
007261  1  xx xx xx xx  
007265  1  xx xx xx xx  
007269  1  xx xx xx xx  
00726D  1  xx xx xx xx  
007271  1  xx xx xx xx  
007275  1  xx xx xx xx  
007279  1  xx xx xx xx  
00727D  1  xx xx xx xx  
007281  1  xx xx xx xx  
007285  1  xx xx xx xx  
007289  1  xx xx xx xx  
00728D  1  xx xx xx xx  
007291  1  xx xx xx xx  
007295  1  xx xx xx xx  
007299  1  xx xx xx xx  
00729D  1  xx xx xx xx  
0072A1  1  xx xx xx xx  
0072A5  1  xx xx xx xx  
0072A9  1  xx xx xx xx  
0072AD  1  xx xx xx xx  
0072B1  1  xx xx xx xx  
0072B5  1  xx xx xx xx  
0072B9  1  xx xx xx xx  
0072BD  1  xx xx xx xx  
0072C1  1  xx xx xx xx  
0072C5  1  xx xx xx xx  
0072C9  1  xx xx xx xx  
0072CD  1  xx xx xx xx  
0072D1  1  xx xx xx xx  
0072D5  1  xx xx xx xx  
0072D9  1  xx xx xx xx  
0072DD  1  xx xx xx xx  
0072E1  1  xx xx xx xx  
0072E5  1  xx xx xx xx  
0072E9  1  xx xx xx xx  
0072ED  1  xx xx xx xx  
0072F1  1  xx xx xx xx  
0072F5  1  xx xx xx xx  
0072F9  1  xx xx xx xx  
0072FD  1  xx xx xx xx  
007301  1  xx xx xx xx  
007305  1  xx xx xx xx  
007309  1  xx xx xx xx  
00730D  1  xx xx xx xx  
007311  1  xx xx xx xx  
007315  1  xx xx xx xx  
007319  1  xx xx xx xx  
00731D  1  xx xx xx xx  
007321  1  xx xx xx xx  
007325  1  xx xx xx xx  
007329  1  xx xx xx xx  
00732D  1  xx xx xx xx  
007331  1  xx xx xx xx  
007335  1  xx xx xx xx  
007339  1  xx xx xx xx  
00733D  1  xx xx xx xx  
007341  1  xx xx xx xx  
007345  1  xx xx xx xx  
007349  1  xx xx xx xx  
00734D  1  xx xx xx xx  
007351  1  xx xx xx xx  
007355  1  xx xx xx xx  
007359  1  xx xx xx xx  
00735D  1  xx xx xx xx  
007361  1  xx xx xx xx  
007365  1  xx xx xx xx  
007369  1  xx xx xx xx  
00736D  1  xx xx xx xx  
007371  1  xx xx xx xx  
007375  1  xx xx xx xx  
007379  1  xx xx xx xx  
00737D  1  xx xx xx xx  
007381  1  xx xx xx xx  
007385  1  xx xx xx xx  
007389  1  xx xx xx xx  
00738D  1  xx xx xx xx  
007391  1  xx xx xx xx  
007395  1  xx xx xx xx  
007399  1  xx xx xx xx  
00739D  1  xx xx xx xx  
0073A1  1  xx xx xx xx  
0073A5  1  xx xx xx xx  
0073A9  1  xx xx xx xx  
0073AD  1  xx xx xx xx  
0073B1  1  xx xx xx xx  
0073B5  1  xx xx xx xx  
0073B9  1  xx xx xx xx  
0073BD  1  xx xx xx xx  
0073C1  1  xx xx xx xx  
0073C5  1  xx xx xx xx  
0073C9  1  xx xx xx xx  
0073CD  1  xx xx xx xx  
0073D1  1  xx xx xx xx  
0073D5  1  xx xx xx xx  
0073D9  1  xx xx xx xx  
0073DD  1  xx xx xx xx  
0073E1  1  xx xx xx xx  
0073E5  1  xx xx xx xx  
0073E9  1  xx xx xx xx  
0073ED  1  xx xx xx xx  
0073F1  1  xx xx xx xx  
0073F5  1  xx xx xx xx  
0073F9  1  xx xx xx xx  
0073FD  1  xx xx xx xx  
007401  1  xx xx xx xx  
007405  1  xx xx xx xx  
007409  1  xx xx xx xx  
00740D  1  xx xx xx xx  
007411  1  xx xx xx xx  
007415  1  xx xx xx xx  
007419  1  xx xx xx xx  
00741D  1  xx xx xx xx  
007421  1  xx xx xx xx  
007425  1  xx xx xx xx  
007429  1  xx xx xx xx  
00742D  1  xx xx xx xx  
007431  1  xx xx xx xx  
007435  1  xx xx xx xx  
007439  1  xx xx xx xx  
00743D  1  xx xx xx xx  
007441  1  xx xx xx xx  
007445  1  xx xx xx xx  
007449  1  xx xx xx xx  
00744D  1  xx xx xx xx  
007451  1  xx xx xx xx  
007455  1  xx xx xx xx  
007459  1  xx xx xx xx  
00745D  1  xx xx xx xx  
007461  1  xx xx xx xx  
007465  1  xx xx xx xx  
007469  1  xx xx xx xx  
00746D  1  xx xx xx xx  
007471  1  xx xx xx xx  
007475  1  xx xx xx xx  
007479  1  xx xx xx xx  
00747D  1  xx xx xx xx  
007481  1  xx xx xx xx  
007485  1  xx xx xx xx  
007489  1  xx xx xx xx  
00748D  1  xx xx xx xx  
007491  1  xx xx xx xx  
007495  1  xx xx xx xx  
007499  1  xx xx xx xx  
00749D  1  xx xx xx xx  
0074A1  1  xx xx xx xx  
0074A5  1  xx xx xx xx  
0074A9  1  xx xx xx xx  
0074AD  1  xx xx xx xx  
0074B1  1  xx xx xx xx  
0074B5  1  xx xx xx xx  
0074B9  1  xx xx xx xx  
0074BD  1  xx xx xx xx  
0074C1  1  xx xx xx xx  
0074C5  1  xx xx xx xx  
0074C9  1  xx xx xx xx  
0074CD  1  xx xx xx xx  
0074D1  1  xx xx xx xx  
0074D5  1  xx xx xx xx  
0074D9  1  xx xx xx xx  
0074DD  1  xx xx xx xx  
0074E1  1  xx xx xx xx  
0074E5  1  xx xx xx xx  
0074E9  1  xx xx xx xx  
0074ED  1  xx xx xx xx  
0074F1  1  xx xx xx xx  
0074F5  1  xx xx xx xx  
0074F9  1  xx xx xx xx  
0074FD  1  xx xx xx xx  
007501  1  xx xx xx xx  
007505  1  xx xx xx xx  
007509  1  xx xx xx xx  
00750D  1  xx xx xx xx  
007511  1  xx xx xx xx  
007515  1  xx xx xx xx  
007519  1  xx xx xx xx  
00751D  1  xx xx xx xx  
007521  1  xx xx xx xx  
007525  1  xx xx xx xx  
007529  1  xx xx xx xx  
00752D  1  xx xx xx xx  
007531  1  xx xx xx xx  
007535  1  xx xx xx xx  
007539  1  xx xx xx xx  
00753D  1  xx xx xx xx  
007541  1  xx xx xx xx  
007545  1  xx xx xx xx  
007549  1  xx xx xx xx  
00754D  1  xx xx xx xx  
007551  1  xx xx xx xx  
007555  1  xx xx xx xx  
007559  1  xx xx xx xx  
00755D  1  xx xx xx xx  
007561  1  xx xx xx xx  
007565  1  xx xx xx xx  
007569  1  xx xx xx xx  
00756D  1  xx xx xx xx  
007571  1  xx xx xx xx  
007575  1  xx xx xx xx  
007579  1  xx xx xx xx  
00757D  1  xx xx xx xx  
007581  1  xx xx xx xx  
007585  1  xx xx xx xx  
007589  1  xx xx xx xx  
00758D  1  xx xx xx xx  
007591  1  xx xx xx xx  
007595  1  xx xx xx xx  
007599  1  xx xx xx xx  
00759D  1  xx xx xx xx  
0075A1  1  xx xx xx xx  
0075A5  1  xx xx xx xx  
0075A9  1  xx xx xx xx  
0075AD  1  xx xx xx xx  
0075B1  1               DAreaEnd:
0075B1  1               
0075B1  1               
0075B1  1               
0075B1  1               INL_End = $0909	; RSR, & ha_inline code end marker
0075B1  1               
0075B1  1               ; Bit masks in "flags & length" byte of word header:
0075B1  1               ha_inline    = $80 ; can be compiled by copying inline
0075B1  1               ha_immediate = $40 ; aka precedence bit
0075B1  1               ha_smudge    = $20 ; do not find this word by name
0075B1  1               ha_length    = $1f ; # of chars in name (including ones > vWidth)
0075B1  1               
0075B1  1                 .macro FHdr name,flags ; compile a FORTH word header
0075B1  1               	.local L1,L2
0075B1  1               L1:	.byte name	;name of word as a string (no leading count byte)
0075B1  1               L2:	.byte L2-L1+flags ;flags & length of name (see ha_*)
0075B1  1               	.dbyt DictLink	;LFA: link to previous word's CFA in vocabulary chain
0075B1  1               DictLink .set *
0075B1  1               ;		The fields above are at negative offsets from label.
0075B1  1               ;label:	;NFA: same as CFA.  We access header fields using negative offsets from CFA.
0075B1  1               ;	;CFA: CPU6 code starts here.  This is the address that "find" returns.
0075B1  1               ;		Words that want PFA (eg CREATEd words) will have a JSR to the handler code,
0075B1  1               ;		  followed by the PFA area.  The JSR return address (+1) points to the PFA.
0075B1  1               	.endmacro
0075B1  1               
0075B1  1               DictLink .set 0 ; used to build the FHdr link chain.
0075B1  1               		; 0 indicates end of vocabulary list
0075B1  1               
0075B1  1               ; The FHdr line of each entry shows a symbolic description of the action of the procedure
0075B1  1               ; on the parameter stack.  The symbols indicate the order in which input parameters have
0075B1  1               ; been placed on the stack.  "---" indicate the execution point; any parameters left on the
0075B1  1               ; stack are listed after.  In this notation, the top of the stack is to the right.
0075B1  1               ;
0075B1  1               ; The symbols include:
0075B1  1               ;
0075B1  1               ; addr	memory address
0075B1  1               ; b	8 bit byte (i.e. hi 8  bits zero)
0075B1  1               ; c	ASCII character (hi 9 bits zero)
0075B1  1               ; d	32 bit signed double integer, most significant portion with sign on top of stack.
0075B1  1               ; f	boolean flag. 0=false, non-zero=true
0075B1  1               ; ff	boolean false flag=0
0075B1  1               ; n	16 bit signed integer number
0075B1  1               ; u	16 bit unsigned integer
0075B1  1               ; tf	boolean true flag (non-zero)
0075B1  1               ;
0075B1  1               ; The capital letters on the right show definition characteristics:
0075B1  1               ;   (not used)
0075B1  1               ; C	May only be used within a colon definition. A digit indicates number of memory
0075B1  1               ;	addresses used, if other than one.
0075B1  1               ; E	intended for execution only.
0075B1  1               ; L0	Level Zero definition of FORTH-78
0075B1  1               ; L1	Level One definition of FORTH-78
0075B1  1               ; P	Has precedence bit (immediate) set. Will execute even when compliling.
0075B1  1               ; U	A user variable.
0075B1  1               ;
0075B1  1               ; Unless otherwise noted, all references to numbers are for 16 bit signed integers.
0075B1  1               ; 16 bit numbers are big-endian, like the hardware.
0075B1  1               ; For 32 bit signed double numbers, the most significant part (with the sign) is on top.
0075B1  1               ;
0075B1  1               ; All arithmetic is implicitly 16 bit signed integer math, with error and underflow
0075B1  1               ; indication unspecified.
0075B1  1               
0075B1  1               
0075B1  1               	.org $200 ; start of program RAM ==========================================================
000200  1               ORIG:	; Start of boot up parameters.  34 bytes.
000200  1               
000200  1  01           Enter:	NOPC		; +00 User cold entry point
000201  1  71 17 CC     	JMPD Cold
000204  1  01           ReEnter: NOPC		; +04 User warm entry point
000205  1  71 17 DA     	JMPD Warm
000208  1  00 00 00 00  	.dbyt 0,0	; +08 CPU6 in radix-36
00020C  1               
00020C  1               ; Initial values copied to VUser.
00020C  1               ; These values are altered as you make permanent extensions to your installation.
00020C  1  1E 81        	.dbyt NTOP	; +0C Last word
00020E  1  00 08        	.dbyt $08	; +0E Backspace Character
000210  1  70 5E        	.dbyt UArea	; +10 Initial User Area
000212  1  71 15        	.dbyt TOS	; +12 S0 - Initial Top of Stack (in user area)
000214  1  71 9D        	.dbyt RStackE	; +14 R0 - Initial Top of Return Stack
000216  1  70 04        	.dbyt TIBX	; +16 Initial terminal input buffer
000218  1  00 1F        	.dbyt 31	; +18 Initial name field width (not used)
00021A  1  00 00        	.dbyt 0		; +1A Initial warning
00021C  1  1E EE        	.dbyt TOP	; +1C Initial fence address
00021E  1  1E EE        	.dbyt TOP	; +1E Initial top of dictionary
000220  1  17 05        	.dbyt Forth+3+2	; +20 Initial Vocabulary link ptr.
000222  1               
000222  1               
000222  1  45 6D 70 74   FHdr 'Empty-RStack',0 ; ( -- ) ( R: ... -- )  empty the return stack (load from user variable R0 ) .
000226  1  79 2D 52 53  
00022A  1  74 61 63 6B  
00022E  1  0C 00 00     
000231  1               EmptyRStack:
000231  1  91 70 66     	LDAD VR0	; load S
000234  1  5F           	XAS
000235  1  75 40        	JMPX XW,ModBRB,0 ; return (without adjusting S)
000237  1               
000237  1               
000237  1               	.if 0
000237  1                FHdr 'RP!',0 ; ( -- )  FIG alias
000237  1               	JMPR EmptyRStack
000237  1               	.endif
000237  1               
000237  1               
000237  1               	.if 0
000237  1                FHdr 'RDepth',0 ; ( -- n )  return # of cells on return stack (not including this routine)
000237  1               	LDAD VR0
000237  1               	SUB AW,SW
000237  1               	INR AW,2
000237  1               	JMPR Depth3
000237  1               	.endif
000237  1               
000237  1               
000237  1  45 6D 70 74   FHdr 'Empty-Stack',0 ; ( ... -- )  empty the param stack.
00023B  1  79 2D 53 74  
00023F  1  61 63 6B 0B  
000243  1  02 31        
000245  1               EmptyStack:
000245  1  91 70 64     	LDAD VS0		; load the parameter stack pointer from S0
000248  1  5E           	XAZ
000249  1  D1 70 95     	LDBD VFpHi		; also empty FP stack
00024C  1  F1 70 91     	STBD VFPtr
00024F  1  09           	RSR
000250  1               
000250  1               
000250  1               	.if 0
000250  1                FHdr 'SP!',0 ; ( -- )  FIG alias
000250  1               	JMPR EmptyStack
000250  1               	.endif
000250  1               
000250  1               
000250  1  44 65 70 74   FHdr 'Depth',0 ; ( -- n )  https://forth-standard.org/standard/core/DEPTH
000254  1  68 05 02 45  
000258  1               ; Return the address of the stack position to the top of the stack, as it was before Depth was executed.
000258  1               ; (e.g. 1 2 Depth  . . .  would type 2 2 1 )
000258  1  91 70 64     Depth:	LDAD VS0
00025B  1  51 80        	SUB AW,ZW
00025D  1  33 01        Depth3:	IVR AW,1		; A = VS0-param_stack_ptr
00025F  1  3C           	SRA			; /2
000260  1  B5 82        	STAX ZW,ModBMRB,0	; push it
000262  1  09           	RSR			; return
000263  1               
000263  1               
000263  1               	.if 0
000263  1                FHdr 'SP@',0 ; ( -- n )  FIG alias
000263  1               	JMPR Depth
000263  1               	.endif
000263  1               
000263  1               
000263  1  44 72 6F 70   FHdr 'Drop',ha_inline ; ( n -- )  Drop a number from the stack.
000267  1  84 02 58     
00026A  1                  ; https://forth-standard.org/standard/core/DROP
00026A  1  30 81        Drop:	INR ZW,2		; bump the param stack index up 1 cell
00026C  1  09 09        	.dbyt INL_End		; return
00026E  1               
00026E  1               
00026E  1  32 44 72 6F   FHdr '2Drop',ha_inline ; ( n n -- )
000272  1  70 85 02 6A  
000276  1                  ; https://forth-standard.org/standard/core/TwoDROP
000276  1               TwoDrop:
000276  1  30 83        	INR ZW,4		; bump the param stack index up 2 cells
000278  1  09 09        	.dbyt INL_End		; return
00027A  1               
00027A  1               
00027A  1  52 6F 74 03   FHdr 'Rot',0 ; ( n1 n2 n3 -- n2 n3 n1 )  https://forth-standard.org/standard/core/ROT
00027E  1  02 76        
000280  1                  ; Rotate the top 3 values on the stack, bringing the 3rd to the top.
000280  1                  ; https://forth-standard.org/standard/core/ROT
000280  1  95 88 04     Rot:	LDAX ZW,ModNBRB,4	; Y=n1
000283  1  D5 88 02     	LDBX ZW,ModNBRB,2	; A=n2
000286  1  F5 88 04     	STBX ZW,ModNBRB,4	; store 3rd-on-stack
000289  1  DC           	LDBA ZW			; A=n1
00028A  1  F5 88 02     	STBX ZW,ModNBRB,2	; store next-on-stack
00028D  1  BC           	STAA ZW			; store top-on-stack
00028E  1  09           	RSR			; return
00028F  1               
00028F  1               
00028F  1               	.if 1
00028F  1  2D 52 6F 74   FHdr '-Rot',0 ; ( n1 n2 n3 -- n3 n1 n2 )  rotate the other way
000293  1  04 02 80     
000296  1               MRot:	; small but slow
000296  1  7B E8        	JSRR Rot
000298  1  73 E6        	JMPR Rot
00029A  1               	.endif
00029A  1               
00029A  1               
00029A  1               	.if 0
00029A  1                FHdr '2Rot',0 ; ( d1 d2 d3 -- d2 d3 d1 )  Rotate the top 3 values on the stack
00029A  1                  ; https://forth-standard.org/standard/double/TwoROT
00029A  1               TwoRot:	DCR ZW,2		; do hi word
00029A  1               	JSRR @10
00029A  1               	INR ZW,2		; do lo word
00029A  1               @10:	LDAX ZW,ModNBRB,8+2	; Y=n1
00029A  1               	LDBX ZW,ModNBRB,4+2	; A=n2
00029A  1               	STBX ZW,ModNBRB,8+2	; store 3rd-on-stack
00029A  1               	LDBX ZW,ModNBRB,0+2	; A=n1
00029A  1               	STBX ZW,ModNBRB,4+2	; store next-on-stack
00029A  1               	STAX ZW,ModNBRB,0+2	; store top-on-stack
00029A  1               	RSR			; return
00029A  1               	.endif
00029A  1               
00029A  1               
00029A  1               	.if 0
00029A  1                FHdr 'Roll',0 ; ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
00029A  1                  ; Remove u. Rotate u+1 items on the top of the stack.
00029A  1                  ; An ambiguous condition exists if there are less than u+2 items on the stack before ROLL is executed.
00029A  1                  ; https://forth-standard.org/standard/core/ROLL
00029A  1               Roll:	JSRD ABort ;???
00029A  1               	.endif
00029A  1               
00029A  1               
00029A  1  53 77 61 70   FHdr 'Swap',0 ; ( n1 n2 -- n2 n1 )  Exchange the top 2 values on the stack.
00029E  1  04 02 96     
0002A1  1                  ; https://forth-standard.org/standard/core/SWAP
0002A1  1  D5 81        Swap:	LDBX ZW,ModBRPB,0	; B=n2
0002A3  1  9C           	LDAA ZW			; A=n1
0002A4  1  FC           	STBA ZW			; store next-on-stack
0002A5  1  B5 82        	STAX ZW,ModBMRB,0	; store top-on-stack
0002A7  1  09           	RSR			; return
0002A8  1               
0002A8  1               
0002A8  1  32 53 77 61   FHdr '2Swap',0 ; ( d1 d2 -- d2 d1 )  Exchange top 2 double values on the stack.
0002AC  1  70 05 02 A1  
0002B0  1                  ; https://forth-standard.org/standard/core/TwoSWAP
0002B0  1               TwoSwap:
0002B0  1  D5 88 06     	LDBX ZW,ModNBRB,6	; swap lo words
0002B3  1  95 88 02     	LDAX ZW,ModNBRB,2
0002B6  1  F5 88 02     	STBX ZW,ModNBRB,2
0002B9  1  B5 88 06     	STAX ZW,ModNBRB,6
0002BC  1  D5 88 04     	LDBX ZW,ModNBRB,4	; swap hi words
0002BF  1  9C           	LDAA ZW
0002C0  1  FC           	STBA ZW
0002C1  1  B5 88 04     	STAX ZW,ModNBRB,4
0002C4  1  09           	RSR			; return
0002C5  1               
0002C5  1               
0002C5  1  4F 76 65 72   FHdr 'Over',ha_inline ; ( n1 n2 -- n1 n2 n1 )  Copy the second stack value, placing it as the new top.
0002C9  1  84 02 B0     
0002CC  1                  ; https://forth-standard.org/standard/core/OVER
0002CC  1  95 88 02     Over:	LDAX ZW,ModNBRB,2	; get next-on-stack
0002CF  1  B5 82        	STAX ZW,ModBMRB,0	; push it
0002D1  1  09 09        	.dbyt INL_End		; return
0002D3  1               
0002D3  1               
0002D3  1  32 4F 76 65   FHdr '2Over',0 ; ( d1 d2 -- d1 d2 d1 )  Copy the 2nd double value
0002D7  1  72 05 02 CC  
0002DB  1                  ; https://forth-standard.org/standard/core/TwoOVER
0002DB  1               TwoOver:
0002DB  1  D5 88 04     	LDBX ZW,ModNBRB,4	; get d1.hi word
0002DE  1  95 88 06     	LDAX ZW,ModNBRB,6	; get d1.lo word
0002E1  1  73 16        	JMPR PushBA
0002E3  1               
0002E3  1               
0002E3  1  44 75 70 83   FHdr 'Dup',ha_inline ; ( n1 -- n1 n1 )  Duplicate the value on the stack.
0002E7  1  02 DB        
0002E9  1                  ; https://forth-standard.org/standard/core/DUP
0002E9  1  9C           Dup:	LDAA ZW
0002EA  1  B5 82        PushA:	STAX ZW,ModBMRB,0 ; pushes AW register to the param stack.
0002EC  1  09 09        	.dbyt INL_End
0002EE  1               
0002EE  1               
0002EE  1  32 44 75 70   FHdr '2Dup',0 ; ( d1 -- d1 d1 )  Duplicate double value o the stack.
0002F2  1  04 02 E9     
0002F5  1                  ; https://forth-standard.org/standard/core/TwoDUP
0002F5  1  DC           TwoDup:	LDBA ZW			; get hi word
0002F6  1  95 88 02     	LDAX ZW,ModNBRB,2	; get lo word
0002F9  1  B5 82        PushBA:	STAX ZW,ModBMRB,0	; push lo word
0002FB  1  F5 82        	STBX ZW,ModBMRB,0	; push hi word
0002FD  1  09           	RSR
0002FE  1               
0002FE  1               
0002FE  1  3F 44 75 70   FHdr '?Dup',0	; ( n1 -- n1    ) (if zero)
000302  1  04 02 F5     
000305  1               		; ( n1 -- n1 n1 ) (non-zero)
000305  1                  ; Reproduce n1 only if it is non-zero.  This is usually used to copy a
000305  1                  ; value just before IF, to eliminate the need for an ELSE part to drop it.
000305  1                  ; https://forth-standard.org/standard/core/qDUP
000305  1  9C           QDup:	LDAA ZW			; n1<>0?
000306  1  15 E2        	BNZ PushA		;   push it & return
000308  1  09           	RSR			; return
000309  1               
000309  1               
000309  1               	.if 0
000309  1                FHdr '-Dup',0	; FIG alias
000309  1               	JMPR QDup
000309  1               	.endif
000309  1               
000309  1               
000309  1               	.if 1
000309  1  50 69 63 6B   FHdr 'Pick',0 ; ( xu...x1 x0 u -- xu...x1 x0 xu )  Remove u. Copy the xu to the top of the stack.
00030D  1  04 03 05     
000310  1                  ; An ambiguous condition exists if there are less than u+2 items on the stack before PICK is executed.
000310  1                  ; https://forth-standard.org/standard/core/PICK
000310  1  9C           	LDAA ZW			; get u
000311  1  38           	INA
000312  1  3D           	SLA
000313  1  50 80        	ADD AW,ZW
000315  1  98           	LDAA AW
000316  1  BC           	STAA ZW
000317  1  09           	RSR
000318  1               	.endif
000318  1               
000318  1               
000318  1  4E 69 70 83   FHdr 'Nip',ha_inline ; ( n1 n2 -- n2 )   Drop the first item below the top of stack.
00031C  1  03 10        
00031E  1                  ; https://forth-standard.org/standard/core/NIP
00031E  1  95 81        Nip:	LDAX ZW,ModBRPB,0	; pop n2
000320  1  BC           Nip3:	STAA ZW			; store as top-of-stack
000321  1  09 09        	.dbyt INL_End		; return
000323  1               
000323  1               
000323  1  32 4E 69 70   FHdr '2Nip',0 ; ( d1 d2 -- d2 )
000327  1  04 03 1E     
00032A  1  D5 81        TwoNip:	LDBX ZW,ModBRPB,0	; pop d2.hi
00032C  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
00032E  1  FC           	STBA ZW			; store d.hi
00032F  1  B5 88 02     	STAX ZW,ModNBRB,2	; store d.lo
000332  1  09           	RSR
000333  1               
000333  1               
000333  1               	.if 1
000333  1  54 75 63 6B   FHdr 'Tuck',0 ; ( x1 x2 -- x2 x1 x2 )
000337  1  04 03 2A     
00033A  1                  ; Copy the first (top) stack item below the second stack item.
00033A  1                  ; https://forth-standard.org/standard/core/TUCK
00033A  1  95 81        Tuck:	LDAX ZW,ModBRPB,0	; pop x2
00033C  1  DC           	LDBA ZW			; get x1
00033D  1  BC           	STAA ZW
00033E  1  F5 82        	STBX ZW,ModBMRB,0
000340  1  B5 82        	STAX ZW,ModBMRB,0
000342  1  09           	RSR
000343  1               	.endif
000343  1               
000343  1               
000343  1  4D 69 6E 03   FHdr 'Min',0 ; ( n1 n2 -- n3 )	Leave the smaller of two numbers.
000347  1  03 3A        
000349  1                  ; https://forth-standard.org/standard/core/MIN
000349  1  95 81        Min:	LDAX ZW,ModBRPB,0	; pop n2
00034B  1  DC           	LDBA ZW			; get n1
00034C  1  59           	SAB			; B=A-B
00034D  1  12 0F        	BF Max3			; overflow?
00034F  1  16 CF        Min3:	BM Nip3			; keep n2, return
000351  1  09           	RSR			; return
000352  1               
000352  1               
000352  1  4D 61 78 03   FHdr 'Max',0 ; ( n1 n2 -- n3 )	Leave the greater of two numbers.
000356  1  03 49        
000358  1                  ; https://forth-standard.org/standard/core/MAX
000358  1  95 81        Max:	LDAX ZW,ModBRPB,0	; pop n2
00035A  1  DC           	LDBA ZW			; get n1
00035B  1  59           	SAB			; B=A-B
00035C  1  12 F1        	BF Min3			; overflow?
00035E  1  17 C0        Max3:	BP Nip3			; keep n2, return
000360  1  09           	RSR			; return
000361  1               
000361  1               
000361  1  44 4D 61 78   FHdr 'DMax',0 ; ( d1 d2 -- d )
000365  1  04 03 58     
000368  1                  ; https://forth-standard.org/standard/double/DMAX
000368  1  95 81        DMax:	LDAX ZW,ModBRPB,0	; pop d2.hi
00036A  1  5C           	XAY
00036B  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
00036D  1  DC           	LDBA ZW			; get d1.hi
00036E  1  51 62        	SUB BW,YW		; compare hi words
000370  1  15 07        	BNZ @3
000372  1  D5 88 02     	LDBX ZW,ModNBRB,2	; get d1.lo
000375  1  59           	SAB
000376  1  10 05        	BL DMax7
000378  1  09           	RSR
000379  1               
000379  1  12 23        @3:	BF DMin3
00037B  1  16 06        DMax3:	BM DMax9
00037D  1  55 62        DMax7:	XFR BW,YW		; store d.hi
00037F  1  FC           	STBA ZW
000380  1  B5 88 02     	STAX ZW,ModNBRB,2	; store d.lo
000383  1  09           DMax9:	RSR
000384  1               
000384  1               
000384  1  44 4D 69 6E   FHdr 'DMin',0 ; ( d1 d2 -- d )
000388  1  04 03 68     
00038B  1                  ; https://forth-standard.org/standard/double/DMIN
00038B  1  95 81        DMin:	LDAX ZW,ModBRPB,0	; pop d2.hi
00038D  1  5C           	XAY
00038E  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
000390  1  DC           	LDBA ZW			; get d1.hi
000391  1  51 62        	SUB BW,YW		; compare hi words
000393  1  15 07        	BNZ @3
000395  1  D5 88 02     	LDBX ZW,ModNBRB,2	; get d1.lo
000398  1  59           	SAB
000399  1  11 E2        	BNL DMax7
00039B  1  09           	RSR
00039C  1               
00039C  1  12 DD        @3:	BF DMax3
00039E  1  16 DD        DMin3:	BM DMax7
0003A0  1  09           	RSR
0003A1  1               
0003A1  1               
0003A1  1               	.if 0
0003A1  1                FHdr 'Within',0 ; ( n1 | u1 n2 | u2 n3 | u3 -- flag )
0003A1  1                  ; Perform a comparison of a test value n1 | u1 with a lower limit n2 | u2 and an upper limit n3 | u3,
0003A1  1                  ; returning true if either (n2 | u2 < n3 | u3 and (n2 | u2 <= n1 | u1 and n1 | u1 < n3 | u3)) or
0003A1  1                  ; (n2 | u2 > n3 | u3 and (n2 | u2 <= n1 | u1 or n1 | u1 < n3 | u3)) is true, returning false otherwise.
0003A1  1                  ; An ambiguous condition exists n1 | u1, n2 | u2, and n3 | u3 are not all the same type.
0003A1  1                  ; https://forth-standard.org/standard/core/WITHIN
0003A1  1               Within:	JSRD Abort ;???
0003A1  1               	.endif
0003A1  1               
0003A1  1               
0003A1  1               ; Note that top-of-return-stack lives in X in the calling routine,
0003A1  1               ; so inline code is not R@="LDAA SW", >R="STAX SW,ModBMRB,0", R>="LDAX SW,ModBRPB,0"
0003A1  1               
0003A1  1  52 40 02 03   FHdr 'R@',0 ; ( R: n -- n ) ( -- n )  Copy the top of the return stack to the param stack.
0003A5  1  8B           
0003A6  1                  ; https://forth-standard.org/standard/core/RFetch
0003A6  1  9D           RAt:	LDAA SW			; get top of return stack of my caller
0003A7  1  B5 82        	STAX ZW,ModBMRB,0	; push it
0003A9  1  09           	RSR			; return
0003AA  1               
0003AA  1               	.if 0
0003AA  1                FHdr 'R',0 ; ( -- n )  FIG alias
0003AA  1               	JMPR RAt
0003AA  1               	.endif
0003AA  1               
0003AA  1               
0003AA  1  52 44 72 6F   FHdr 'RDrop',0 ; ( R: n -- )  ; drop top return stack entry
0003AE  1  70 05 03 A6  
0003B2  1  30 A1        	INR SW,2
0003B4  1  09           	RSR
0003B5  1               
0003B5  1               
0003B5  1  52 3E 02 03   FHdr 'R>',0 ; ( R: n -- ) ( -- n )  https://forth-standard.org/standard/core/Rfrom
0003B9  1  B2           
0003BA  1                  ; Remove the top value from the return stack and leave it on the param stack.
0003BA  1                  ; See >R and R@
0003BA  1  95 A1        RFrom:	LDAX SW,ModBRPB,0	; pop return stack, skipping my return addr in X
0003BC  1  B5 82        	STAX ZW,ModBMRB,0	; push n
0003BE  1  09           	RSR
0003BF  1               
0003BF  1               
0003BF  1  3E 52 02 03   FHdr '>R',0 ; ( n -- ) ( R: -- n )   https://forth-standard.org/standard/core/toR
0003C3  1  BA           
0003C4  1                  ; Remove a numbef from the computation stack and place as the most accessable
0003C4  1                  ; on the return stack.  Use should be balanced with R> in the same definition.
0003C4  1                  ; https://forth-standard.org/standard/core/toR
0003C4  1  95 81        ToR:	LDAX ZW,ModBRPB,0	; pop n
0003C6  1  B5 A2        	STAX SW,ModBMRB,0	; push n on return stack
0003C8  1  09           	RSR
0003C9  1               
0003C9  1               
0003C9  1  32 3E 52 03   FHdr '2>R',0 ; ( d -- ) ( R: -- d )
0003CD  1  03 C4        
0003CF  1                  ; https://forth-standard.org/standard/core/TwotoR
0003CF  1  95 81        TwoToR:	LDAX ZW,ModBRPB,0	; pop d.hi
0003D1  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d.lo
0003D3  1  7E 03        	PUSH AH,4		; push d.lo & d.hi
0003D5  1  09           	RSR
0003D6  1               
0003D6  1               
0003D6  1  32 52 40 03   FHdr '2R@',0 ; ( -- d ) ( R: d -- d )
0003DA  1  03 CF        
0003DC  1                  ; https://forth-standard.org/standard/core/TwoRFetch
0003DC  1  DD           TwoRAt:	LDBA SW			; get d.hi
0003DD  1  95 A8 02     	LDAX SW,ModNBRB,2	; get d.lo
0003E0  1  71 02 F9     	JMPD PushBA
0003E3  1               
0003E3  1               
0003E3  1  32 52 3E 03   FHdr '2R>',0 ; ( R: d -- ) ( -- d )
0003E7  1  03 DC        
0003E9  1                  ; https://forth-standard.org/standard/core/TwoRfrom
0003E9  1               TwoRFrom:
0003E9  1  D5 A1        	LDBX SW,ModBRPB,0	; pop d.hi
0003EB  1  95 A1        	LDAX SW,ModBRPB,0	; pop d.lo
0003ED  1  71 02 F9     	JMPD PushBA
0003F0  1               
0003F0  1               
0003F0  1               	.if 0
0003F0  1               
0003F0  1                FHdr 'NR>',0
0003F0  1                  ; Interpretation:
0003F0  1                  ;   Interpretation semantics for this word are undefined.
0003F0  1                  ; Execution:
0003F0  1                  ;   ( -- i * x +n ) ( R: j * x +n -- )
0003F0  1                  ;   Retrieve the items previously stored by an invocation of N>R. n is the number of items placed on the data stack.
0003F0  1                  ;   It is an ambiguous condition if NR> is used with data not stored by N>R.
0003F0  1                  ; https://forth-standard.org/standard/tools/NRfrom
0003F0  1               NRFrom:
0003F0  1               	JSRD Abort ;???
0003F0  1               
0003F0  1               
0003F0  1                FHdr 'N>R',0
0003F0  1                  ; Interpretation:
0003F0  1                  ;   Interpretation semantics for this word are undefined.
0003F0  1                  ; Execution:
0003F0  1                  ;   ( i * n +n -- ) ( R: -- j * x +n )
0003F0  1                  ;   Remove n+1 items from the data stack and store them for later retrieval by NR>.
0003F0  1                  ;   The return stack may be used to store the data. Until this data has been retrieved by NR>:
0003F0  1                  ;   * this data will not be overwritten by a subsequent invocation of N>R and
0003F0  1                  ;   * a program may not access data placed on the return stack before the invocation of N>R.
0003F0  1                  ; https://forth-standard.org/standard/tools/NtoR
0003F0  1               NToR:
0003F0  1               	JSRD Abort ;???
0003F0  1               
0003F0  1               	.endif
0003F0  1               
0003F0  1               
0003F0  1  49 6E 76 65   FHdr 'Invert',ha_inline ; ( n1 -- n2 ) Invert bits
0003F4  1  72 74 86 03  
0003F8  1  E9           
0003F9  1                  ; see 0= for logical negate
0003F9  1                  ; https://forth-standard.org/standard/core/INVERT
0003F9  1  9C           Invert:	LDAA ZW
0003FA  1  33 00        	IVR AW,0
0003FC  1  BC           	STAA ZW
0003FD  1  09 09        	.dbyt INL_End
0003FF  1               
0003FF  1               
0003FF  1  41 6E 64 83   FHdr 'And',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical and of n1 and n2 as n3.
000403  1  03 F9        
000405  1                  ; https://forth-standard.org/standard/core/AND
000405  1  95 81        AndD:	LDAX ZW,ModBRPB,0	; pop n2
000407  1  DC           	LDBA ZW			; get n1
000408  1  5A           	NAB			; and
000409  1  FC           	STBA ZW			; store result
00040A  1  09 09        	.dbyt INL_End		; return
00040C  1               
00040C  1               
00040C  1  4F 72 82 04   FHdr 'Or',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical or of two 16 bit values.
000410  1  05           
000411  1                  ; https://forth-standard.org/standard/core/OR
000411  1  95 81        Or:	LDAX ZW,ModBRPB,0	; pop n2
000413  1  DC           	LDBA ZW			; get n1
000414  1  53 02        	ORI BW,AW
000416  1  FC           	STBA ZW			; store result
000417  1  09 09        	.dbyt INL_End		; return
000419  1               
000419  1               
000419  1  58 6F 72 83   FHdr 'Xor',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical exclusive-or of two values.
00041D  1  04 11        
00041F  1                  ; https://forth-standard.org/standard/core/XOR
00041F  1  95 81        Xor:	LDAX ZW,ModBRPB,0	; pop n2
000421  1  DC           XorA:	LDBA ZW			; get n1
000422  1  54 02        	ORE BW,AW
000424  1  FC           	STBA ZW			; store result
000425  1  09 09        	.dbyt INL_End		; return
000427  1               
000427  1               
000427  1  32 2A 82 04   FHdr '2*',ha_inline ; ( x1 -- x2 )  signed multiply by 2 (signed left shift)
00042B  1  1F           
00042C  1                  ; x2 is the result of shifting x1 one bit toward the most-significant bit, filling the vacated
00042C  1                  ; least-significant bit with zero.
00042C  1                  ; https://forth-standard.org/standard/core/TwoTimes
00042C  1               TwoStar:
00042C  1  9C           	LDAA ZW
00042D  1  3D           	SLA
00042E  1  BC           	STAA ZW
00042F  1  09 09        	.dbyt INL_End
000431  1               
000431  1               
000431  1  44 32 2A 03   FHdr 'D2*',0 ; ( xd1 -- xd2 )  signed double multiply by 2 (signed left shift)
000435  1  04 2C        
000437  1                  ; xd2 is the result of shifting xd1 one bit toward the most-significant bit, filling the vacated
000437  1                  ; least-significant bit with zero.
000437  1                  ; https://forth-standard.org/standard/double/DTwoTimes
000437  1               DTwoStar:
000437  1  95 88 02     	LDAX ZW,ModNBRB,2
00043A  1  3D           	SLA
00043B  1  B5 88 02     	STAX ZW,ModNBRB,2
00043E  1  9C           	LDAA ZW
00043F  1  37 00        	RLR AW,1
000441  1  BC           	STAA ZW
000442  1  09           	RSR
000443  1               
000443  1               
000443  1  32 2F 82 04   FHdr '2/',ha_inline ; ( x1 -- x2 )  signed divide by  (signed right shift)
000447  1  37           
000448  1                  ; x2 is the result of shifting x1 one bit toward the least-significant bit, leaving the most significant
000448  1                  ; bit unchanged.
000448  1                  ; https://forth-standard.org/standard/core/TwoDiv
000448  1               TwoSlash:
000448  1  9C           	LDAA ZW
000449  1  3C           	SRA
00044A  1  BC           	STAA ZW
00044B  1  09 09        	.dbyt INL_End
00044D  1               
00044D  1               
00044D  1  44 32 2F 03   FHdr 'D2/',0 ; ( xd1 -- xd2 )  signed double divide by 2 (signed right shift)
000451  1  04 48        
000453  1                  ; xd2 is the result of shifting xd1 one bit toward the least-significant bit, leaving the most significant
000453  1                  ; bit unchanged.
000453  1                  ; https://forth-standard.org/standard/double/DTwoDiv
000453  1  9C           DDiv2:	LDAA ZW
000454  1  3C           	SRA
000455  1  BC           	STAA ZW
000456  1  95 88 02     	LDAX ZW,ModNBRB,2
000459  1  36 00        	RRR AW,1
00045B  1  B5 88 02     	STAX ZW,ModNBRB,2
00045E  1  09           	RSR
00045F  1               
00045F  1               
00045F  1  55 32 2F 83   FHdr 'U2/',ha_inline ; ( u -- u/2 )   Unsigned divide by two (logical right shift)
000463  1  04 53        
000465  1                  ; https://forth-standard.org/standard/core/TwoDiv "Shr"
000465  1  9C           UDiv2:	LDAA ZW
000466  1  07           	RL
000467  1  36 00        	RRR AW,1
000469  1  BC           	STAA ZW
00046A  1  09 09        	.dbyt INL_End
00046C  1               
00046C  1               
00046C  1               	.if 0
00046C  1                FHdr 'UD2/',0 ; ( ud1 -- ud2 ) unsigned double divide by 2 (logical right shift)
00046C  1               	JSRR UDiv2
00046C  1               	LDAX ZW,ModNBRB,2
00046C  1               	RRR AW,1
00046C  1               	STAX ZW,ModNBRB,2
00046C  1               	RSR
00046C  1               	.endif
00046C  1               
00046C  1               
00046C  1  72 6F 72 83   FHdr 'ror',ha_inline ; ( x1 -- x2 )   Logical right-rotation of one bit-place
000470  1  04 65        
000472  1  9C           	LDAA ZW
000473  1  36 00        	RRR AW,1
000475  1  BC           	STAA ZW
000476  1  09 09        	.dbyt INL_End
000478  1               
000478  1               
000478  1  72 6F 6C 83   FHdr 'rol',ha_inline ; ( x1 -- x2 )   Logical left-rotation of one bit-place
00047C  1  04 72        
00047E  1  9C           	LDAA ZW
00047F  1  37 00        	RLR AW,1
000481  1  BC           	STAA ZW
000482  1  09 09        	.dbyt INL_End
000484  1               
000484  1               
000484  1               	.if 1
000484  1               
000484  1  4C 53 68 69   FHdr 'LShift',0 ; ( x1 u -- x2 )  Perform a logical left shift of u bit-places on x1, giving x2.
000488  1  66 74 06 04  
00048C  1  7E           
00048D  1                  ; Put zeroes into the least significant bits vacated by the shift.
00048D  1                  ; An ambiguous condition exists if u is greater than or equal to the number of bits in a cell.
00048D  1                  ; https://forth-standard.org/standard/core/LSHIFT
00048D  1  95 81        LShift:	LDAX ZW,ModBRPB,0	; pop u
00048F  1  14 07        	BZ @9
000491  1  DC           	LDBA ZW			; get x1
000492  1  35 20        @2:	SLR BW,1
000494  1  29           	DCAB
000495  1  15 FB        	BNZ @2
000497  1  FC           	STBA ZW			; save x2
000498  1  09           @9:	RSR
000499  1               
000499  1               
000499  1  52 53 68 69   FHdr 'RShift',0 ; ( x1 u -- x2 )  Perform a logical right shift of u bit-places on x1, giving x2.
00049D  1  66 74 06 04  
0004A1  1  8D           
0004A2  1                  ; Put zeroes into the most significant bits vacated by the shift.
0004A2  1                  ; An ambiguous condition exists if u is greater than or equal to the number of bits in a cell.
0004A2  1                  ; https://forth-standard.org/standard/core/RSHIFT
0004A2  1  95 81        RShift:	LDAX ZW,ModBRPB,0	; pop u
0004A4  1  14 08        	BZ @9
0004A6  1  DC           	LDBA ZW			; get x1
0004A7  1  07           @2:	RL
0004A8  1  36 20        	RRR BW,1
0004AA  1  29           	DCAB
0004AB  1  15 FA        	BNZ @2
0004AD  1  FC           	STBA ZW			; save x2
0004AE  1  09           @9:	RSR
0004AF  1               
0004AF  1               	.endif
0004AF  1               
0004AF  1               
0004AF  1  31 2B 82 04   FHdr '1+',ha_inline ; ( n1 -- n2 )  Increment n1 by 1
0004B3  1  A2           
0004B4  1                  ; https://forth-standard.org/standard/core/OnePlus
0004B4  1               OnePlus:
0004B4  1  9C           	LDAA ZW			; get n1
0004B5  1  38           	INA
0004B6  1  BC           	STAA ZW			; store n2
0004B7  1  09 09        	.dbyt INL_End		; return
0004B9  1               
0004B9  1               
0004B9  1  32 2B 82 04   FHdr '2+',ha_inline ; ( n1 -- n2 )  Increment n1 by 2
0004BD  1  B4           
0004BE  1               TwoPlus:
0004BE  1  9C           	LDAA ZW			; get n1
0004BF  1  30 01        	INR AW,2
0004C1  1  BC           	STAA ZW			; store n2
0004C2  1  09 09        	.dbyt INL_End		; return
0004C4  1               
0004C4  1               
0004C4  1  31 2D 82 04   FHdr '1-',ha_inline ; ( n1 -- n2 )  Decrement n1 by 1
0004C8  1  BE           
0004C9  1                  ; https://forth-standard.org/standard/core/OneMinus
0004C9  1               OneMinus:
0004C9  1  9C           	LDAA ZW			; get n1
0004CA  1  39           	DCA
0004CB  1  BC           	STAA ZW			; store n2
0004CC  1  09 09        	.dbyt INL_End		; return
0004CE  1               
0004CE  1               
0004CE  1  32 2D 82 04   FHdr '2-',ha_inline ; ( n1 -- n2 ) Decrement n1 by 2
0004D2  1  C9           
0004D3  1               TwoMinus:
0004D3  1  9C           	LDAA ZW			; get n1
0004D4  1  31 01        	DCR AW,2		; subtract 2
0004D6  1  BC           	STAA ZW			; store n2
0004D7  1  09 09        	.dbyt INL_End
0004D9  1               
0004D9  1               
0004D9  1  2B 81 04 D3   FHdr '+',ha_inline ; ( n1 n2 -- n_sum )  n_sum = n1 + n2
0004DD  1                  ; https://forth-standard.org/standard/core/Plus
0004DD  1  95 81        Plus:	LDAX ZW,ModBRPB,0	; pop n2
0004DF  1  DC           PlusA:	LDBA ZW			; get n1
0004E0  1  58           	AAB
0004E1  1  FC           	STBA ZW			; store n_sum
0004E2  1  09 09        	.dbyt INL_End		; return
0004E4  1               
0004E4  1               
0004E4  1  4D 2B 02 04   FHdr 'M+',0 ; ( d1 n -- d2 )  d2 = d1 + signed(n)
0004E8  1  DD           
0004E9  1                 ; https://forth-standard.org/standard/double/MPlus
0004E9  1  95 81        MPlus:	LDAX ZW,ModBRPB,0	; pop n
0004EB  1  D5 88 02     MPlusA:	LDBX ZW,ModNBRB,2	; get d1.lo
0004EE  1  58           	AAB
0004EF  1  F5 88 02     	STBX ZW,ModNBRB,2
0004F2  1  DC           	LDBA ZW			; get d1.hi
0004F3  1  11 02        	BNL @4			; carry?
0004F5  1  30 20        	INR BW,1
0004F7  1  5C           @4:	XAY			; test n sign
0004F8  1  17 02        	BP @6
0004FA  1  31 20        	DCR BW,1
0004FC  1  FC           @6:	STBA ZW
0004FD  1  09           	RSR
0004FE  1               
0004FE  1               
0004FE  1  44 2B 02 04   FHdr 'D+',0 ; ( d1 d2 -- d_sum )  d_sum = d1 + d2
000502  1  E9           
000503  1  95 81        DPlus:	LDAX ZW,ModBRPB,0 ; pop d2.hi
000505  1  5C           	XAY
000506  1  95 81        	LDAX ZW,ModBRPB,0 ; pop d2.lo
000508  1  D5 88 02     	LDBX ZW,ModNBRB,2 ; get d1.lo
00050B  1  58           	AAB
00050C  1  F5 88 02     	STBX ZW,ModNBRB,2 ; store d1.lo
00050F  1  11 02        	BNL @2		; carry?
000511  1  30 60        	INR YW,1
000513  1               @2:
000513  1  9C           	LDAA ZW		; get d1.hi
000514  1  50 60        	ADD AW,YW
000516  1  BC           	STAA ZW		; store d1.hi
000517  1  09           	RSR
000518  1               
000518  1               
000518  1  2D 81 05 03   FHdr '-',ha_inline ; ( n1 n2 -- n_diff )  n_diff=n1-n2
00051C  1                  ; https://forth-standard.org/standard/core/Minus
00051C  1               Subtract:
00051C  1  D5 81        	LDBX ZW,ModBRPB,0 ; pop n2
00051E  1  9C           	LDAA ZW		; get n1
00051F  1  59           	SAB
000520  1  FC           	STBA ZW		; store n_diff
000521  1  09 09        	.dbyt INL_End
000523  1               
000523  1               
000523  1  44 2D 02 05   FHdr 'D-',0 ; ( d1 d2 -- d )  d=d1-d2
000527  1  1C           
000528  1                  ; https://forth-standard.org/standard/double/DMinus
000528  1               DMinus:
000528  1                   .if 1
000528  1               	; short slower version
000528  1  7B 2F        	JSRR DNegate
00052A  1  73 D7        	JMPR DPlus
00052C  1                   .else
00052C  1               	; long faster version
00052C  1               	LDAX ZW,ModBRPB,0	; Y= d2.hi
00052C  1               	XAY
00052C  1               	LDBX ZW,ModBRPB,0	; B= dl.lo
00052C  1               	LDAX ZW,ModNBRB,2	; A= d1.lo
00052C  1               	SAB
00052C  1               	STBX ZW,ModNBRB,2
00052C  1               	LDAA ZW			; A= d1.hi
00052C  1               	XFR BW,YW
00052C  1               	SAB
00052C  1               	STAA ZW
00052C  1               	RSR
00052C  1                   .endif
00052C  1               
00052C  1               
00052C  1  4E 65 67 61   FHdr 'Negate',ha_inline ; ( n -- n )  Leave the two's complement of a number.
000530  1  74 65 86 05  
000534  1  28           
000535  1                  ; https://forth-standard.org/standard/core/NEGATE
000535  1  DC           Negate:	LDBA ZW		; get n
000536  1  33 21        Negat1:	IVR BW,1
000538  1  FC           	STBA ZW		; store n
000539  1  09 09        	.dbyt INL_End
00053B  1               
00053B  1               
00053B  1               	.if 0
00053B  1                FHdr "Minus",0 ; ( n -- n )  FIG alias
00053B  1               	JMPR Negate
00053B  1               	.endif
00053B  1               
00053B  1               
00053B  1  41 62 73 03   FHdr 'Abs',0 ; ( n -- u )  Leave the absolute value of n as u.
00053F  1  05 35        
000541  1  DC           Abs:	LDBA ZW		; n<0?
000542  1  16 F2        	BM Negat1	;   negate it & return
000544  1  09           	RSR		; return
000545  1               
000545  1               
000545  1  2B 2D 02 05   FHdr '+-',0 ; ( n1 n2 -- n3 )  Apply the sign of n2 to n1, which is left as n3.
000549  1  41           
00054A  1  95 81        PM:	LDAX ZW,ModBRPB,0 ; pop n2
00054C  1  16 E7        PMP:	BM Negate	;   negate n1 & return
00054E  1  09           	RSR		; return
00054F  1               
00054F  1               
00054F  1  44 4E 65 67   FHdr 'DNegate',0 ; ( d1 -- d2 )  Convert d1 to its double number two's complement.
000553  1  61 74 65 07  
000557  1  05 4A        
000559  1                  ; https://forth-standard.org/standard/double/DNEGATE
000559  1  D5 88 02     DNegate: LDBX ZW,ModNBRB,2 ; get d1.lo
00055C  1  3A           	CLA
00055D  1  59           	SAB
00055E  1  F5 88 02     	STBX ZW,ModNBRB,2 ; store d2.lo
000561  1  DC           	LDBA ZW		; get d1.hi
000562  1  10 01        	BL @3		; borrow?
000564  1  39           	DCA
000565  1               @3:
000565  1  59           	SAB
000566  1  FC           	STBA ZW		; store d2.hi
000567  1  09           	RSR
000568  1               
000568  1               
000568  1               	.if 0
000568  1                FHdr 'DMinus',0 ; ( d1 -- d2 )  FIG alias
000568  1               	JMPR DNegate
000568  1               	.endif
000568  1               
000568  1               
000568  1  44 41 62 73   FHdr 'DAbs',0 ; ( d -- ud )  Leave the absolute value ud of a double number.
00056C  1  04 05 59     
00056F  1                  ; https://forth-standard.org/standard/double/DABS
00056F  1  8C           DAbs:	LDABA ZW	; d<0?
000570  1  16 E7        	BM DNegate	;   negate d & return
000572  1  09           	RSR		; return
000573  1               
000573  1               
000573  1  44 2B 2D 03   FHdr 'D+-',0 ; ( d1 n -- d2 )  Apply the sign of n to the doulbe number d1, leaving it as d2.
000577  1  05 6F        
000579  1                  ; https://forth-standard.org/standard/double/DPlus
000579  1  95 81        DPM:	LDAX ZW,ModBRPB,0 ; pop n
00057B  1  16 DC        DPMP:	BM DNegate	;   negate d1 & return
00057D  1  09           	RSR		; return
00057E  1               
00057E  1               
00057E  1               	.if 1
00057E  1               
00057E  1  46 61 6C 73   FHdr 'False',ha_inline ; ( -- false )  Return a false flag.
000582  1  65 85 05 79  
000586  1                  ; https://forth-standard.org/standard/core/FALSE
000586  1  3A           False:	CLA
000587  1  B5 82        	STAX ZW,ModBMRB,0
000589  1  09 09        	.dbyt INL_End
00058B  1               
00058B  1               
00058B  1  54 72 75 65   FHdr 'True',ha_inline ; ( -- true )  Return a true flag.
00058F  1  84 05 86     
000592  1                  ; https://forth-standard.org/standard/core/TRUE
000592  1  32 01        True:	CLR AW,1
000594  1  B5 82        	STAX ZW,ModBMRB,0
000596  1  09 09        	.dbyt INL_End
000598  1               
000598  1               	.endif
000598  1               
000598  1               
000598  1  30 3C 02 05   FHdr '0<',0 ; ( n -- f )  Leave a bool n<0
00059C  1  92           
00059D  1                  ; https://forth-standard.org/standard/core/Zeroless
00059D  1               ZLessThan:
00059D  1  8C           	LDABA ZW		; test n
00059E  1  16 76        	BM True0
0005A0  1  71 06 25     	JMPD False0
0005A3  1               
0005A3  1               
0005A3  1  30 3E 02 05   FHdr '0>',0 ; ( n -- f )  Leave a bool n>0
0005A7  1  9D           
0005A8  1  9C           ZGt:	LDAA ZW			; test n
0005A9  1  16 7A        	BM False0
0005AB  1  14 78        	BZ False0
0005AD  1  73 67        	JMPR True0
0005AF  1               
0005AF  1               
0005AF  1  44 30 3C 03   FHdr 'D0<',0 ; ( d -- f ) f=(d<0)
0005B3  1  05 A8        
0005B5  1                  ; https://forth-standard.org/standard/double/DZeroless
0005B5  1               DZLessThan:
0005B5  1  95 81        	LDAX ZW,ModBRPB,0	; pop d.hi
0005B7  1  16 5D        	BM True0
0005B9  1  73 6A        	JMPR False0
0005BB  1               
0005BB  1               
0005BB  1  30 3D 02 05   FHdr '0=',0 ; ( n -- f )  Leave a bool n==0
0005BF  1  B5           
0005C0  1                  ; https://forth-standard.org/standard/core/ZeroEqual
0005C0  1  9C           ZEqual:	LDAA ZW			; test n
0005C1  1  14 53        	BZ True0
0005C3  1  73 60        	JMPR False0
0005C5  1               
0005C5  1               
0005C5  1  30 3C 3E 03   FHdr '0<>',0 ; ( n -- f )  Leave a bool n!=0
0005C9  1  05 C0        
0005CB  1                  ; https://forth-standard.org/standard/core/Zerone
0005CB  1               ZNEqual:
0005CB  1  9C           	LDAA ZW			; test n
0005CC  1  15 48        	BNZ True0
0005CE  1  09           	RSR
0005CF  1               
0005CF  1               
0005CF  1  44 30 3D 03   FHdr 'D0=',0 ; ( d -- f ) Leave a bool d==0
0005D3  1  05 CB        
0005D5  1                  ; https://forth-standard.org/standard/double/DZeroEqual
0005D5  1               DZEqual:
0005D5  1  95 81        	LDAX ZW,ModBRPB,0	; pop hi word
0005D7  1  15 4C        	BNZ False0
0005D9  1  DC           	LDBA ZW			; get lo word
0005DA  1  14 3A        	BZ True0
0005DC  1  73 47        	JMPR False0
0005DE  1               
0005DE  1               
0005DE  1  44 3D 02 05   FHdr 'D=',0 ; ( d1 d2 -- f )  f=(d1==d2)  double equal
0005E2  1  D5           
0005E3  1                  ; https://forth-standard.org/standard/double/DEqual
0005E3  1  95 81        DEqual:	LDAX ZW,ModBRPB,0	; pop d2.hi
0005E5  1  5C           	XAY
0005E6  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
0005E8  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d1.hi
0005EA  1  51 62        	SUB BW,YW		; compare hi words
0005EC  1  15 37        	BNZ False0
0005EE  1  DC           	LDBA ZW			; get d1.lo
0005EF  1  59           	SAB			; compare lo words
0005F0  1  15 33        	BNZ False0
0005F2  1  73 22        	JMPR True0
0005F4  1               
0005F4  1               
0005F4  1  44 3C 3E 03   FHdr 'D<>',0 ; ( d1 d2 -- f )  f=(d1!=d2)  double not equal
0005F8  1  05 E3        
0005FA  1               DNEqual:
0005FA  1  7B E7        	JSRR DEqual
0005FC  1  71 05 C0     	JMPD ZEqual
0005FF  1               
0005FF  1               
0005FF  1  3C 3E 02 05   FHdr '<>',0 ; ( x1 x2 -- flag)  https://forth-standard.org/standard/core/ne
000603  1  FA           
000604  1                  ; https://forth-standard.org/standard/core/Zerone
000604  1               NtoEqual:
000604  1  95 81        	LDAX ZW,ModBRPB,0	; pop x2
000606  1  DC           	LDBA ZW			; get x1
000607  1  59           	SAB			; x2<>x1?
000608  1  15 0C        	BNZ True0
00060A  1  FC           	STBA ZW			; flag=false
00060B  1  09           	RSR
00060C  1               
00060C  1               
00060C  1  3D 01 06 04   FHdr '=',0 ; ( x1 x2 -- flag )  Leave a true flag if x1=x2; otherwise leave a false flag.
000610  1                  ; https://forth-standard.org/standard/core/Equal
000610  1  95 81        Equal:	LDAX ZW,ModBRPB,0	; pop x2
000612  1  DC           	LDBA ZW			; get x1
000613  1  59           	SAB			; x2==x1?
000614  1  15 0F        	BNZ False0
000616  1  32 01        True0:	CLR AW,1		; flag=true
000618  1  BC           	STAA ZW
000619  1  09           	RSR
00061A  1               
00061A  1               
00061A  1  55 3C 02 06   FHdr 'U<',0 ; ( u1 u2 -- f )  f=u1<u2 (unsigned compare)
00061E  1  10           
00061F  1                  ; https://forth-standard.org/standard/core/Uless
00061F  1               ULessThan:
00061F  1  D5 81        	LDBX ZW,ModBRPB,0	; pop u2
000621  1  9C           	LDAA ZW			; get u1
000622  1  59           ULt3:	SAB			; n1<n2?
000623  1  11 F1        	BNL True0
000625  1  3A           False0:	CLA			; f=false
000626  1  BC           	STAA ZW
000627  1  09           	RSR
000628  1               
000628  1               
000628  1  55 3E 02 06   FHdr 'U>',0 ; ( u1 u2 -- f )  f=u1>u2 (unsigned compare)
00062C  1  1F           
00062D  1                  ; https://forth-standard.org/standard/core/Umore
00062D  1               UGreaterThan:
00062D  1  95 81        	LDAX ZW,ModBRPB,0	; pop u2
00062F  1  DC           	LDBA ZW			; get u1
000630  1  73 F0        	JMPR ULt3
000632  1               
000632  1               
000632  1  3C 01 06 2D   FHdr '<',0 ; ( n1 n2 -- f )  f=n1<n2 (signed compare)
000636  1                  ; https://forth-standard.org/standard/core/less
000636  1               LessThan:
000636  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n2
000638  1  9C           	LDAA ZW			; get n1
000639  1  59           LT2:	SAB			; n1<n2?
00063A  1  12 04        LT3:	BF @3			; overflow?
00063C  1  16 D8        	BM True0
00063E  1  73 E5        	JMPR False0
000640  1               
000640  1  16 E3        @3:	BM False0
000642  1  73 D2        	JMPR True0
000644  1               
000644  1               
000644  1  3C 3D 02 06   FHdr '<=',0 ; ( n1 n2 -- flag ) flag=n1<=n2 (signed compare)
000648  1  36           
000649  1               LessEqual:
000649  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n2
00064B  1  9C           	LDAA ZW			; get n1
00064C  1  59           LE3:	SAB			; n1<n2?
00064D  1  15 EB        	BNZ LT3
00064F  1  73 C5        	JMPR True0
000651  1               
000651  1               
000651  1  3E 01 06 49   FHdr '>',0 ; ( n1 n2 -- f )  f=n1>n2 (signed compare)
000655  1                  ; https://forth-standard.org/standard/core/less
000655  1               GreaterThan:
000655  1  95 81        	LDAX ZW,ModBRPB,0	; pop n2
000657  1  DC           	LDBA ZW			; get n1
000658  1  73 DF        	JMPR LT2
00065A  1               
00065A  1               
00065A  1  3E 3D 02 06   FHdr '>=',0 ; ( n1 n2 -- f )  f=n1>=n2 (signed compare)
00065E  1  55           
00065F  1               GreaterEqual:
00065F  1  95 81        	LDAX ZW,ModBRPB,0	; pop n2
000661  1  DC           	LDBA ZW			; get n1
000662  1  73 E8        	JMPR LE3
000664  1               
000664  1               
000664  1  44 55 3C 03   FHdr 'DU<',0 ; ( d1 d2 -- f )  f=d1<d2 (unsigned compare)
000668  1  06 5F        
00066A  1                  ; https://forth-standard.org/standard/double/DUless
00066A  1               DULessThan:
00066A  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d2.hi
00066C  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
00066E  1  5C           	XAY
00066F  1  95 81        	LDAX ZW,ModBRPB,0	; pop d1.hi
000671  1  59           	SAB
000672  1  15 03        	BNZ @7
000674  1  9C           	LDAA ZW			; get d1.lo
000675  1  51 06        	SUB YW,AW
000677  1  11 9D        @7:	BNL True0
000679  1  73 AA        	JMPR False0
00067B  1               
00067B  1               
00067B  1  44 3C 02 06   FHdr 'D<',0 ; ( d1 d2 -- f )  f=d1<d2 (signed compare)
00067F  1  6A           
000680  1                  ; https://forth-standard.org/standard/double/Dless
000680  1               DLessThan:
000680  1  D5 81        	LDBX ZW,ModBRPB,0	; pop d2.hi
000682  1  95 81        	LDAX ZW,ModBRPB,0	; pop d2.lo
000684  1  5C           	XAY
000685  1  95 81        	LDAX ZW,ModBRPB,0	; pop d1.hi
000687  1  59           	SAB
000688  1  15 07        	BNZ @10
00068A  1  9C           	LDAA ZW			; get d1.lo
00068B  1  51 06        	SUB YW,AW
00068D  1  11 87        	BNL True0
00068F  1  73 94        	JMPR False0
000691  1               
000691  1  13 05        @10:	BNF @14
000693  1  16 90        	BM False0
000695  1  71 06 16     	JMPD True0
000698  1               
000698  1  17 8B        @14:	BP False0
00069A  1  71 06 16     	JMPD True0
00069D  1               
00069D  1               
00069D  1  44 3E 53 83   FHdr 'D>S',ha_inline ; ( d -- n )  Convert double to single
0006A1  1  06 80        
0006A3  1                  ; https://forth-standard.org/standard/double/DtoS
0006A3  1  30 81        DToS:	INR ZW,2
0006A5  1  09 09        	.dbyt INL_End
0006A7  1               
0006A7  1               
0006A7  1  53 3E 44 03   FHdr 'S>D',0 ; ( n -- d )  Sign extend a single number to form a double number.
0006AB  1  06 A3        
0006AD  1                  ; https://forth-standard.org/standard/core/StoD
0006AD  1  3A           SToD:	CLA			; assume hi word is 0
0006AE  1  DC           	LDBA ZW			; n<0?
0006AF  1  17 01        	BP @2
0006B1  1  39           	DCA			;   change to -1
0006B2  1  B5 82        @2:	STAX ZW,ModBMRB,0	; push hi word
0006B4  1  09           	RSR
0006B5  1               
0006B5  1               
0006B5  1               	.if 0
0006B5  1                FHdr 'S->D',0 ; ( n -- d )  FIG alias
0006B5  1               	JMPR SToD
0006B5  1               	.endif
0006B5  1               
0006B5  1               
0006B5  1  55 4D 2A 03   FHdr 'UM*',0 ; ( u1 u2 -- ud )  ud = unsigned double number product of 2 unsigned numbers.
0006B9  1  06 AD        
0006BB  1                  ; https://forth-standard.org/standard/core/UMTimes
0006BB  1  6D A2        UMStar:	STXX SW,ModBMRB,0	; save X
0006BD  1  95 88 02     	LDAX ZW,ModNBRB,2	; Y=u1
0006C0  1  5C           	XAY
0006C1  1  9C           	LDAA ZW			; A=u2
0006C2  1  32 20        	CLR BW,0		; product.hi=0
0006C4  1  60 00 10     	LDXL 16			; for 16 bits
0006C7  1  07           	RL			; pre-shift u2
0006C8  1  36 00        	RRR AW,1
0006CA  1  11 02        @3:	BNL @4			;   set?
0006CC  1  50 62        	ADD BW,YW		;     add u1 to product.hi
0006CE  1  36 20        @4:	RRR BW,1		;   rotate product right 1 bit
0006D0  1  36 00        	RRR AW,1
0006D2  1  3F           	DCX			;  next bit
0006D3  1  15 F5        	BNZ @3
0006D5  1  FC           	STBA ZW			; store product.hi
0006D6  1  B5 88 02     	STAX ZW,ModNBRB,2	; store product.lo
0006D9  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
0006DB  1  09           	RSR			; return
0006DC  1               
0006DC  1               
0006DC  1               	.if 0
0006DC  1                FHdr 'U*',0 ; ( u1 u2 -- ud )  FIG alias
0006DC  1               	JMPR UMStar
0006DC  1               	.endif
0006DC  1               
0006DC  1                 .if 0
0006DC  1               UMStarTest1:
0006DC  1               	LDAL 1
0006DC  1               	STAX ZW,ModBMRB,0
0006DC  1               	LDAL 1
0006DC  1               	STAX ZW,ModBMRB,0
0006DC  1               	JSRD UMStar
0006DC  1               	LDAX ZW,ModBRPB,0
0006DC  1               	LDBL 0
0006DC  1               	SAB
0006DC  1               	BZ @13
0006DC  1               	HLT
0006DC  1               @13:
0006DC  1               	LDAX ZW,ModBRPB,0
0006DC  1               	LDBL 1
0006DC  1               	SAB
0006DC  1               	BZ @14
0006DC  1               	HLT
0006DC  1               @14:
0006DC  1               
0006DC  1               	LDAL $9876
0006DC  1               	STAX ZW,ModBMRB,0
0006DC  1               	LDAL $a987
0006DC  1               	STAX ZW,ModBMRB,0
0006DC  1               	JSRD UMStar
0006DC  1               	LDAX ZW,ModBRPB,0
0006DC  1               	LDBL $64f6
0006DC  1               	SAB
0006DC  1               	BZ @23
0006DC  1               	HLT
0006DC  1               @23:
0006DC  1               	LDAX ZW,ModBRPB,0
0006DC  1               	LDBL $4c3a
0006DC  1               	SAB
0006DC  1               	BZ @24
0006DC  1               	HLT
0006DC  1               @24:
0006DC  1               
0006DC  1               	RSR
0006DC  1                 .endif
0006DC  1               
0006DC  1               
0006DC  1  55 4D 2F 4D   FHdr 'UM/Mod',0 ; ( ud_dividend u_divisor -- u_rem u_quot )
0006E0  1  6F 64 06 06  
0006E4  1  BB           
0006E5  1                  ; Leave the unsigned remainder and unsigned quotient from the unsigned
0006E5  1                  ; double dividend and unsigned divisor.
0006E5  1                  ; https://forth-standard.org/standard/core/UMDivMOD
0006E5  1               UMSlashMod:
0006E5  1  95 81        	LDAX ZW,ModBRPB,0	; pop divisor into A
0006E7  1  33 01        	IVR AW,1		; negate
0006E9  1  6D A2        	STXX SW,ModBMRB,0	; save X
0006EB  1  55 82        	XFR BW,ZW		; save Z
0006ED  1  F5 A2        	STBX SW,ModBMRB,0
0006EF  1  D5 88 02     	LDBX ZW,ModNBRB,2	; Y=dividend.lo
0006F2  1  55 26        	XFR YW,BW
0006F4  1  65 80        	LDXX ZW,ModBRB,0	; X=dividend.hi
0006F6  1               
0006F6  1  C0 10        	LDBBL 16		; for 16 bits
0006F8  1  45 39        	XFRB ZL,BL
0006FA  1  35 60        	SLR YW,1		; shift dividend.lo left
0006FC  1  37 40        @2:	RLR XW,1		;   rotate dividend.hi left
0006FE  1  10 1B        	BL @7			;   dividend overflowed?
000700  1  55 42        	XFR BW,XW
000702  1  58           	AAB			;   dividend.hi>=divisor?
000703  1  14 02        	BZ @3
000705  1  11 02        	BNL @4
000707  1  55 24        @3:	XFR XW,BW		;     dividend.hi-=divisor
000709  1  37 60        @4:	RLR YW,1		;   shift into quotient, start dividend shift
00070B  1  21 90        	DCRB ZL			;  next bit
00070D  1  15 ED        	BNZ @2
00070F  1  95 A1        	LDAX SW,ModBRPB,0	; restore Z
000711  1  5E           	XAZ
000712  1  6D 88 02     	STXX ZW,ModNBRB,2	; save remainder
000715  1  55 60        	XFR AW,YW
000717  1  BC           	STAA ZW			; save quotient
000718  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
00071A  1  09           	RSR			; return
00071B  1               
00071B  1               @7:				; dividend overflowed, so it's always bigger than the divisor
00071B  1  55 42        	XFR BW,XW
00071D  1  58           	AAB			; dividend.hi-=divisor
00071E  1  06           	SL			; it always fits, because the shifted out bit was set
00071F  1  73 E6        	JMPR @3
000721  1               
000721  1               
000721  1               	.if 0
000721  1                FHdr 'U/',0 ; FIG alias
000721  1               	JMPR UMSlashMod
000721  1               	.endif
000721  1               
000721  1               
000721  1               	.if 0
000721  1               UMSlashModTest1:
000721  1               	LDAL $5678		; dividend = $12345678
000721  1               	STAX ZW,ModBMRB,0
000721  1               	LDAL $1234
000721  1               	STAX ZW,ModBMRB,0
000721  1               	LDAL $6789		; divisor = $6789
000721  1               	STAX ZW,ModBMRB,0
000721  1               	JSRD UMSlashMod
000721  1               	LDAX ZW,ModBRPB,0	; quotient
000721  1               	LDBL $2d03
000721  1               	SAB
000721  1               	BZ @3
000721  1               	HLT
000721  1               @3:
000721  1               	LDAX ZW,ModBRPB,0	; remainder
000721  1               	LDBL $add
000721  1               	SAB
000721  1               	BZ @4
000721  1               	HLT
000721  1               @4:
000721  1               	RSR
000721  1               	.endif
000721  1               
000721  1               
000721  1  4D 2A 02 06   FHdr 'M*',0 ; ( n1 n2 -- d )
000725  1  E5           
000726  1                  ; A mixed magnitude math operations which leaves the double number signed
000726  1                  ; product of two signed integers.
000726  1                  ; https://forth-standard.org/standard/core/MTimes
000726  1  9C           MStar:	LDAA ZW			; save result sign
000727  1  D5 88 02     	LDBX ZW,ModNBRB,2
00072A  1  54 02        	ORE BW,AW
00072C  1  F5 A2        	STBX SW,ModBMRB,0
00072E  1  79 05 41     	JSRD Abs		; n2=abs(n2)
000731  1  D5 88 02     	LDBX ZW,ModNBRB,2	; n1<0?
000734  1  17 05        	BP @4
000736  1  3A           	CLA			;   n1=-n1
000737  1  59           	SAB
000738  1  F5 88 02     	STBX ZW,ModNBRB,2
00073B  1               @4:
00073B  1  79 06 BB     	JSRD UMStar		; unsigned multiply giving double product
00073E  1  95 A1        	LDAX SW,ModBRPB,0	; should be negative?
000740  1  71 05 7B     	JMPD DPMP		; fix sign & return
000743  1               
000743  1               
000743  1  4D 2F 4D 6F   FHdr 'M/Mod',0 ; ( ud1 u2 -- u3 ud4 )
000747  1  64 05 07 26  
00074B  1                  ; An unsigned mixed magnitude math operation which leaves a double quotient ud4 and
00074B  1                  ; remainder u3, from a double dividend ud1 and single divisor u2.
00074B  1               MSlashMod:
00074B  1  DC           	LDBA ZW			; >R 0
00074C  1  F5 A2        	STBX SW,ModBMRB,0
00074E  1  3A           	CLA
00074F  1  BC           	STAA ZW
000750  1  F5 82        	STBX ZW,ModBMRB,0	; R
000752  1  79 06 E5     	JSRD UMSlashMod		; U/
000755  1  DD           	LDBA SW			; R> Swap >R
000756  1  9C           	LDAA ZW
000757  1  FC           	STBA ZW
000758  1  BD           	STAA SW
000759  1  79 06 E5     	JSRD UMSlashMod		; U/
00075C  1  95 A1        	LDAX SW,ModBRPB,0	; R>
00075E  1  B5 82        	STAX ZW,ModBMRB,0
000760  1  09           	RSR
000761  1               
000761  1               
000761  1               	.if 0
000761  1               MSlashModTest1:
000761  1               	LDAL .loword(123456789)
000761  1               	STAX ZW,ModBMRB,0
000761  1               	LDAL .hiword(123456789)
000761  1               	STAX ZW,ModBMRB,0
000761  1               	LDAL 10
000761  1               	STAX ZW,ModBMRB,0
000761  1               	JSRR MSlashMod
000761  1               	LDAX ZW,ModBRPB,0
000761  1               	LDBL .hiword(12345678)
000761  1               	SAB
000761  1               	BZ @11
000761  1               	HLT
000761  1               @11:
000761  1               	LDAX ZW,ModBRPB,0
000761  1               	LDBL .loword(12345678)
000761  1               	SAB
000761  1               	BZ @12
000761  1               	HLT
000761  1               @12:
000761  1               	LDAX ZW,ModBRPB,0
000761  1               	LDBL 9
000761  1               	SAB
000761  1               	BZ @13
000761  1               	HLT
000761  1               @13:
000761  1               	RSR
000761  1               	.endif
000761  1               
000761  1               
000761  1  53 4D 2F 52   FHdr 'SM/Rem',0 ; ( d_dividend n_divisor -- n_remainder n_quotient )
000765  1  65 6D 06 07  
000769  1  4B           
00076A  1                  ; A mixed magnitude math operation which leaves the signed remainder and signed
00076A  1                  ; quotient, from a double number dividend and divisor.
00076A  1                  ; The remainder takes its sign from the dividend.
00076A  1               
00076A  1                  ; Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
00076A  1                  ;  Input and output stack arguments are signed.
00076A  1                  ;  An ambiguous condition exists if n1 is zero or if the quotient lies outside the range of a single-cell signed integer.
00076A  1                  ; https://forth-standard.org/standard/core/SMDivREM
00076A  1               SMSlashRem:
00076A  1  95 81        	LDAX ZW,ModBRPB,0	; pop divisor
00076C  1  DC           	LDBA ZW			; push dividend sign to return stack
00076D  1  F5 A2        	STBX SW,ModBMRB,0
00076F  1  B5 A2        	STAX SW,ModBMRB,0	; push divisor to return stack
000771  1  79 05 6F     	JSRD DAbs		; d=abs(d)
000774  1  9D           	LDAA SW			; get a copy of divisor from return stack
000775  1  B5 82        	STAX ZW,ModBMRB,0
000777  1  79 05 41     	JSRD Abs		; abs
00077A  1  79 06 E5     	JSRD UMSlashMod		; unsigned divide
00077D  1  95 A1        	LDAX SW,ModBRPB,0	; pop divisor from return stack
00077F  1               ;	STAX ZW,ModBMRB,0
00077F  1  DD           	LDBA SW			; should quotient be negative?
000780  1  54 02        	ORE BW,AW
000782  1  79 05 4C     	JSRD PMP
000785  1  95 A1        	LDAX SW,ModBRPB,0	; pop dividend sign
000787  1  17 08        	BP @18			; should remander be negative?
000789  1  3A           	CLA			;   negate remainder
00078A  1  D5 88 02     	LDBX ZW,ModNBRB,2
00078D  1  59           	SAB
00078E  1  F5 88 02     	STBX ZW,ModNBRB,2
000791  1               @18:
000791  1  09           	RSR			; return
000792  1               
000792  1               
000792  1               	.if 0
000792  1                FHdr 'M/',0 ; ( d_dividend n_divisor -- n_remainder n_quotient )  FIG alias
000792  1               	JMPR SMSlashRem
000792  1               	.endif
000792  1               
000792  1               
000792  1               	.if 0
000792  1                FHdr 'FM/Mod',0 ; ( d n1  n2 n3 )
000792  1                  ; Divide d1 by n1, giving the floored quotient n3 and the remainder n2.
000792  1                  ; Input and output stack arguments are signed.
000792  1                  ; An ambiguous condition exists if n1 is zero or if the quotient lies outside the range of a single-cell signed integer.
000792  1                  ; https://forth-standard.org/standard/core/FMDivMOD
000792  1               FMSMod:	LDAX ZW,ModBRPB,0	;pop divsior
000792  1               FMSModA: STAX SW,ModBMRB,0	;save divisor
000792  1               	LDAA ZW			; get dividend hi word
000792  1               	STAX SW,ModBMRB ,0	; save dividend sign
000792  1               	BP @3			; make dividend positive
000792  1               	JSRD DNegate
000792  1               @3:
000792  1               	LDAX SW,ModNBRB,2	; get abs(divisor)
000792  1               	BP @4
000792  1               	IVR AW,1
000792  1               @4:
000792  1               	STAX SW,ModBMRB,0
000792  1               	JSRD UMSlashMod		;unsigned divide
000792  1               
000792  1               	LDAXB SW,ModNBRB,2	;correct remainder
000792  1               	BP @6
000792  1               	LDAX ZW,ModNBRB,2
000792  1               	IVR AW,1
000792  1               	STAX ZW,ModNBRB,2
000792  1               @6:
000792  1               	LDAX SW,ModBRPB,0	;correct quotient
000792  1               	LDBA SW
000792  1               	ORE AW,BW
000792  1               	BP @5
000792  1               	sec
000792  1               	lda 2,x
000792  1               	beq @7
000792  1               	lda 1,s
000792  1               	sec
000792  1               	sbc 2,x
000792  1               	sta 2,x
000792  1               	clc
000792  1               @7:
000792  1               	lda #0
000792  1               	sbc 0,x
000792  1               	sta 0,x
000792  1               @5:
000792  1               	INR SW,2		; drop divisor
000792  1               	RSR
000792  1               	.endif
000792  1               
000792  1               
000792  1  2A 01 07 6A   FHdr '*',0 ; ( n1 n2 -- n_prod )  Leave the signed product of two signed numbers.
000796  1                  ; https://forth-standard.org/standard/core/Times
000796  1  79 06 BB     Star:	JSRD UMStar		; do unsigned multiply
000799  1  30 81        	INR ZW,2		; drop hi word of result
00079B  1  09           	RSR			; return
00079C  1               
00079C  1               
00079C  1  2F 4D 6F 64   FHdr '/Mod',0 ; ( n_dividend n_divisor -- n_rem n_quot )  Divide
0007A0  1  04 07 96     
0007A3  1                  ; https://forth-standard.org/standard/core/DivMOD
0007A3  1               SlashMod:
0007A3  1  95 81        	LDAX ZW,ModBRPB,0	; save divisor
0007A5  1  B5 A2        	STAX SW,ModBMRB,0
0007A7  1  79 06 AD     	JSRD SToD		; convert dividend to double
0007AA  1  95 A1        	LDAX SW,ModBRPB,0	; get divisor
0007AC  1  B5 82        	STAX ZW,ModBMRB,0
0007AE  1  73 BA        	JMPR SMSlashRem		; divide & return
0007B0  1               
0007B0  1               
0007B0  1  2F 01 07 A3   FHdr '/',0 ; ( n_dividend n_divisor -- n_quot )  Divide
0007B4  1                  ; https://forth-standard.org/standard/core/Div
0007B4  1  7B ED        Slash:	JSRR SlashMod		; do the divide
0007B6  1  71 03 1E     	JMPD Nip		; discard the remainder, & return
0007B9  1               
0007B9  1               
0007B9  1  4D 6F 64 03   FHdr 'Mod',0 ; ( n_dividend n_divisor -- n_mod )
0007BD  1  07 B4        
0007BF  1                  ; Leave the remainder of n1/n2, with the same sign as n1.
0007BF  1                  ; https://forth-standard.org/standard/core/MOD
0007BF  1  7B E2        Mod:	JSRR SlashMod		; do the divide
0007C1  1  30 81        	INR ZW,2		; drop the quotient
0007C3  1  09           	RSR			; return
0007C4  1               
0007C4  1               
0007C4  1  2A 2F 4D 6F   FHdr '*/Mod',0 ; ( n1 n_multipier n_divisor -- n_remainder n_quotient )
0007C8  1  64 05 07 BF  
0007CC  1                  ; Leave the quotient and remainder of the operation (n1*n_multiplier)/n_divisor .
0007CC  1                  ; A 31 bit intermediate product is used as for */ .
0007CC  1                  ; https://forth-standard.org/standard/core/TimesDivMOD
0007CC  1               StarSlashMod:
0007CC  1  95 81        	LDAX ZW,ModBRPB,0	; save divisor on return stack
0007CE  1  B5 A2        	STAX SW,ModBMRB,0
0007D0  1  79 07 26     	JSRD MStar		; do multiply
0007D3  1  95 A1        	LDAX SW,ModBRPB,0	; get divisor from return stack
0007D5  1  B5 82        	STAX ZW,ModBMRB,0
0007D7  1  73 91        	JMPR SMSlashRem		; do divide & return
0007D9  1               
0007D9  1               
0007D9  1  2A 2F 02 07   FHdr '*/',0 ; ( n1 n_multiplier n_divisor -- n_quotient )
0007DD  1  CC           
0007DE  1                  ; Leave the ratio n_quotient = (n1*n_multiplier)/n_divisor where all are signed numbers.
0007DE  1                  ; Retention of an intermediate 31 bit product permits greater accuracy
0007DE  1                  ; than would be available with the sequence:
0007DE  1                  ;	n1 n_multiplier * n_divisor /
0007DE  1                  ; https://forth-standard.org/standard/core/TimesDiv
0007DE  1               StarSlash:
0007DE  1  7B EC        	JSRR StarSlashMod ; do it
0007E0  1  71 03 1E     	JMPD Nip		; discard the remainder & return
0007E3  1               
0007E3  1               
0007E3  1               	.if 0
0007E3  1                FHdr 'M*/',0 ; ( d1 n1 +n2 -- d2 )
0007E3  1                  ; https://forth-standard.org/standard/double/MTimesDiv
0007E3  1               	JSRD Abort ;???
0007E3  1               	.endif
0007E3  1               
0007E3  1               
0007E3  1  2B 21 02 07   FHdr '+!',0 ; ( n adr -- )  Add n to the value at the address.
0007E7  1  DE           
0007E8  1                  ; https://forth-standard.org/standard/core/PlusStore
0007E8  1               PlusStore:
0007E8  1  95 81        	LDAX ZW,ModBRPB,0	; pop adr
0007EA  1  5C           	XAY
0007EB  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
0007ED  1  DB           	LDBA YW
0007EE  1  58           	AAB
0007EF  1  FB           	STBA YW
0007F0  1  09           	RSR
0007F1  1               
0007F1  1               
0007F1  1  31 2B 21 83   FHdr '1+!',ha_inline ; ( adr -- )  increment a variable
0007F5  1  07 E8        
0007F7  1  D5 81        	LDBX ZW,ModBRPB,0	; pop addr
0007F9  1  99           	LDAA BW			; increment the word
0007FA  1  38           	INA
0007FB  1  B9           	STAA BW
0007FC  1  09 09        	.dbyt INL_End		; return
0007FE  1               
0007FE  1               
0007FE  1  30 21 82 07   FHdr '0!',ha_inline ; ( adr -- )  store 0 in a variable
000802  1  F7           
000803  1  3A           	CLA
000804  1  B5 85        	STAX ZW,ModABRPB,0
000806  1  09 09        	.dbyt INL_End		; return
000808  1               
000808  1               
000808  1               	.if 0
000808  1                FHdr 'Toggle',0 ; ( adr n -- )  Complement the contents of addr by the bit pattern n .
000808  1               Toggle:	LDBX ZW,ModBRPB,0	; pop n
000808  1               	LDAX ZW,ModBRPB,0	; pop adr
000808  1               	XAY
000808  1               	LDAA YW			; do a word
000808  1               	ORE AW,BW
000808  1               	STAA YW
000808  1               	RSR
000808  1               	.endif
000808  1               
000808  1               
000808  1  40 81 08 03   FHdr '@',ha_inline ; ( adr -- n )  Leave the 16 bit contents of address.
00080C  1                  ; https://forth-standard.org/standard/core/Fetch
00080C  1  95 84        At:	LDAX ZW,ModABRB,0	; get @adr
00080E  1  BC           	STAA ZW			; store n
00080F  1  09 09        	.dbyt INL_End
000811  1               
000811  1               
000811  1  32 40 02 08   FHdr '2@',0 ; ( adr -- d )  Leave the 32 bit contents of address.
000815  1  0C           
000816  1                  ; https://forth-standard.org/standard/core/TwoFetch
000816  1  DC           TwoAt:	LDBA ZW			; get addr
000817  1  95 21        	LDAX BW,ModBRPB,0	; get d.hi
000819  1  D9           	LDBA BW			; get d.lo
00081A  1  FC           	STBA ZW			; store d.lo
00081B  1  B5 82        	STAX ZW,ModBMRB,0	; store d.hi
00081D  1  09           	RSR
00081E  1               
00081E  1               
00081E  1  43 40 82 08   FHdr 'C@',ha_inline ; ( adr -- n )  Leave the 8 bit contents of memory address.
000822  1  16           
000823  1               ; https://forth-standard.org/standard/core/CFetch
000823  1  3A           CAt:	CLA			; set the hi byte to 0
000824  1  85 84        	LDABX ZW,ModABRB,0	; fetch byte addressed by bottom of stack
000826  1  BC           	STAA ZW			; store as n
000827  1  09 09        	.dbyt INL_End		; return
000829  1               
000829  1               
000829  1  21 81 08 23   FHdr '!',ha_inline ; ( n adr -- )  Store 16 bits of n at address.
00082D  1                  ; https://forth-standard.org/standard/core/Store
00082D  1  D5 81        Store:	LDBX ZW,ModBRPB,0	; pop adr
00082F  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
000831  1  B9           	STAA BW			; store at (adr)
000832  1  09 09        	.dbyt INL_End		; return
000834  1               
000834  1               
000834  1  32 21 02 08   FHdr '2!',0 ; ( d adr -- )  Store 32 bits at adr.
000838  1  2D           
000839  1                  ; https://forth-standard.org/standard/core/TwoStore
000839  1               TwoStore:
000839  1  D5 81        	LDBX ZW,ModBRPB,0	; pop adr
00083B  1  95 81        	LDAX ZW,ModBRPB,0	; pop d.hi
00083D  1  B5 21        	STAX BW,ModBRPB,0	; store at adr+0
00083F  1  95 81        	LDAX ZW,ModBRPB,0	; pop d.lo
000841  1  B9           	STAA BW			; store at adr+2
000842  1  09           	RSR			; return
000843  1               
000843  1               
000843  1  43 21 82 08   FHdr 'C!',ha_inline ; ( n adr -- )  Store 8 bits at address.
000847  1  39           
000848  1                  ; https://forth-standard.org/standard/core/CStore
000848  1  D5 81        CStore:	LDBX ZW,ModBRPB,0	; pop adr
00084A  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
00084C  1  A9           	STABA BW		; store at adr
00084D  1  09 09        	.dbyt INL_End		; return
00084F  1               
00084F  1               
00084F  1  45 78 65 63   FHdr 'Execute',0 ; ( xt -- )
000853  1  75 74 65 07  
000857  1  08 48        
000859  1                  ; Execute the definition whose address is on the stack.
000859  1                  ; The code address is also called the compilation address.
000859  1                  ; https://forth-standard.org/standard/core/EXECUTE
000859  1  75 85        Execute: JMPX ZW,ModABRPB,0	; pop xt & jmp to it
00085B  1               
00085B  1               
00085B  1  43 6F 75 6E   FHdr 'Count',0 ; ( addr1 -- addr2 len )
00085F  1  74 05 08 59  
000863  1               ; Leave the byte address addr2 and byte count len of a counted string beginning at
000863  1               ; address addr1.  It is presumed that the first byte at addr1 contains the text
000863  1               ; byte count and the actual text starts with the second byte.
000863  1               ; Typically COUNT is followed by TYPE .
000863  1               ; https://forth-standard.org/standard/core/COUNT
000863  1  DC           Count:	LDBA ZW			; get addr1
000864  1  3A           	CLA			; get length byte
000865  1  85 21        	LDABX BW,ModBRPB,0
000867  1  FC           	STBA ZW			; store addr2
000868  1  B5 82        	STAX ZW,ModBMRB,0	; push length
00086A  1  09           	RSR			; return
00086B  1               
00086B  1               
00086B  1               	.if 0
00086B  1               
00086B  1                FHdr 'Chars',ha_inline ; ( n1 -- n2 )
00086B  1                  ; n2 is the size in address units of n1 characters.
00086B  1                  ; https://forth-standard.org/standard/core/CHARS
00086B  1               Chars:	.dbyt INL_End
00086B  1               
00086B  1               
00086B  1                FHdr 'Char+',0 ; ( c-addr1 -- c-addr2 )
00086B  1                  ; Add the size in address units of a character to c-addr1, giving c-addr2.
00086B  1                  ; https://forth-standard.org/standard/core/CHARPlus
00086B  1               CharPlus: JMPR OnePlus
00086B  1               
00086B  1               	.endif
00086B  1               
00086B  1               
00086B  1  43 65 6C 6C   FHdr 'Cell',0 ; ( -- n )  size of a cell in bytes
00086F  1  04 08 63     
000872  1  71 0A 6E     Cell:	JMPD Two
000875  1               
000875  1               
000875  1  43 65 6C 6C   FHdr 'Cells',0 ; ( n1 -- n2 ) convert # of cells to bytes
000879  1  73 05 08 72  
00087D  1                  ; https://forth-standard.org/standard/core/CELLS
00087D  1  71 04 2C     Cells:	JMPD TwoStar
000880  1               
000880  1               
000880  1  43 65 6C 6C   FHdr 'Cell+',0 ; ( n1 -- n2 ) add size of cell
000884  1  2B 05 08 7D  
000888  1                  ; https://forth-standard.org/standard/core/CELLPlus
000888  1               CellPlus:
000888  1  71 04 BE     	JMPD TwoPlus
00088B  1               
00088B  1               
00088B  1               	.if 0
00088B  1                FHdr '/String',0 ; ( c-addr1 u1 n -- c-addr2 u2 )
00088B  1                  ; Adjust the character string at c-addr1 by n characters. The resulting character string, specified by c-addr2 u2,
00088B  1                  ; begins at c-addr1 plus n characters and is u1 minus n characters long.
00088B  1                  ; https://forth-standard.org/standard/string/DivSTRING
00088B  1               SlashString:
00088B  1               	LDAX ZW,ModBRPB,0	; pop n
00088B  1               	LDBX ZW,ModNBRB,2	; fix c-addr1
00088B  1               	AAB
00088B  1               	STBX ZW,ModNBRB,2
00088B  1               	LDBA ZW			; fix u1
00088B  1               	SUB AW,BW
00088B  1               	STAA ZW
00088B  1               	RSR
00088B  1               	.endif
00088B  1               
00088B  1               
00088B  1  2D 54 72 61   FHdr '-Trailing',0 ; ( addr n1 -- addr n2 )  Remove trailing blanks
00088F  1  69 6C 69 6E  
000893  1  67 09 08 88  
000897  1                  ; Adjust the char count n1 of a text string beginning at addr to suppress
000897  1                  ; the output of trailing blanks.  i.e. the chars at addr+n1 to addr+n2
000897  1                  ; are blanks.
000897  1                  ; https://forth-standard.org/standard/string/MinusTRAILING
000897  1               DTrailing:
000897  1  6D A2        	STXX SW,ModBMRB,0	; save X
000899  1               
000899  1  65 80        	LDXX ZW,ModBRB,0	; X= len
00089B  1  95 88 02     	LDAX ZW,ModNBRB,2	; Y= addr+len
00089E  1  5C           	XAY
00089F  1  50 46        	ADD YW,XW
0008A1  1  3F           @8:	DCX			; step to previous char
0008A2  1  16 07        	BM @9
0008A4  1  C5 62        	LDBBX YW,ModBMRB,0	; get char
0008A6  1  80 20        	LDABL ' '		; is char blank?
0008A8  1  49           	SABB
0008A9  1  14 F6        	BZ @8			;   if so, do another char
0008AB  1  3E           @9:	INXC			; done
0008AC  1  6D 80        	STXX ZW,ModBRB,0	; store new len
0008AE  1               
0008AE  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
0008B0  1  09           	RSR			; return
0008B1  1               
0008B1  1               
0008B1  1  55 70 70 65   FHdr 'Upper',0 ; ( adr len -- ) uppercase a string
0008B5  1  72 05 08 97  
0008B9  1  6D A2        Upper:	STXX SW,ModBMRB,0	; push X
0008BB  1  65 81        	LDXX ZW,ModBRPB,0	; pop len
0008BD  1  95 81        	LDAX ZW,ModBRPB,0	; pop adr
0008BF  1  5C           	XAY
0008C0  1  14 15        	BZ @Done
0008C2  1               
0008C2  1  85 61        @2:	LDABX YW,ModBRPB,0	; get char
0008C4  1  C0 61        	LDBBL 'a'		; <'a'?
0008C6  1  49           	SABB
0008C7  1  11 0B        	BNL @7
0008C9  1  C0 7B        	LDBBL 'z'+1		; >'z'?
0008CB  1  49           	SABB
0008CC  1  10 06        	BL @7
0008CE  1  C0 DF        	LDBBL $DF		; change to ASCII uppercase
0008D0  1  4A           	NABB
0008D1  1  E5 68 FF     	STBBX YW,ModNBRB,$ff	; store it back
0008D4  1  3F           @7:	DCX			; len--
0008D5  1  17 EB        	BP @2			; <0?
0008D7  1               
0008D7  1  65 A1        @Done:	LDXX SW,ModBRPB,0	; pop X
0008D9  1  09           	RSR
0008DA  1               
0008DA  1               
0008DA  1               	.if 0
0008DA  1                FHdr 'Replaces',0 ; ( c-addr1 u1 c-addr2 u2 -- )
0008DA  1                  ; Set the string c-addr1 u1 as the text to substitute for the substitution named by c-addr2 u2.
0008DA  1                  ; If the substitution does not exist it is created. The program may then reuse the buffer c-addr1 u1
0008DA  1                  ; without affecting the definition of the substitution.
0008DA  1                  ;
0008DA  1                  ; Ambiguous conditions occur as follows:
0008DA  1                  ;	The substitution cannot be created;
0008DA  1                  ;	The name of a substitution contains the `%' delimiter character.
0008DA  1                  ; 	REPLACES may allot data space and create a definition. This breaks the contiguity of the current region and
0008DA  1                  ;	  is not allowed during compilation of a colon definition
0008DA  1                  ; https://forth-standard.org/standard/string/REPLACES
0008DA  1               Replaces:
0008DA  1               	JSRD Abort ;???
0008DA  1               	.endif
0008DA  1               
0008DA  1               
0008DA  1               	.if 0
0008DA  1                FHdr 'Search',0 ; ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
0008DA  1                  ; Search the string specified by c-addr1 u1 for the string specified by c-addr2 u2.
0008DA  1                  ; If flag is true, a match was found at c-addr3 with u3 characters remaining.
0008DA  1                  ; If flag is false there was no match and c-addr3 is c-addr1 and u3 is u1.
0008DA  1                  ; https://forth-standard.org/standard/string/SEARCH
0008DA  1               Search:
0008DA  1               	STXX SW,ModBMRB,0	; save X
0008DA  1               	LDAX ZW,ModBRPB,0	; pop u2
0008DA  1               	INA
0008DA  1               	STAX SW,ModBMRB,0	;   push u2
0008DA  1               	LDAA ZW			; get c-addr2
0008DA  1               	LDBL $7f00		;   YH=$7f, YL=1st char
0008DA  1               	LDBBX AW,ModBRPB,0
0008DA  1               	STBX SW,ModBMRB,0	;     push
0008DA  1               	STAX SW,ModBMRB,0	;   push c-addr2 + 1
0008DA  1               	LDAX ZW,ModNBRB,2	; get u1
0008DA  1               	INA			;   + 1
0008DA  1               	LDBX SW,ModNBRB,4	;   - u2
0008DA  1               	SAB
0008DA  1               	STBX SW,ModBMRB,0	;   push
0008DA  1               	LDAX ZW,ModNBRB,4	; get c-addr1
0008DA  1               	STAX SW,ModBMRB,0	;   push
0008DA  1               	XFR AW,ZW		; save Z
0008DA  1               	STAX SW,ModBMRB,0
0008DA  1               @c2	= 10
0008DA  1               @chr2	=  8
0008DA  1               @A2	=  6
0008DA  1               @A1	=  4
0008DA  1               @c1	=  2
0008DA  1               @Z	=  0
0008DA  1               
0008DA  1               @10:				; load regs for 1st char search
0008DA  1               	LDAX SW,ModNBRB,@c1	; Z = @c1
0008DA  1               	XAZ
0008DA  1               	LDAX SW,ModNBRB,@chr2	; Yh = $7f; YL = 1st pattern char
0008DA  1               	XAY
0008DA  1               	LDXX SW,ModNBRB,@A1	; X = @A1
0008DA  1               @12:	DCR ZW			;   get next byte
0008DA  1               	BZ @NotFound
0008DA  1               	LDABX XW,ModBRPB,0
0008DA  1               	SUBB BL,YL		;   compare
0008DA  1               	ANR BL,YH		;   is this helpful?
0008DA  1               	BNZ @12
0008DA  1               	STXX SW,ModNBRB,@A1	; save loc of 2nd char
0008DA  1               	XFR AW,ZW
0008DA  1               	STAX SW,ModNBRB,@c1	; save count
0008DA  1               
0008DA  1               	LDAX SW,ModNBRB,@A2	; load regs for additional chars search
0008DA  1               	XAY
0008DA  1               	LDAX SW,ModNBRB,@c2
0008DA  1               	XAZ
0008DA  1               	JMPR @28
0008DA  1               @22:	LDABX XW,ModBRPB,0	; compare char
0008DA  1               	LDBBX YW,ModBRPB,0
0008DA  1               	SABB
0008DA  1               	BNZ @10
0008DA  1               @28:	DCR ZW			; adjust count
0008DA  1               	BNZ @22
0008DA  1               
0008DA  1               @Found:	LDAA SW ;@Z		; restore Z
0008DA  1               	XAZ
0008DA  1               	LDAX SW,ModNBRB,@A1	; c-addr3 = @A1 - 1
0008DA  1               	DCA
0008DA  1               	STAX ZW,ModNBRB,4
0008DA  1               	LDAX SW,ModNBRB,@c1	; u3 = @c1 + @c2
0008DA  1               	LDBX SW,ModNBRB,@c2
0008DA  1               	AAB
0008DA  1               	STBX ZW,ModNBRB,2
0008DA  1               	LDAL 1			; flag = true
0008DA  1               	JMPR @99
0008DA  1               
0008DA  1               @NotFound:
0008DA  1               	LDAA SW ; @Z		; restore Z
0008DA  1               	XAZ
0008DA  1               	CLA			; flag = false
0008DA  1               
0008DA  1               @99:	INR SW,@c2+2
0008DA  1               	LDXX SW,MonBRPB,0	; restore X
0008DA  1               	STAA ZW			; save flag
0008DA  1               	RSR
0008DA  1               	.endif
0008DA  1               
0008DA  1               
0008DA  1               	.if 0
0008DA  1                FHdr 'Substitute',0 ; ( c-addr1 u1 c-addr2 u2 -- c-addr2 u3 n )
0008DA  1                  ; Perform substitution on the string c-addr1 u1 placing the result at string c-addr2 u3,
0008DA  1                  ; where u3 is the length of the resulting string.
0008DA  1                  ; An error occurs if the resulting string will not fit into c-addr2 u2 or if c-addr2 is the same as c-addr1.
0008DA  1                  ; The return value n is positive or 0 on success and indicates the number of substitutions made. A negative value for n indicates that an error occurred, leaving c-addr2 u3 undefined. Negative values of n are implementation defined except for values in table 9.1 THROW code assignments.
0008DA  1                  ;
0008DA  1                  ; Substitution occurs left to right from the start of c-addr1 in one pass and is non-recursive.
0008DA  1                  ;
0008DA  1                  ; When text of a potential substitution name, surrounded by `%' (ASCII $25) delimiters is encountered by SUBSTITUTE, the following occurs:
0008DA  1                  ;
0008DA  1                  ; If the name is null, a single delimiter character is passed to the output, i.e., %% is replaced by %. The current number of substitutions is not changed.
0008DA  1                  ; If the text is a valid substitution name acceptable to 17.6.2.2141 REPLACES, the leading and trailing delimiter characters and the enclosed substitution name are replaced by the substitution text. The current number of substitutions is incremented.
0008DA  1                  ; If the text is not a valid substitution name, the name with leading and trailing delimiters is passed unchanged to the output. The current number of substitutions is not changed.
0008DA  1                  ; Parsing of the input string resumes after the trailing delimiter.
0008DA  1                  ; If after processing any pairs of delimiters, the residue of the input string contains a single delimiter, the residue is passed unchanged to the output.
0008DA  1                  ; https://forth-standard.org/standard/string/SUBSTITUTE
0008DA  1               Substutute:
0008DA  1               	JSRD Abort ;???
0008DA  1               	.endif
0008DA  1               
0008DA  1               
0008DA  1               	.if 0
0008DA  1                FHdr 'Unescape',0 ; ( c-addr1 u1 c-addr2 -- c-addr2 u2 )
0008DA  1                  ; Replace each `%' character in the input string c-addr1 u1 by two `%' characters.
0008DA  1                  ; The output is represented by c-addr2 u2. The buffer at c-addr2 shall be big enough to hold the unescaped string.
0008DA  1                  ; An ambiguous condition occurs if the resulting string will not fit into the destination buffer (c-addr2).
0008DA  1                  ; https://forth-standard.org/standard/string/UNESCAPE
0008DA  1               Unescape:
0008DA  1               	JSRD Abort ;???
0008DA  1               	.endif
0008DA  1               
0008DA  1               
0008DA  1  45 6E 63 6C   FHdr 'Enclose',0 ; ( addr delimiter - addr1 n1 n2 n3 )
0008DE  1  6F 73 65 07  
0008E2  1  08 B9        
0008E4  1                  ; The text scanning primitive used by WORD.  From the text address addr1 and an ASCII
0008E4  1                  ; delimiting char, is determined the byte offset to the first non-delimiter
0008E4  1                  ; char n1, the offset to the first delimiter after the text n2, and the offset to the
0008E4  1                  ; first char not included.
0008E4  1                  ; This procedure will not process past an ASCII 'null', treating it as an unconditional delimiter.
0008E4  1               Enclose:
0008E4  1  6D A2        	STXX SW,ModBMRB,0	; push X
0008E6  1  65 88 02     	LDXX ZW,ModNBRB,2	; X=addr
0008E9  1  9C           	LDAA ZW			; AL=delimiter
0008EA  1  31 83        	DCR ZW,4		; alloc space for n2 & n3
0008EC  1               
0008EC  1               	; skip initial delimiters
0008EC  1  3F           	DCX
0008ED  1  3E           @313:	INXC			; get next char
0008EE  1  CA           	LDBBA XW
0008EF  1  49           	SABB
0008F0  1  14 FB        	BZ @313
0008F2  1  D5 88 06     	LDBX ZW,ModNBRB,6	; n1=index of 1st non-delimiter char
0008F5  1  51 42        	SUB BW,XW
0008F7  1  F5 88 04     	STBX ZW,ModNBRB,4
0008FA  1               
0008FA  1  3F           	DCX			; skip word
0008FB  1  3E           @318:	INXC			; get next char
0008FC  1  CA           	LDBBA XW
0008FD  1  14 10        	BZ @70			;    null?
0008FF  1  49           	SABB			;    !delimiter?
000900  1  15 F9        	BNZ @318
000902  1  D5 88 06     	LDBX ZW,ModNBRB,6	; n2=index of delimiter after word
000905  1  51 42        	SUB BW,XW
000907  1  F5 88 02     	STBX ZW,ModNBRB,2
00090A  1  30 20        	INR BW,1		; n3=n2+1
00090C  1  FC           	STBA ZW
00090D  1  73 15        	JMPR @Rtn
00090F  1               
00090F  1               @70: ; we hit a null
00090F  1  D5 88 06     	LDBX ZW,ModNBRB,6	; n2=index of null
000912  1  51 42        	SUB BW,XW
000914  1  F5 88 02     	STBX ZW,ModNBRB,2
000917  1  FC           	STBA ZW			; n3=index of null
000918  1               
000918  1  95 88 04     	LDAX ZW,ModNBRB,4	; n2==n1?
00091B  1  51 20        	SUB AW,BW
00091D  1  15 05        	BNZ @326
00091F  1  30 20        	INR BW,1		;   n2+=1
000921  1  F5 88 02     	STBX ZW,ModNBRB,2
000924  1               @326:
000924  1  65 A1        @Rtn:	LDXX SW,ModBRPB,0	; pop X
000926  1  09           	RSR			; return
000927  1               
000927  1               
000927  1               ; FHdr 'Word',0 ; ( c -- addr )  ANSI
000927  1                  ;	Parses one word from the input stream, using the character (usually blank) as a delimiter.
000927  1                  ;	Moves the string to the address HERE with the count in the first byte, leaving the address on the stack.
000927  1                  ; https://forth-standard.org/standard/core/WORD
000927  1               
000927  1               
000927  1  57 6F 72 64   FHdr 'Word',0 ; ( c -- )  FIG
00092B  1  04 08 E4     
00092E  1                  ; Read the next text chars from the input stream being interpreted, until a delimiter
00092E  1                  ; c is found, storing the packed char string beginning at the dictionary buffer HERE .
00092E  1                  ; WORD leaves the char count in the 1st byte, the chars, and ends with 2 or more blanks.
00092E  1                  ; Leading occurances of c are ignored.  If BLK is zero, text is taken from the
00092E  1                  ; terminal input buffer, otherwise from the disc block stored in BLK .
00092E  1                  ; See BLK IN
00092E  1  91 70 74     Word:	LDAD VBlk		; if not terminal
000931  1  14 07        	BZ @1914
000933  1               
000933  1  B5 82        	STAX ZW,ModBMRB,0	;   get block ptr
000935  1  79 19 0F     	JSRD Block
000938  1  73 05        	JMPR @1916		;  else
00093A  1               
00093A  1  91 70 68     @1914:	LDAD VTIB		;   get terminal buffer ptr
00093D  1  B5 82        	STAX ZW,ModBMRB,0
00093F  1               				;  then
00093F  1               @1916:				; ( c buf )
00093F  1               
00093F  1  91 70 76     	LDAD VIn
000942  1  79 04 DF     	JSRD PlusA
000945  1  79 02 A1     	JSRD Swap
000948  1  79 08 E4     	JSRD Enclose		; ( buf n1 n2 n3 )
00094B  1               
00094B  1  91 70 70     	LDAD VDP		; output ptr
00094E  1  5C           	XAY
00094F  1               
00094F  1  95 88 02     	LDAX ZW,ModNBRB,2	; store string length
000952  1  D5 88 04     	LDBX ZW,ModNBRB,4
000955  1  59           	SAB
000956  1  E5 61        	STBBX YW,ModBRPB,0
000958  1               
000958  1  95 88 06     	LDAX ZW,ModNBRB,6	; source addr
00095B  1  D5 88 04     	LDBX ZW,ModNBRB,4
00095E  1  58           	AAB
00095F  1  85 68 FF     	LDABX YW,ModNBRB,$ff
000962  1  45 10        	XFRB AH,AL		; store chars
000964  1  85 21        @31:	LDABX BW,ModBRPB,0
000966  1  A5 61        	STABX YW,ModBRPB,0
000968  1  21 00        	DCRB AH
00096A  1  15 F8        	BNZ @31
00096C  1               
00096C  1  90 20 20     	LDAL $2020		; store blanks
00096F  1  BB           	STAA YW
000970  1               
000970  1  79 0B 3D     	JSRD In			; In+=n3
000973  1  79 07 E8     	JSRD PlusStore
000976  1  30 85        	INR ZW,6		; drop n2 n1 buf
000978  1  09           	RSR
000979  1               
000979  1               
000979  1               	.if 0
000979  1                FHdr 'Digit',0	; ( c n1 -- n2 true ) (ok)
000979  1               		; ( c n1 ---  false ) (bad)
000979  1                  ; Converts the ASCII char c (using base n1) to its binary equivalent n2,
000979  1                  ; accompanied by a true flag.  If the conversion is invalid, leaves
000979  1                  ; only a false flag.
000979  1               	JSRD Abort ;???
000979  1               	.endif
000979  1               
000979  1               
000979  1  28 4E 75 6D   FHdr '(Number)',0 ; ( d1 addr1 -- d2 addr2 )
00097D  1  62 65 72 29  
000981  1  08 09 2E     
000984  1                  ; Convert the ASCII text beginning at addr1+1 with regard to BASE.  The new value
000984  1                  ; is accumulated into double number d1, being left as d2.  Addr2 is the address
000984  1                  ; of the first unconvertable digit.  Used by NUMBER.
000984  1               PNumber:
000984  1  9C           @1971:	LDAA ZW			; addr1+=1
000985  1  38           	INA
000986  1  BC           	STAA ZW
000987  1  88           	LDABA AW		; get char
000988  1  C0 D0        	LDBBL $100-'0'		; 0..9?
00098A  1  40 31        	ADDB AL,BL
00098C  1  11 48        	BNL @bad
00098E  1  C0 0A        	LDBBL 10
000990  1  49           	SABB
000991  1  11 18        	BNL @base
000993  1  C0 F9        	LDBBL $100-7
000995  1  40 31        	ADDB AL,BL
000997  1  C0 0A        	LDBBL 10		; A..Z?
000999  1  49           	SABB
00099A  1  11 3A        	BNL @bad
00099C  1  C1 70 85     	LDBBD 1+VBase
00099F  1  49           	SABB
0009A0  1  11 0F        	BNL @ok
0009A2  1  C0 E0        	LDBBL $100-$20		; a..z?
0009A4  1  40 31        	ADDB AL,BL
0009A6  1  C0 0A        	LDBBL 10
0009A8  1  49           	SABB
0009A9  1  11 2B        	BNL @bad
0009AB  1  C1 70 85     @base:	LDBBD 1+VBase		; >=base?
0009AE  1  49           	SABB
0009AF  1  10 25        	BL @bad
0009B1  1               @ok:
0009B1  1  DC           	LDBA ZW			; save addr1 on return stack
0009B2  1  F5 A2        	STBX SW,ModBMRB,0
0009B4  1  22 00        	CLRB AH
0009B6  1  BC           	STAA ZW			; ( ul uh digit )
0009B7  1               
0009B7  1  79 02 A1     	JSRD Swap		; ( ul digit uh )
0009BA  1  7B 1B        	JSRR @mul		; ( u1 digit dh )
0009BC  1  30 81        	INR ZW,2		; ( ul digit uh )
0009BE  1  79 02 80     	JSRD Rot		; ( digit uh ul )  ( n1 n2 n3 -- n2 n3 n1 )
0009C1  1  79 09 D7     	JSRD @mul		; ( digit uh dl )
0009C4  1  79 05 03     	JSRD DPlus		; ( d2 )
0009C7  1  91 70 86     	LDAD VDPL		; decimal_places>=0?
0009CA  1  16 04        	BM @1998
0009CC  1  38           	INA
0009CD  1  B1 70 86     	STAD VDPL		;   increment decimal_places
0009D0  1               @1998:
0009D0  1  95 A1        	LDAX SW,ModBRPB,0	; pop addr1 from return stack  ( d2 addr )
0009D2  1  B5 82        	STAX ZW,ModBMRB,0
0009D4  1  73 AE        	JMPR @1971		; back for more digits
0009D6  1               
0009D6  1  09           @bad:	RSR			; we hit something not-a-number, return
0009D7  1               
0009D7  1  91 70 84     @mul:	LDAD VBase
0009DA  1  B5 82        	STAX ZW,ModBMRB,0
0009DC  1  71 06 BB     	JMPD UMStar
0009DF  1               
0009DF  1               
0009DF  1  4E 75 6D 62   FHdr 'Number',0 ; ( addr -- d )
0009E3  1  65 72 06 09  
0009E7  1  84           
0009E8  1                  ; Convert a character string left at addr with a preceeding count, to a signed
0009E8  1                  ; double number, using the current numeric base.  If a decimal point is encountered
0009E8  1                  ; in the text its position will be given in DPL, but no other effect occurs.
0009E8  1                  ; If numeric conversion is not possible, an error message will be given.
0009E8  1  6D A2        Number:	STXX SW,ModBMRB,0	; save X
0009EA  1  65 80        	LDXX ZW,ModBRB,0	; get addr
0009EC  1  3A           	CLA			; push 0.
0009ED  1  BC           	STAA ZW
0009EE  1  B5 82        	STAX ZW,ModBMRB,0
0009F0  1  31 81        	DCR ZW,2		; ( d addr )
0009F2  1               
0009F2  1  91 70 84     	LDAD VBase		; save default base
0009F5  1  B5 A2        	STAX SW,ModBMRB,0
0009F7  1  90 FF FF     	LDAL $ffff		; init decimal places to "no . found"
0009FA  1  B1 70 86     	STAD VDPL
0009FD  1               
0009FD  1  3E           	INXC			; skip string count byte
0009FE  1  8A           	LDABA XW		; look at next char
0009FF  1  C0 2D        	LDBBL '-'		; negative sign?
000A01  1  49           	SABB
000A02  1  E5 A2        	STBBX SW,ModBMRB,0	;   save this for finish
000A04  1  15 02        	BNZ @17
000A06  1  3E           	INXC			;   skip sign char
000A07  1  8A           	LDABA XW
000A08  1               @17:
000A08  1  C0 24        	LDBBL '$'		;    hex?
000A0A  1  49           	SABB
000A0B  1  14 1D        	BZ @Hex
000A0D  1  C0 27        	LDBBL "'"		;    char literal?
000A0F  1  49           	SABB
000A10  1  14 1E        	BZ @Char
000A12  1  3F           @29:	DCX			; save addr of remaining string-1
000A13  1  6D 80        	STXX ZW,ModBRB,0
000A15  1               
000A15  1  79 09 84     @2023:	JSRD PNumber		; do some digits
000A18  1  85 84        	LDABX ZW,ModABRB,0	; look at next char
000A1A  1  C0 20        	LDBBL ' '		; blank?
000A1C  1  49           	SABB
000A1D  1  14 27        	BZ @2042
000A1F  1  C0 2E        	LDBBL '.'		; '.'?
000A21  1  49           	SABB
000A22  1  15 1D        	BNZ @err
000A24  1  3A           	CLA			; remember the dot
000A25  1  B1 70 86     	STAD VDPL
000A28  1  73 EB        	JMPR @2023		; back for more chars
000A2A  1               
000A2A  1               @Hex:	; temporary hex base
000A2A  1  79 0D 3B     	JSRD Hex
000A2D  1  3E           	INXC
000A2E  1  73 E2        	JMPR @29
000A30  1               
000A30  1               @Char: ; char literal
000A30  1  85 48 02     	LDABX XW,ModNBRB,2	; check ending delimiter
000A33  1  C0 27        	LDBBL "'"
000A35  1  49           	SABB
000A36  1  15 DA        	BNZ @29
000A38  1  3A           	CLA			; get char
000A39  1  85 48 01     	LDABX XW,ModNBRB,1
000A3C  1  B5 88 04     	STAX ZW,ModNBRB,4
000A3F  1  73 05        	JMPR @2042
000A41  1               
000A41  1  32 20        @err:	CLR BW,Err_0		; unconvertable digit, signal error
000A43  1  79 0F 6A     	JSRD ErrorY
000A46  1               
000A46  1               @2042:				; done
000A46  1  30 81        	INR ZW,2		; drop addr
000A48  1  85 A1        	LDABX SW,ModBRPB,0	; was there a '-' sign?
000A4A  1  15 03        	BNZ @2047
000A4C  1  79 05 59     	JSRD DNegate		;   negate the result
000A4F  1               @2047:
000A4F  1  95 A1        	LDAX SW,ModBRPB,0	; restore base
000A51  1  B1 70 84     	STAD VBase
000A54  1  65 A1        	LDXX SW,ModBRPB,0	; restore X
000A56  1  09           	RSR			; return
000A57  1               
000A57  1               
000A57  1               	.if 0
000A57  1                FHdr '>Number',0 ; ( ud1 addr1 u1  ud2 addr2 u2 )
000A57  1                  ;Return value ud2 is the unsigned result of converting the characters within the string specified
000A57  1                  ; by addr1 u1 into digits, using the number in BASE, and adding each into ud1 after multiplying
000A57  1                  ; ud1 by the number in BASE. Conversion continues left-to-right until a character that is not
000A57  1                  ; convertible, including any + or -, is encountered or the string is entirely converted.
000A57  1                  ; Address addr2 is the location of the first unconverted character or the first character past
000A57  1                  ; the end of the string if the string was entirely converted.
000A57  1                  ; Length u2 is the number of unconverted characters in the string.
000A57  1               	JSRD Abort ;???
000A57  1               	.endif
000A57  1               
000A57  1               
000A57  1               ; These small numbers are used so often that it is attractive to define them
000A57  1               ; by name in the dictionary as constants.
000A57  1               
000A57  1  30 81 09 E8   FHdr '0',ha_inline ; ( -- n )  constant: 0
000A5B  1  3A           Zero:	CLA
000A5C  1  B5 82        	STAX ZW,ModBMRB,0
000A5E  1  09 09        	.dbyt INL_End
000A60  1               
000A60  1               
000A60  1  31 81 0A 5B   FHdr '1',ha_inline ; ( -- n )  constant: 1
000A64  1  32 01        One:	CLR AW,1
000A66  1  B5 82        	STAX ZW,ModBMRB,0
000A68  1  09 09        	.dbyt INL_End
000A6A  1               
000A6A  1               
000A6A  1  32 81 0A 64   FHdr '2',ha_inline ; ( -- n )  constant: 2
000A6E  1  32 02        Two:	CLR AW,2
000A70  1  B5 82        	STAX ZW,ModBMRB,0
000A72  1  09 09        	.dbyt INL_End
000A74  1               
000A74  1               
000A74  1  33 81 0A 6E   FHdr '3',ha_inline ; ( -- n )  constant: 3
000A78  1  32 03        Three:	CLR AW,3
000A7A  1  B5 82        	STAX ZW,ModBMRB,0
000A7C  1  09 09        	.dbyt INL_End
000A7E  1               
000A7E  1               
000A7E  1  42 6C 82 0A   FHdr 'Bl',ha_inline ; ( -- n )	constant: the ASCII value for "blank".
000A82  1  78           
000A83  1               ; https://forth-standard.org/standard/core/BL
000A83  1  90 00 20     Bl:	LDAL ' '		; push a blank & return
000A86  1  B5 82        	STAX ZW,ModBMRB,0
000A88  1  09 09        	.dbyt INL_End
000A8A  1               
000A8A  1               
000A8A  1  43 2F 4C 03   FHdr 'C/L',0 ; ( -- n )  constant: chars per screen line
000A8E  1  0A 83        
000A90  1  90 00 40     CSlashL: LDAL 64
000A93  1  B5 82        	STAX ZW,ModBMRB,0
000A95  1  09           	RSR
000A96  1               
000A96  1               
000A96  1  42 2F 42 75   FHdr 'B/Buf',0 ; ( -- n )  constant: number of bytes per disc buffer,
000A9A  1  66 05 0A 90  
000A9E  1               			; the byte count read from disc by BLOCK.
000A9E  1  90 01 00     BBuf:	LDAL SectorSize
000AA1  1  B5 82        	STAX ZW,ModBMRB,0
000AA3  1  09           	RSR
000AA4  1               
000AA4  1               
000AA4  1  42 2F 53 63   FHdr 'B/Scr',0 ; ( -- n )  constant: number of blocks per editing screen.
000AA8  1  72 05 0A 9E  
000AAC  1               		; By convention, an editing screen is 1024 bytes organized as 16 lines of 64 chars each.
000AAC  1  90 00 04     BScr:	LDAL 1024/SectorSize
000AAF  1  B5 82        	STAX ZW,ModBMRB,0
000AB1  1  09           	RSR
000AB2  1               
000AB2  1               
000AB2  1  2B 4F 72 69   FHdr '+Origin',0 ; ( n -- adr )  Memory address relative by n to the origin parameter area.
000AB6  1  67 69 6E 07  
000ABA  1  0A AC        
000ABC  1               	; n is the minimum address unit, either byte or word.
000ABC  1               	; This definition is used to access or modify the boot-up parameters at the origin area.
000ABC  1  90 02 00     POrig:	LDAL ORIG
000ABF  1  71 04 DF     	JMPD PlusA
000AC2  1               
000AC2  1               
000AC2  1  55 73 65 72   FHdr 'User',0 ;
000AC6  1  04 0A BC     
000AC9  1                  ; A defining word used in the form:
000AC9  1                  ;	n USER cccc
000AC9  1                  ; which creates a user variable cccc.
000AC9  1                  ; When cccc is later executed, it places the sum of its offset and the user area
000AC9  1                  ; base address on the stack as the storage address of that particular variable.
000AC9  1  79 12 C2     User:	JSRD HeaderComma	; compile word header
000ACC  1  79 11 2A     	JSRD LdaImmedComma	; compile "ldal n"
000ACF  1  90 0B 5E     	LDAL DoUser		; compile "jmp DoUser" & return
000AD2  1  71 10 F5     	JMPD JmpCommaA
000AD5  1               
000AD5  1               
000AD5  1  42 53 02 0A   FHdr 'BS',0 ; ( -- n )	User variable
000AD9  1  C9           
000ADA  1  90 70 60     BS:	LDAL VBS
000ADD  1  73 7F        	JMPR DoUser
000ADF  1               
000ADF  1               
000ADF  1  54 49 42 03   FHdr 'TIB',0 ; ( -- adr )  User variable
000AE3  1  0A DA        
000AE5  1  90 70 68     TIB:	LDAL VTIB
000AE8  1  73 74        	JMPR DoUser
000AEA  1               
000AEA  1               
000AEA  1               	.if 0
000AEA  1                FHdr '#TIB',0 ; (  addr )  User variable
000AEA  1               	HLT ; ??Contains the size of the contents of the terminal input buffer.
000AEA  1               	.endif
000AEA  1               
000AEA  1               
000AEA  1  57 69 64 74   FHdr 'Width',0 ; ( -- adr )  User variable
000AEE  1  68 05 0A E5  
000AF2  1  90 70 6A     Width:	LDAL VWidth
000AF5  1  73 67        	JMPR DoUser
000AF7  1               
000AF7  1               
000AF7  1  57 61 72 6E   FHdr 'Warning',0 ; ( -- adr )  User variable
000AFB  1  69 6E 67 07  
000AFF  1  0A F2        
000B01  1  90 70 6C     Warning: LDAL VWarning
000B04  1  73 58        	JMPR DoUser
000B06  1               
000B06  1               
000B06  1  46 65 6E 63   FHdr 'Fence',0 ; ( -- adr )  User variable
000B0A  1  65 05 0B 01  
000B0E  1  90 70 6E     Fence:	LDAL VFence
000B11  1  73 4B        	JMPR DoUser
000B13  1               
000B13  1               
000B13  1  44 50 02 0B   FHdr 'DP',0 ; ( -- adr )  User variable
000B17  1  0E           
000B18  1  90 70 70     DP:	LDAL VDP
000B1B  1  73 41        	JMPR DoUser
000B1D  1               
000B1D  1               
000B1D  1  56 6F 63 2D   FHdr 'Voc-Link',0 ; ( -- adr )  User variable
000B21  1  4C 69 6E 6B  
000B25  1  08 0B 18     
000B28  1  90 70 72     VocL:	LDAL VVoc_Link
000B2B  1  73 31        	JMPR DoUser
000B2D  1               
000B2D  1               
000B2D  1  42 6C 6B 03   FHdr 'Blk',0 ; ( -- adr )  User variable
000B31  1  0B 28        
000B33  1  90 70 74     Blk:	LDAL VBlk
000B36  1  73 26        	JMPR DoUser
000B38  1               
000B38  1               
000B38  1  49 6E 02 0B   FHdr 'In',0 ; ( -- adr )  User variable
000B3C  1  33           
000B3D  1  90 70 76     In:	LDAL VIn
000B40  1  73 1C        	JMPR DoUser
000B42  1               
000B42  1               
000B42  1  3E 49 4E 03   FHdr '>IN',0 ; ( -- a-addr )
000B46  1  0B 3D        
000B48  1                  ; a-addr is the address of a cell containing the offset in characters from the start of the input
000B48  1                  ; buffer to the start of the parse area.
000B48  1                  ; https://forth-standard.org/standard/core/toIN
000B48  1  73 F3        ToIn:	JMPR In
000B4A  1               
000B4A  1               
000B4A  1  4F 75 74 03   FHdr 'Out',0 ; ( -- adr )  User variable
000B4E  1  0B 48        
000B50  1  90 70 78     Out:	LDAL VOut
000B53  1  73 09        	JMPR DoUser
000B55  1               
000B55  1               
000B55  1  53 63 72 03   FHdr 'Scr',0 ; ( -- adr )  User variable
000B59  1  0B 50        
000B5B  1  90 70 7A     Scr:	LDAL VScr
000B5E  1               ;	JMPR DoUser
000B5E  1               
000B5E  1               
000B5E  1               DoUser: ; runtime.  Push A + user area base
000B5E  1  B5 82        	STAX ZW,ModBMRB,0	; push A
000B60  1               ;	LDBD VUA		; add user area base
000B60  1               ;	AAB
000B60  1               ;	STBX ZW,ModBMRB,0	; push B
000B60  1  09           	RSR			; return
000B61  1               
000B61  1               
000B61  1  4F 66 66 73   FHdr 'Offset',0 ; ( -- adr )  User variable
000B65  1  65 74 06 0B  
000B69  1  5B           
000B6A  1  90 70 7C     Offset:	LDAL VOffset
000B6D  1  73 EF        	JMPR DoUser
000B6F  1               
000B6F  1               
000B6F  1  43 6F 6E 74   FHdr 'Context',0 ; ( -- adr )  User variable
000B73  1  65 78 74 07  
000B77  1  0B 6A        
000B79  1  90 70 7E     Context: LDAL VContext
000B7C  1  73 E0        	JMPR DoUser
000B7E  1               
000B7E  1               
000B7E  1  43 75 72 72   FHdr 'Current',0 ; ( -- adr )  User variable
000B82  1  65 6E 74 07  
000B86  1  0B 79        
000B88  1  90 70 80     Current: LDAL VCurrent
000B8B  1  73 D1        	JMPR DoUser
000B8D  1               
000B8D  1               
000B8D  1  53 74 61 74   FHdr 'State',0 ; ( -- adr )  User variable
000B91  1  65 05 0B 88  
000B95  1  90 70 82     State:	LDAL VState
000B98  1  73 C4        	JMPR DoUser
000B9A  1               
000B9A  1               
000B9A  1  42 61 73 65   FHdr 'Base',0 ; ( -- adr )  User variable
000B9E  1  04 0B 95     
000BA1  1  90 70 84     Base:	LDAL VBase
000BA4  1  73 B8        	JMPR DoUser
000BA6  1               
000BA6  1               
000BA6  1  44 50 4C 03   FHdr 'DPL',0 ; ( -- adr )  User variable
000BAA  1  0B A1        
000BAC  1  90 70 86     DPL:	LDAL VDPL
000BAF  1  73 AD        	JMPR DoUser
000BB1  1               
000BB1  1               
000BB1  1  46 6C 64 03   FHdr 'Fld',0 ; ( -- adr )  User variable
000BB5  1  0B AC        
000BB7  1  90 70 88     Fld:	LDAL VFld
000BBA  1  73 A2        	JMPR DoUser
000BBC  1               
000BBC  1               
000BBC  1  43 53 50 03   FHdr 'CSP',0 ; ( -- adr )  User variable
000BC0  1  0B B7        
000BC2  1  90 70 8A     CSP:	LDAL VCSP
000BC5  1  73 97        	JMPR DoUser
000BC7  1               
000BC7  1               
000BC7  1  52 23 02 0B   FHdr 'R#',0 ; ( -- adr )  User variable
000BCB  1  C2           
000BCC  1  90 70 8C     RNum:	LDAL VRNum
000BCF  1  71 0B 5E     	JMPD DoUser
000BD2  1               
000BD2  1               
000BD2  1  48 6C 64 03   FHdr 'Hld',0 ; ( -- adr )  User variable
000BD6  1  0B CC        
000BD8  1  90 70 8E     Hld:	LDAL VHld
000BDB  1  71 0B 5E     	JMPD DoUser
000BDE  1               
000BDE  1               
000BDE  1               	.if 0
000BDE  1                FHdr 'N',0 ; ( -- adr )  User variable
000BDE  1               N:	LDAL VN
000BDE  1               	JMPD DoUser
000BDE  1               	.endif
000BDE  1               
000BDE  1               
000BDE  1  46 50 74 72   FHdr 'FPtr',0 ; ( -- adr )  User variable
000BE2  1  04 0B D8     
000BE5  1  90 70 91     FPtr:	LDAL VFPtr
000BE8  1  71 0B 5E     	JMPD DoUser
000BEB  1               
000BEB  1               
000BEB  1  46 70 4C 6F   FHdr 'FpLo',0 ; ( -- adr )  User variable
000BEF  1  04 0B E5     
000BF2  1  90 70 93     FpLo:	LDAL VFpLo
000BF5  1  71 0B 5E     	JMPD DoUser
000BF8  1               
000BF8  1               
000BF8  1  46 70 48 69   FHdr 'FpHi',0 ; ( -- adr )  User variable
000BFC  1  04 0B F2     
000BFF  1  90 70 95     FpHi:	LDAL VFpHi
000C02  1  71 0B 5E     	JMPD DoUser
000C05  1               
000C05  1               
000C05  1  48 65 72 65   FHdr 'Here',0 ; ( -- n )  Leave the address of the next available dictionary location.
000C09  1  04 0B FF     
000C0C  1                  ; https://forth-standard.org/standard/core/HERE
000C0C  1  91 70 70     Here:	LDAD VDP		; get next available dictionary location
000C0F  1  B5 82        	STAX ZW,ModBMRB,0	; push it
000C11  1  09           	RSR			; return
000C12  1               
000C12  1               
000C12  1  4C 61 74 65   FHdr 'Latest',0 ; ( -- addr )
000C16  1  73 74 06 0C  
000C1A  1  0C           
000C1B  1                  ; Leave the code field address of the topmost word in the CURRENT vocabulary.
000C1B  1  92 70 80     Latest:	LDAI VCurrent
000C1E  1  B5 82        	STAX ZW,ModBMRB,0	; push A
000C20  1  09           	RSR
000C21  1               
000C21  1               
000C21  1  43 4D 6F 76   FHdr 'CMove',0 ; ( src_addr dest_addr len -- )
000C25  1  65 05 0C 1B  
000C29  1                  ; Move the specified quantity of bytes beginning at src_addr to dest_addr.
000C29  1                  ; The contents of src_addr is moved first proceeding toward high memory.
000C29  1                  ; Further specification is necessary on word addressing computers.
000C29  1                  ; This would probably run faster if it took advantage of word load & store.
000C29  1                  ; https://forth-standard.org/standard/string/CMOVE
000C29  1                  ; Also: CPU6 0xf7 memcpy instruction
000C29  1  6D A2        CMove:	STXX SW,ModBMRB,0	; save X
000C2B  1  65 81        	LDXX ZW,ModBRPB,0	; pop len
000C2D  1  95 81        	LDAX ZW,ModBRPB,0	; pop dest
000C2F  1  5C           	XAY
000C30  1  D5 81        	LDBX ZW,ModBRPB,0	; pop src
000C32  1  55 44        	XFR XW,XW		; len=0?
000C34  1  14 07        	BZ @Done
000C36  1  85 21        @4:	LDABX BW,ModBRPB,0	; copy a byte
000C38  1  A5 61        	STABX YW,ModBRPB,0
000C3A  1  3F           	DCX
000C3B  1  15 F9        	BNZ @4
000C3D  1  65 A1        @Done:	LDXX SW,ModBRPB,0	; restore X
000C3F  1  09           	RSR
000C40  1               
000C40  1               
000C40  1  43 4D 6F 76   FHdr 'CMove>',0 ; ( src_addr dest_addr len -- )
000C44  1  65 3E 06 0C  
000C48  1  29           
000C49  1                  ; Move the specified quantity of bytes beginning at src_addr to dest_addr.
000C49  1                  ; Moves proceeding toward low memory.
000C49  1                  ; This would probably run faster if it took advantage of word load & store.
000C49  1                  ; https://forth-standard.org/standard/string/CMOVEtop
000C49  1  6D A2        CMoveG:	STXX SW,ModBMRB,0	; save X
000C4B  1  65 81        	LDXX ZW,ModBRPB,0	; pop len
000C4D  1  95 81        	LDAX ZW,ModBRPB,0	; pop dest
000C4F  1  5C           	XAY
000C50  1  D5 81        	LDBX ZW,ModBRPB,0	; pop src
000C52  1  55 44        	XFR XW,XW		; len=0?
000C54  1  14 0B        	BZ @Done
000C56  1  50 42        	ADD BW,XW
000C58  1  50 46        	ADD YW,XW
000C5A  1  85 22        @4:	LDABX BW,ModBMRB,0	; copy a byte
000C5C  1  A5 62        	STABX YW,ModBMRB,0
000C5E  1  3F           	DCX
000C5F  1  15 F9        	BNZ @4
000C61  1  65 A1        @Done:	LDXX SW,ModBRPB,0	; restore X
000C63  1  09           	RSR
000C64  1               
000C64  1               
000C64  1  4D 6F 76 65   FHdr 'Move',0 ; ( src_addr dest_addr len -- )
000C68  1  04 0C 49     
000C6B  1                  ; After this move, the u bytes at addr2 contain exactly what the u bytes at addr1 contained before
000C6B  1                  ; the move (no clobbering occurs).
000C6B  1                  ; https://forth-standard.org/standard/core/MOVE
000C6B  1  95 88 04     Move:	LDAX ZW,ModNBRB,4
000C6E  1  D5 88 02     	LDBX ZW,ModNBRB,2
000C71  1  59           	SAB
000C72  1  10 B5        	BL CMove
000C74  1  73 D3        	JMPR CMoveG
000C76  1               
000C76  1               
000C76  1               	.if 0
000C76  1                FHdr 'Compare',0 ; ( addr1 u1 addr2 u2  n )
000C76  1                  ;Compare the string specified by addr1 and u1 to the string specified by addr2 and u2.
000C76  1                  ; The strings are compared, beginning at the given addresses, character by character up
000C76  1                  ; to the length of the shorter string, or until a difference is found.
000C76  1                  ; If both strings are the same up to the length of the shorter string, then the longer
000C76  1                  ; string is greater than the shorter string.
000C76  1                  ; n is -1 if the string specified by addr1 and u1 is less than the string specified by addr2 and u2.
000C76  1                  ; n is zero if the strings are equal.
000C76  1                  ; n is 1 if the string specified by addr1 and u1 is greater than the string specified by addr2 and u2.
000C76  1                  ; https://forth-standard.org/standard/string/COMPARE
000C76  1               Compare:
000C76  1               	STXX SW,ModBMRB,0	; save X
000C76  1               	XFR AW,ZW		; save Z
000C76  1               	STAX SW,ModBMRB,0
000C76  1               
000C76  1               	JSRD Abort ;???
000C76  1               
000C76  1               	LDBX ZW,ModBRPB,0	; pop u2
000C76  1               	LDAZ ZW,ModBRPB,0	; pop addr2
000C76  1               	XAY
000C76  1               	LDAX ZW,ModBRPB,0	; pop u2
000C76  1               	SAB
000C76  1               	STBA ZW			; save u1-u2
000C76  1               	BL @17
000C76  1               	LDAA ZW
000C76  1               @17:	XAY			; save min(u1,u2)
000C76  1               	XFR AW,ZW		; push Z
000C76  1               	STAX SW,ModBMRB,0
000C76  1               
000C76  1               	LDAX ZW,ModNBRB,2	; X = addr2
000C76  1               	XAX
000C76  1               	LDAX ZW,ModNBRB,6	; Z = addr1
000C76  1               	XAZ
000C76  1               @12:	DCR YW,1
000C76  1               	BZ @30
000C76  1               	LDABX XW,ModBRPB,0	; get chars
000C76  1               	LDBBX ZW,ModBRPB,0
000C76  1               	SABB
000C76  1               	BZ @12
000C76  1               
000C76  1               @20:	CLR BW,0
000C76  1               	RLR BW,2
000C76  1               	INR SW,2		; rdrop u1-u2
000C76  1               @22:	LDAA SW			; restore Z
000C76  1               	XAZ
000C76  1               	INR ZW,6		; drop u2, addr2, u1
000C76  1               	STBA ZW			; save n
000C76  1               	LDXX SW,ModBRPB,0	; restore X
000C76  1               	RSR
000C76  1               
000C76  1               @30: ; chars are equal, compare lengths
000C76  1               
000C76  1               	.endif
000C76  1               
000C76  1               
000C76  1  46 69 6C 6C   FHdr 'Fill',0 ; ( adr len value -- )  Fill memory at the address with the specified quantity of bytes value.
000C7A  1  04 0C 6B     
000C7D  1                  ; https://forth-standard.org/standard/core/FILL
000C7D  1  D5 81        Fill:	LDBX ZW,ModBRPB,0	; pop value
000C7F  1  55 46        Fill1:	XFR YW,XW		; save X
000C81  1  95 81        	LDAX ZW,ModBRPB,0	; pop len
000C83  1  38           	INA
000C84  1  65 81        	LDXX ZW,ModBRPB,0	; pop adr
000C86  1  73 02        	JMPR @8
000C88  1               
000C88  1  E5 41        @2:	STBBX XW,ModBRPB,0	; store a byte
000C8A  1  39           @8:	DCA			; count it
000C8B  1  15 FB        	BNZ @2
000C8D  1  55 64        	XFR XW,YW		; restore X
000C8F  1  09           	RSR
000C90  1               
000C90  1               
000C90  1  45 72 61 73   FHdr 'Erase',0 ; ( adr len -- )  Clear a region of memory to zero from addr over len addresses.
000C94  1  65 05 0C 7D  
000C98  1                  ; https://forth-standard.org/standard/core/ERASE
000C98  1  C0 00        Erase:	LDBBL 0			; fill value
000C9A  1  73 E3        	JMPR Fill1		; do Fill, & return
000C9C  1               
000C9C  1               
000C9C  1  42 6C 61 6E   FHdr 'Blanks',0 ; ( adr count -- )  Fill an area of memory beginning at addr with blanks.
000CA0  1  6B 73 06 0C  
000CA4  1  98           
000CA5  1                  ; https://forth-standard.org/standard/string/BLANK
000CA5  1  C0 20        Blanks:	LDBBL ' '		; fill value
000CA7  1  73 D6        	JMPR Fill1		; do Fill, & return
000CA9  1               
000CA9  1               ;----------------------
000CA9  1               ; 1st Terminal muliplexer port
000CA9  1               
000CA9  1               Term0CmdStat = $f200	; command (Write) & status (Read)
000CA9  1               Term0Data = $f201	; data tx (Write) & rx (Read)
000CA9  1               
000CA9  1               ;TermInit:
000CA9  1               ;	LDABL $c5		; configure UART - 9600,n,8,1
000CA9  1               ;	STABD Term0CmdStat
000CA9  1               ;	RSR
000CA9  1               
000CA9  1               
000CA9  1  4B 65 79 03   FHdr 'Key',0 ; ( -- n )
000CAD  1  0C A5        
000CAF  1                  ; Leave the ASCII value of the next terminal key struck.
000CAF  1                  ; https://forth-standard.org/standard/core/KEY
000CAF  1               Key:
000CAF  1               	.if 1
000CAF  1  71 1D C4     	JMPD Tty_GetC
000CB2  1               
000CB2  1               KeyA = Tty_GetC_A ; reads one terminal keystroke to A
000CB2  1               
000CB2  1               	.else
000CB2  1               
000CB2  1               	JSRR KeyA
000CB2  1               	STAX ZW,ModBMRB,0	; push it on param stack
000CB2  1               	RSR			; return
000CB2  1               
000CB2  1               KeyA: ; reads one terminal keystroke to A
000CB2  1               @1:	LDABD Term0CmdStat	; char ready?
000CB2  1               	SRAB
000CB2  1               	BNL @Empty
000CB2  1               	CLA			; get char
000CB2  1               	LDABD Term0Data
000CB2  1               	LDBBL $7f		; strip hi bit
000CB2  1               	ANDB AL,BL
000CB2  1               	RSR
000CB2  1               
000CB2  1               @Empty:	; queue empty
000CB2  1               ;	JSRD Pause		; wait awhile
000CB2  1               	JMPR @1			; & try again
000CB2  1               
000CB2  1               	.endif
000CB2  1               
000CB2  1               
000CB2  1  3F 54 65 72   FHdr '?Terminal',0 ; ( -- f )
000CB6  1  6D 69 6E 61  
000CBA  1  6C 09 0C AF  
000CBE  1                  ; Perform a test of the terminal keyboard for actuation of the break key.
000CBE  1                  ; A true flags indicates actuation.
000CBE  1                  ; This definition is installation dependent.
000CBE  1               QTerminal:
000CBE  1               	.if 1
000CBE  1  71 1D EA     	JMPD Tty_Next
000CC1  1               
000CC1  1               QTerminalA:
000CC1  1  7B FB        	JSRR QTerminal
000CC3  1  95 81        	LDAX ZW,ModBRPB,0	; set flags too
000CC5  1  09           	RSR
000CC6  1               
000CC6  1               	.else
000CC6  1               	JSRR QTerminalA
000CC6  1               	STAX ZW,ModBMRB,0	; push it
000CC6  1               	RSR			; return
000CC6  1               
000CC6  1               QTerminalA: ; leaves a boolean in A & V flag representing terminal break
000CC6  1               	CLA
000CC6  1               	LDABD Term0CmdStat
000CC6  1               	LDBL 1
000CC6  1               	ANDC AW,BW
000CC6  1               	RSR
000CC6  1               	.endif
000CC6  1               
000CC6  1               
000CC6  1  45 6D 69 74   FHdr 'Emit',0 ; ( n -- )
000CCA  1  04 0C BE     
000CCD  1                  ; Transmit ASCII char n to the selected output device.
000CCD  1                  ; OUT is incremented for each char output.
000CCD  1                  ; https://forth-standard.org/standard/core/EMIT
000CCD  1               Emit:	; writes one ASCII character to terminal
000CCD  1  91 70 78     	LDAD VOut	; count the char
000CD0  1  38           	INA
000CD1  1  B1 70 78     	STAD VOut
000CD4  1               	.if 1
000CD4  1  71 1D 84     	JMPD Tty_PutC
000CD7  1               	.else
000CD7  1               @1:	LDABD Term0CmdStat ; ready?
000CD7  1               	SRAB
000CD7  1               	SRAB
000CD7  1               	BNL @Full
000CD7  1               
000CD7  1               	LDAX ZW,ModBRPB,0	; pop n
000CD7  1               	STABD Term0Data		; transmit it
000CD7  1               	RSR
000CD7  1               
000CD7  1               @Full:	; queue full
000CD7  1               ;	JSRD Pause		; wait awhile
000CD7  1               	JMPR @1			; & try again
000CD7  1               	.endif
000CD7  1               
000CD7  1               
000CD7  1               EmitA: ; writes one ASCII character in A to terminal
000CD7  1  B5 82        	STAX ZW,ModBMRB,0	; push char
000CD9  1  F5 A2        	STBX SW,ModBMRB,0	; push B
000CDB  1  55 62        	XFR BW,YW		; push Y
000CDD  1  F5 A2        	STBX SW,ModBMRB,0
000CDF  1  7B EC        	JSRR Emit		; do it
000CE1  1  95 A1        	LDAX SW,ModBRPB,0	; pop Y
000CE3  1  5C           	XAY
000CE4  1  D5 A1        	LDBX SW,ModBRPB,0	; pop B
000CE6  1  09           	RSR
000CE7  1               
000CE7  1               
000CE7  1  43 52 02 0C   FHdr 'CR',0 ; ( -- )  Transmit a carriage return and line feed to the selected output device.
000CEB  1  CD           
000CEC  1                  ; https://forth-standard.org/standard/core/CR
000CEC  1  80 0D        CR:	LDABL $0d		; send CR
000CEE  1  7B E7        	JSRR EmitA
000CF0  1  80 0A        	LDABL $0a		; send LF
000CF2  1  7B E3        	JSRR EmitA
000CF4  1  3A           	CLA			; clear output position
000CF5  1  B1 70 78     	STAD VOut
000CF8  1  09           	RSR
000CF9  1               
000CF9  1               
000CF9  1  53 70 61 63   FHdr 'Space',0 ; ( -- )  InseRSR an ASCII blank to the output device.
000CFD  1  65 05 0C EC  
000D01  1                  ; https://forth-standard.org/standard/core/SPACE
000D01  1  80 20        Space:	LDABL ' '
000D03  1  73 D2        	JMPR EmitA
000D05  1               
000D05  1               
000D05  1  53 70 61 63   FHdr 'Spaces',0 ; ( n -- )  Transmit n ASCII blanks to the output device.
000D09  1  65 73 06 0D  
000D0D  1  01           
000D0E  1                  ; https://forth-standard.org/standard/core/SPACES
000D0E  1  73 03        Spaces:	JMPR @8
000D10  1               
000D10  1  BC           @2:	STAA ZW			; save n
000D11  1  7B EE        	JSRR Space		; type 1 space
000D13  1  9C           @8:	LDAA ZW			; load n
000D14  1  39           	DCA			; decrement n
000D15  1  17 F9        	BP @2			; >=0?
000D17  1  30 81        	INR ZW,2		; drop n
000D19  1  09           	RSR			; return
000D1A  1               
000D1A  1               
000D1A  1  54 79 70 65   FHdr 'Type',0 ; ( adr len -- )  Transmit len chars from addr to the selected output device.
000D1E  1  04 0D 0E     
000D21  1                  ; https://forth-standard.org/standard/core/TYPE
000D21  1  9C           Type:	LDAA ZW			; test remaining length
000D22  1  14 0E        	BZ @9
000D24  1  39           	DCA			; decrement length
000D25  1  BC           	STAA ZW
000D26  1  D5 88 02     	LDBX ZW,ModNBRB,2	; get addr
000D29  1  85 21        	LDABX BW,ModBRPB,0	; get char
000D2B  1  F5 88 02     	STBX ZW,ModNBRB,2	; save updated addr
000D2E  1  7B A7        	JSRR EmitA		; send to console
000D30  1  73 EF        	JMPR Type
000D32  1               
000D32  1  30 83        @9:	INR ZW,4		; pop len & adr
000D34  1  09           	RSR			; return
000D35  1               
000D35  1               
000D35  1  48 65 78 03   FHdr 'Hex',0 ; ( -- )  Set the numeric conversion base to sixteen (hexadecimal).
000D39  1  0D 21        
000D3B  1                  ; https://forth-standard.org/standard/core/HEX
000D3B  1  90 00 10     Hex:	LDAL 16			; Base=16
000D3E  1  73 0C        	JMPR Decim3
000D40  1               
000D40  1               
000D40  1  44 65 63 69   FHdr 'Decimal',0 ; ( -- )  set the numeric conversion base for decimal input-output.
000D44  1  6D 61 6C 07  
000D48  1  0D 3B        
000D4A  1                  ; https://forth-standard.org/standard/core/DECIMAL
000D4A  1  32 0A        Decimal: CLR AW,10		; Base=10
000D4C  1  B1 70 84     Decim3:	STAD VBase
000D4F  1  09           	RSR
000D50  1               
000D50  1               
000D50  1               	.if 0
000D50  1                FHdr 'Octal',0 ; ( -- )  set the numeric conversion base for octa input-output.
000D50  1               Decimal: CLR AW,8		; Base=8
000D50  1               	JMPR Decim3
000D50  1               	.endif
000D50  1               
000D50  1               
000D50  1               PadSize = 68	; PAD is 68 ( C/L + a little) bytes above here.
000D50  1               
000D50  1  50 61 64 03   FHdr 'Pad',0 ; ( -- adr )  address of the text output buffer, which is a fixed offset above HERE .
000D54  1  0D 4A        
000D56  1                  ; https://forth-standard.org/standard/core/PAD
000D56  1  7B 03        Pad:	JSRR PadA		; get Pad in A
000D58  1  B5 82        	STAX ZW,ModBMRB,0	; push it
000D5A  1  09           	RSR			; return
000D5B  1               
000D5B  1  91 70 70     PadA:	LDAD VDP		; get dictionary location
000D5E  1  D0 00 44     	LDBL PadSize
000D61  1  50 20        	ADD AW,BW
000D63  1  09           	RSR
000D64  1               
000D64  1               
000D64  1  3C 23 02 0D   FHdr '<#',0 ; ( --- )
000D68  1  56           
000D69  1                  ; Setup for pictured numeric output formatting using the words:
000D69  1                  ;	<# # #S SIGN #>
000D69  1                  ; The conversion is done on a double number producting text at PAD .
000D69  1                  ; https://forth-standard.org/standard/core/num-start
000D69  1  7B F0        BDigs:	JSRR PadA		; Hld= PAD addr
000D6B  1  B1 70 8E     	STAD VHld
000D6E  1  09           	RSR			; return
000D6F  1               
000D6F  1               
000D6F  1  48 6F 6C 64   FHdr 'Hold',0 ; ( c -- )
000D73  1  04 0D 69     
000D76  1                  ; Used between <# and #> to insert an ASCII char into a pictured numeric
000D76  1                  ; output string.  e.g. 2E HOLD will place a decimal point.
000D76  1                  ; https://forth-standard.org/standard/core/HOLD
000D76  1  95 81        Hold:	LDAX ZW,ModBRPB,0	; pop c
000D78  1  D1 70 8E     HoldA:	LDBD VHld
000D7B  1  A5 22        	STABX BW,ModBMRB,0	; decr addr & store char
000D7D  1  F1 70 8E     	STBD VHld
000D80  1  09           	RSR			; return
000D81  1               
000D81  1               
000D81  1               	.if 0
000D81  1                FHdr 'HoldS',0 ; ( c-addr u -- )
000D81  1                  ; Adds the string represented by c-addr u to the pictured numeric output string.
000D81  1                  ; An ambiguous condition exists if HOLDS executes outside of a <# #> delimited number conversion.
000D81  1                  ; https://forth-standard.org/standard/core/HOLDS
000D81  1               HoldS:	LDAX ZW,ModNBRB,2	; get c-addr
000D81  1               	XAY
000D81  1               @11:	LDAA ZW			; get u
000D81  1               	BZ @19
000D81  1               	DCA
000D81  1               	STAA ZW
000D81  1               	LDABX YW,ModBRPB,0	; get char
000D81  1               	JSRD EmitA
000D81  1               	JMPR @11
000D81  1               
000D81  1               @19:	INR ZW,4		; drop u & c-addr
000D81  1               	RSR
000D81  1               	.endif
000D81  1               
000D81  1               
000D81  1  23 3E 02 0D   FHdr '#>',0 ; ( ud -- adr count )
000D85  1  76           
000D86  1                  ; Terminates numeric output conversion by dropping ud, leaving the text
000D86  1                  ; addres and char count suitable for TYPE.
000D86  1                  ; https://forth-standard.org/standard/core/num-end
000D86  1  91 70 8E     EDigs:	LDAD VHld
000D89  1  B5 88 02     	STAX ZW,ModNBRB,2	; store adr
000D8C  1  79 0D 5B     	JSRD PadA		; count=PAD-Hld
000D8F  1  D1 70 8E     	LDBD VHld
000D92  1  59           	SAB
000D93  1  FC           	STBA ZW			; store count
000D94  1  09           	RSR			; return
000D95  1               
000D95  1               
000D95  1  53 69 67 6E   FHdr 'Sign',0 ; ( n d -- d )
000D99  1  04 0D 86     
000D9C  1                  ; Stores an ASCII '-' sign just before a converted numeric output string in the text
000D9C  1                  ; buffer when n is negative.  n is discarded, but double number d is maintained.
000D9C  1                  ; Must be used between <# and #> .
000D9C  1                  ; https://forth-standard.org/standard/core/SIGN
000D9C  1  79 02 80     Sign:	JSRD Rot		; bring n to top of param stack
000D9F  1  95 81        	LDAX ZW,ModBRPB,0	; <0?
000DA1  1  17 04        	BP @3496
000DA3  1  80 2D        	LDABL '-'		;   append '-'
000DA5  1  15 D1        	BNZ HoldA
000DA7  1  09           @3496:	RSR			; return
000DA8  1               
000DA8  1               
000DA8  1  23 01 0D 9C   FHdr '#',0 ; ( ud1 -- ud2 )
000DAC  1                  ; Generate from a double number ud1, the next ASCII char which is placed in
000DAC  1                  ; an output string.  Result ud2 is the quotient after division by BASE, and
000DAC  1                  ; is maintained for further processing.  Used between <# and #>.  See #S.
000DAC  1                  ; https://forth-standard.org/standard/core/num
000DAC  1  91 70 84     Hash:	LDAD VBase
000DAF  1  B5 82        	STAX ZW,ModBMRB,0	; ( ud1 u )
000DB1  1  79 07 4B     	JSRD MSlashMod		; ( rem ud2 )
000DB4  1  79 02 80     	JSRD Rot		; ( ud2 remainder )
000DB7  1  95 81        	LDAX ZW,ModBRPB,0	; pop remainder
000DB9  1  C0 0A        	LDBBL 10		; >=10?
000DBB  1  49           	SABB
000DBC  1  11 04        	BNL @3517
000DBE  1  C0 07        	LDBBL 7			;   change from ASCII digit to letter
000DC0  1  40 31        	ADDB AL,BL
000DC2  1  C0 30        @3517:	LDBBL '0'		; convert to ASCII
000DC4  1  40 31        	ADDB AL,BL
000DC6  1  73 B0        	JMPR HoldA		; append to HOLD, & return
000DC8  1               
000DC8  1               
000DC8  1  23 53 02 0D   FHdr '#S',0 ; ( ud1 -- ud2 )
000DCC  1  AC           
000DCD  1                  ; Generates ASCII text in the text output buffer, by the use of #, until
000DCD  1                  ; a zero double number ud2 results.  Used between <# and #>.
000DCD  1                  ; https://forth-standard.org/standard/core/numS
000DCD  1               HashS:
000DCD  1  7B DD        @3529:	JSRR Hash		; do a digit
000DCF  1  95 88 02     	LDAX ZW,ModNBRB,2	;  until ud1=0
000DD2  1  DC           	LDBA ZW
000DD3  1  53 02        	ORI BW,AW
000DD5  1  15 F6        	BNZ @3529
000DD7  1  09           	RSR			; return
000DD8  1               
000DD8  1               
000DD8  1  44 2E 52 03   FHdr 'D.R',0 ; ( d numdigits -- )
000DDC  1  0D CD        
000DDE  1                  ; Print a signed double number d right aligned in a field n chars wide.
000DDE  1                  ; https://forth-standard.org/standard/double/DDotR
000DDE  1  95 81        DDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000DE0  1  B5 A2        	STAX SW,ModBMRB,0
000DE2  1  79 02 A1     DDotR3:	JSRD Swap		; push sign under d
000DE5  1  79 02 CC     	JSRD Over
000DE8  1  79 05 6F     	JSRD DAbs		; d=abs(d)
000DEB  1  79 0D 69     	JSRD BDigs		; begin collecting string
000DEE  1  7B DD        	JSRR HashS		; do all digits
000DF0  1  7B AA        	JSRR Sign		; do sign
000DF2  1  79 0D 86     DDotR7:	JSRD EDigs		; end collecting string
000DF5  1  95 A1        	LDAX SW,ModBRPB,0	; get numdigits from return stack
000DF7  1  DC           	LDBA ZW			; calc # of padding spaces
000DF8  1  59           	SAB
000DF9  1  F5 82        	STBX ZW,ModBMRB,0	; type that many spaces
000DFB  1  79 0D 0E     	JSRD Spaces
000DFE  1  71 0D 21     	JMPD Type		; type the string, & return
000E01  1               
000E01  1               
000E01  1  55 44 2E 52   FHdr 'UD.R',0 ; ( d numdigits -- )
000E05  1  04 0D DE     
000E08  1                  ; Print an unsigned double number d right aligned in a field n chars wide.
000E08  1  95 81        UDDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000E0A  1  B5 A2        	STAX SW,ModBMRB,0
000E0C  1  79 0D 69     	JSRD BDigs		; begin collecting string
000E0F  1  7B BC        	JSRR HashS		; do all digits
000E11  1  73 DF        	JMPR DDotR7
000E13  1               
000E13  1               
000E13  1  55 44 2E 03   FHdr 'UD.',0 ; ( d -- )
000E17  1  0E 08        
000E19  1  79 0D 69     UDDot:	JSRD BDigs		; begin collecting string
000E1C  1  7B AF        	JSRR HashS		; do all digits
000E1E  1  79 0D 86     	JSRD EDigs		; end collecting string
000E21  1  79 0D 21     	JSRD Type
000E24  1  71 0D 01     	JMPD Space
000E27  1               
000E27  1               
000E27  1  44 2E 02 0E   FHdr 'D.',0 ; ( d -- )  Print a signed double number from a 32 bit two's complement value.
000E2B  1  19           
000E2C  1                  ; The high-order 16 bits are most accessable on the stack.  Conversion is
000E2C  1                  ; performed according to the current BASE .  A blank follows.
000E2C  1                  ; https://forth-standard.org/standard/double/Dd
000E2C  1  79 0A 5B     DDot:	JSRD Zero		; push min # of digits
000E2F  1  7B AD        	JSRR DDotR		; do D.R
000E31  1  71 0D 01     	JMPD Space		; type a space, & return
000E34  1               
000E34  1               
000E34  1  2E 52 02 0E   FHdr '.R',0 ; ( n numdigits -- )
000E38  1  2C           
000E39  1                  ; https://forth-standard.org/standard/core/DotR
000E39  1  95 81        DotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000E3B  1  B5 A2        	STAX SW,ModBMRB,0
000E3D  1  79 06 AD     	JSRD SToD		; convert n to double
000E40  1  73 A0        	JMPR DDotR3		; do D.R, & return
000E42  1               
000E42  1               
000E42  1  55 2E 52 03   FHdr 'U.R',0 ; ( u numdigits -- )
000E46  1  0E 39        
000E48  1                  ; https://forth-standard.org/standard/core/UDotR
000E48  1  95 81        UDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
000E4A  1  B5 A2        	STAX SW,ModBMRB,0
000E4C  1  3A           	CLA			; convert u to double
000E4D  1  B5 82        	STAX ZW,ModBMRB,0
000E4F  1  73 91        	JMPR DDotR3		; do D.R, & return
000E51  1               
000E51  1               
000E51  1  55 2E 02 0E   FHdr 'U.',0 ; ( u -- )
000E55  1  48           
000E56  1                  ; https://forth-standard.org/standard/core/Ud
000E56  1  79 0A 5B     UDot:	JSRD Zero
000E59  1  7B ED        	JSRR UDotR
000E5B  1  71 0D 01     	JMPD Space
000E5E  1               
000E5E  1               
000E5E  1  2E 01 0E 56   FHdr '.',0 ; ( n -- )  Print a number from a signed 16 bit two's complement value,
000E62  1                  ; converted according to the numeric BASE.  A traling blank follows.
000E62  1                  ; https://forth-standard.org/standard/core/d
000E62  1  79 06 AD     Dot:	JSRD SToD		; convert n to double
000E65  1  73 C5        	JMPR DDot		; do D. , & return
000E67  1               
000E67  1               
000E67  1  3F 01 0E 62   FHdr '?',0 ; ( adr -- )  Print the value contained at the address
000E6B  1                  ; in free format according to the current base.
000E6B  1                  ; https://forth-standard.org/standard/tools/q
000E6B  1  79 08 0C     Ques:	JSRD At			; fetch the word at addr
000E6E  1  73 F2        	JMPR Dot		; type it, & return
000E70  1               
000E70  1               
000E70  1               	.if 0
000E70  1                FHdr 'Accept',0 ; ( addr u1 -- u2 )  Receives u1 characters (or until carriage return) from the
000E70  1                  ; terminal keyboard and stores them, starting at the address.
000E70  1                  ; The count of received characters is returned.
000E70  1               	.endif
000E70  1               
000E70  1               
000E70  1  45 78 70 65   FHdr 'Expect',0 ; ( addr count -- )
000E74  1  63 74 06 0E  
000E78  1  6B           
000E79  1                  ; Transfer chars from the terminal to address, until a "return" or the count of
000E79  1                  ; chars have been received.  One or more nulls area added at the end of the text.
000E79  1  6D A2        Expect:	STXX SW,ModBMRB,0	; push X
000E7B  1  32 40        	CLR XW,0		; index=0
000E7D  1  79 01 0F     @next:	JSRD KeyA
000E80  1  D1 70 60     	LDBD VBS		; backspace?
000E83  1  49           	SABB
000E84  1  14 20        	BZ @bs
000E86  1  C0 0D        	LDBBL $0D		; return?
000E88  1  49           	SABB
000E89  1  14 0F        	BZ @cr
000E8B  1               
000E8B  1  D5 88 02     	LDBX ZW,ModNBRB,2
000E8E  1  50 42        	ADD BW,XW
000E90  1  A9           	STABA BW		; store the char
000E91  1  3E           	INXC			; advance index
000E92  1  79 0C D7     	JSRD EmitA		; update the terminal
000E95  1  DC           	LDBA ZW			; at end_of_line?
000E96  1  51 42        	SUB BW,XW
000E98  1  11 E3        	BNL @next
000E9A  1               
000E9A  1  D5 88 02     @cr:	LDBX ZW,ModNBRB,2	; insert trailing NULLs
000E9D  1  50 42        	ADD BW,XW
000E9F  1  3A           	CLA
000EA0  1  B9           	STAA BW
000EA1  1  65 A1        	LDXX SW,ModBRPB,0	; pop X
000EA3  1  30 83        	INR ZW,4		; TwoDrop
000EA5  1  09           	RSR
000EA6  1               
000EA6  1  55 42        @bs:	XFR BW,XW		; at begin_of_line?
000EA8  1  14 D3        	BZ @next
000EAA  1  3F           	DCX			; back up ptr
000EAB  1  80 08        	LDABL $08		; back up terminal
000EAD  1  79 0C D7     	JSRD EmitA
000EB0  1  73 CB        	JMPR @next		; next
000EB2  1               
000EB2  1               
000EB2  1  51 75 65 72   FHdr 'Query',0 ; ( -- )
000EB6  1  79 05 0E 79  
000EBA  1                  ; Input 80 chars of text (or until a "return") from the operators terminal.
000EBA  1                  ; Text is positioned at the address contained in TIB with IN set to zero.
000EBA  1  3A           Query:	CLA			; IN=0
000EBB  1  B1 70 76     	STAD VIn
000EBE  1  91 70 68     	LDAD VTIB		; buffer addr
000EC1  1  B5 82        	STAX ZW,ModBMRB,0
000EC3  1  90 00 50     	LDAL 80			; 80 characters from terminal
000EC6  1  B5 82        	STAX ZW,ModBMRB,0
000EC8  1  73 AF        	JMPR Expect
000ECA  1               
000ECA  1               
000ECA  1  28 41 62 6F   FHdr '(Abort)',0 ;
000ECE  1  72 74 29 07  
000ED2  1  0E BA        
000ED4  1               ; Executes after an error when WARNING is -1.  This word normally executes ABORT,
000ED4  1               ; but may be altered (with care) to a user's alternative procedure.
000ED4  1  71 17 8D     PAbort:	JMPD Abort
000ED7  1               
000ED7  1               
000ED7  1  45 72 72 6F   FHdr 'Error',0 ; ( error_number -- in blk )  Execute error notification and restart of the system.
000EDB  1  72 05 0E D4  
000EDF  1                  ; WARNING is first examined.  If 1, the text of line n, relative to screen 4 of drive 0 is
000EDF  1                  ; printed.  This line number may be positive or negative, and beyond just screen 4.
000EDF  1                  ; If WARNING=0, n is just printed as a message number (non disc installation).
000EDF  1                  ; If WARNING is -1, the definition (ABORT) is executed, which executes the system ABORT.
000EDF  1                  ; The user may cautionsly modify this execute by altering (ABORT) .
000EDF  1                  ; fig-FORTH saves the contents of IN and BLK to assist in determinging the location of the error.
000EDF  1                  ; Final action is execution of QUIT .
000EDF  1  91 70 6C     Error:	LDAD VWarning		; Warning<0?
000EE2  1  16 F0        	BM PAbort
000EE4  1  79 0D 01     	JSRD Space
000EE7  1  79 0C 0C     	JSRD Here		; type the interpreted word
000EEA  1  79 08 63     	JSRD Count
000EED  1  79 0D 21     	JSRD Type
000EF0  1  79 14 39     	JSRD PDotQuote		; type "  ? "
000EF3  1  05 20 20 3F  	.byte 5,'  ?',0,' '	; "?\0 " sequence triggers simulator to stop feeding text from file
000EF7  1  00 20        
000EF9  1  79 19 9E     	JSRD Message		; type the error
000EFC  1  79 02 45     	JSRD EmptyStack		; empty the param stack
000EFF  1  79 14 39     	JSRD PDotQuote		; show text position
000F02  1  07 20 42 6C  	.byte 7," Block="
000F06  1  6F 63 6B 3D  
000F0A  1  91 70 74     	LDAD VBlk
000F0D  1  B5 82        	STAX ZW,ModBMRB,0
000F0F  1  79 0E 62     	JSRD Dot
000F12  1  79 14 39     	JSRD PDotQuote
000F15  1  07 4F 66 66  	.byte 7,"Offset="
000F19  1  73 65 74 3D  
000F1D  1  91 70 76     	LDAD VIn
000F20  1  B5 82        	STAX ZW,ModBMRB,0
000F22  1  79 0E 62     	JSRD Dot
000F25  1  71 17 39     	JMPD Quit		; restart the interpreter
000F28  1               
000F28  1               
000F28  1  3F 53 74 61   FHdr '?Stack',0 ; ( -- )  Issue an error message if the stack is out of bounds.
000F2C  1  63 6B 06 0E  
000F30  1  DF           
000F31  1  90 71 16     QStack:	LDAL TOS+1		; param atack beyond empty?
000F34  1  51 80        	SUB AW,ZW
000F36  1  10 08        	BL @underflow
000F38  1  90 70 9D     	LDAL BOS+6		; param stack beyond full?
000F3B  1  51 80        	SUB AW,ZW
000F3D  1  11 05        	BNL @overflow
000F3F  1  09           	RSR
000F40  1               
000F40  1  32 21        @underflow: CLR BW,Err_StackUnderflow
000F42  1  73 26        	JMPR ErrorY
000F44  1               
000F44  1  D0 00 07     @overflow: LDBL Err_StackOverflow
000F47  1  73 21        	JMPR ErrorY
000F49  1               
000F49  1               
000F49  1  3F 45 72 72   FHdr '?Error',0 ; ( f n -- )  Issue an error message number n, if f is true;
000F4D  1  6F 72 06 0F  
000F51  1  31           
000F52  1  D5 81        QErr:	LDBX ZW,ModBRPB,0	; pop n
000F54  1  95 81        QErrY:	LDAX ZW,ModBRPB,0	; f true?
000F56  1  15 14        	BNZ ErrorY2		;   signal error
000F58  1  09           	RSR			; return
000F59  1               
000F59  1               
000F59  1  3F 43 6F 6D   FHdr '?Comp',0 ; ( -- )  Issue error message if not compiling.
000F5D  1  70 05 0F 52  
000F61  1  D0 00 11     QComp:	LDBL Err_CompileOnly
000F64  1  91 70 82     	LDAD VState		; not compiling?
000F67  1  14 01        	BZ ErrorY		;   signal error
000F69  1  09           	RSR			; return
000F6A  1               
000F6A  1               ErrorY:				; error code in B
000F6A  1  31 81        	DCR ZW,2
000F6C  1  FC           ErrorY2: STBA ZW
000F6D  1  71 0E DF     	JMPD Error
000F70  1               
000F70  1               
000F70  1  3F 45 78 65   FHdr '?Exec',0 ; ( -- )  Issue an error message if not executing.
000F74  1  63 05 0F 61  
000F78  1  D0 00 12     QExec:	LDBL Err_ExecuteOnly
000F7B  1  91 70 82     	LDAD VState		; compiling?
000F7E  1  15 EA        	BNZ ErrorY		;   signal error
000F80  1  09           	RSR			; return
000F81  1               
000F81  1               
000F81  1  3F 50 61 69   FHdr '?Pairs',0 ; ( n1 n2 -- )  Issue an error message if n1 != n2.
000F85  1  72 73 06 0F  
000F89  1  78           
000F8A  1                  ; The message indicates that compiled conditionals do not match.
000F8A  1  95 81        QPairs:	LDAX ZW,ModBRPB,0	; pop n2
000F8C  1  D5 81        QPairsA: LDBX ZW,ModBRPB,0	; pop n1
000F8E  1  59           	SAB			; n2<>n1?
000F8F  1  14 D0        	BZ QComp		; also verify we're compiling
000F91  1  D0 00 13     	LDBL Err_ConditionalsNotPaired
000F94  1  73 D6        	JMPR ErrorY2		;   signal error
000F96  1               
000F96  1               
000F96  1  21 43 53 50   FHdr '!CSP',0 ; ( -- )  Save the param stack index in CSP. Used as part of the compiler security.
000F9A  1  04 0F 8A     
000F9D  1  55 80        SCSP:	XFR AW,ZW
000F9F  1  B1 70 8A     	STAD VCSP
000FA2  1  09           	RSR
000FA3  1               
000FA3  1               
000FA3  1  3F 43 53 50   FHdr '?CSP',0 ; ( -- )  Issue error message if stack index <> value saved in CSP.
000FA7  1  04 0F 9D     
000FAA  1  D0 00 14     QCSP:	LDBL Err_DefinitionNotFinished
000FAD  1  91 70 8A     	LDAD VCSP		; param stack index different than saved?
000FB0  1  51 80        	SUB AW,ZW
000FB2  1  15 B6        	BNZ ErrorY		;   signal error
000FB4  1  09           	RSR			; return
000FB5  1               
000FB5  1               
000FB5  1  3F 4C 6F 61   FHdr '?Loading',0 ; ( -- )  Issue an error message if not loading.
000FB9  1  64 69 6E 67  
000FBD  1  08 0F AA     
000FC0  1  D0 00 16     QLoad:	LDBL Err_UseOnlyWhenLoading
000FC3  1  91 70 74     	LDAD VBlk		; no block?
000FC6  1  14 A2        	BZ ErrorY		;   signal error
000FC8  1  09           	RSR			; return
000FC9  1               
000FC9  1               
000FC9  1               	.if 0
000FC9  1                FHdr 'Buffer:',0
000FC9  1                  ; Compile: ( u "<spaces>name" -- )
000FC9  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Create a definition for name, with the execution
000FC9  1                  ;   semantics defined below. Reserve u address units at an aligned address.
000FC9  1                  ;   Contiguity of this region with any other region is undefined.
000FC9  1                  ; name Execution:
000FC9  1                  ;   ( -- a-addr )
000FC9  1                  ;   a-addr is the address of the space reserved by BUFFER: when it defined name.
000FC9  1                  ;   The program is responsible for initializing the contents.
000FC9  1                  ; https://forth-standard.org/standard/core/BUFFERColon
000FC9  1               BufferColon:
000FC9  1               	JSRD Create
000FC9  1               	JMPR Allot
000FC9  1               	.endif
000FC9  1               
000FC9  1               
000FC9  1  41 6C 6C 6F   FHdr 'Allot',0 ; ( n -- )  Add the signed number to the dictionary pointer DP.
000FCD  1  74 05 0F C0  
000FD1  1                  ; May be used to reserve dictionary space or re-origin memory.
000FD1  1                  ; n is with regard to computer address type (byte or word).
000FD1  1                  ; https://forth-standard.org/standard/core/ALLOT
000FD1  1  95 81        Allot:	LDAX ZW,ModBRPB,0	; pop n
000FD3  1  D1 70 70     AllotA:	LDBD VDP		; add to DP
000FD6  1  58           	AAB
000FD7  1               AllotCheck:
000FD7  1  F1 70 70     	STBD VDP
000FDA  1  90 6F BC     	LDAL DictTop-PadSize	; out of space?
000FDD  1  59           	SAB
000FDE  1  D0 00 02     	LDBL Err_DictionaryFull
000FE1  1  11 87        	BNL ErrorY
000FE3  1  09           	RSR			; return
000FE4  1               
000FE4  1               
000FE4  1  44 69 63 74   FHdr 'DictTop',0 ; ( -- u )  Return top of dictionary space
000FE8  1  54 6F 70 07  
000FEC  1  0F D1        
000FEE  1  90 70 00     	LDAL DictTop
000FF1  1  B5 82        	STAX ZW,ModBMRB,0
000FF3  1  09           	RSR
000FF4  1               
000FF4  1               
000FF4  1  55 6E 75 73   FHdr 'Unused',0 ; ( -- u )  Return the space remaining in the region addressed by HERE, in address units.
000FF8  1  65 64 06 0F  
000FFC  1  EE           
000FFD  1                  ; https://forth-standard.org/standard/core/UNUSED
000FFD  1  90 6F BC     Unused:	LDAL DictTop-PadSize
001000  1  D1 70 70     	LDBD VDP
001003  1  59           	SAB
001004  1  F5 82        	STBX ZW,ModBMRB,0
001006  1  09           	RSR
001007  1               
001007  1               
001007  1               ;----------------------------------------------------------------------
001007  1               ; Random #s
001007  1               
001007  1  52 6E 64 53   FHdr 'RndState',0  ; 2Variable
00100B  1  74 61 74 65  
00100F  1  08 0F FD     
001012  1               RndState1:
001012  1  90 71 9D     	LDAL RndState
001015  1  B5 82        	STAX ZW,ModBMRB,0
001017  1  09           	RSR
001018  1               
001018  1               
001018  1               	.if 0
001018  1                FHdr 'SRand',0 ; ( d -- ) set random # state
001018  1                  ; Pause is also modifying RndState
001018  1               SRand:	LDBX ZW,ModBRPB,0
001018  1               	LDAX ZW,ModBRPB,0
001018  1               	JMPR Rand8
001018  1               	.endif
001018  1               
001018  1               
001018  1  52 61 6E 64   FHdr 'Rand',0 ; ( -- n )  generate next random #
00101C  1  04 10 12     
00101F  1                  ; https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Galois_LFSRs
00101F  1                  ; https://en.wikipedia.org/wiki/Xorshift
00101F  1               Rand: ; 32bit Galois LFSR
00101F  1  91 71 9F     	LDAD 2+RndState		; BA=state
001022  1  D1 71 9D     	LDBD 0+RndState
001025  1  15 04        	BNZ @39			; fix state=0
001027  1  5C           	XAY
001028  1  15 01        	BNZ @39
00102A  1  38           	INA
00102B  1               @39:
00102B  1  07           	RL			; BA>>=1
00102C  1  36 20        	RRR BW,1
00102E  1  36 00        	RRR AW,1
001030  1  11 0E        	BNL @49
001032  1               
001032  1  55 46        	XFR YW,XW		; save X
001034  1  60 D0 00     	LDXL $d000		; BA^=$d0000001
001037  1  54 42        	ORE BW,XW
001039  1  60 00 01     	LDXL $0001
00103C  1  54 40        	ORE AW,XW
00103E  1  55 64        	XFR XW,YW		; restore X
001040  1  B5 82        @49:	STAX ZW,ModBMRB,0	; return value
001042  1  F1 71 9D     Rand8:	STBD 0+RndState		; save state
001045  1  B1 71 9F     	STAD 2+RndState
001048  1  09           	RSR
001049  1               
001049  1               
001049  1               	.if 0
001049  1                FHdr 'RndTest1',0 ; ( -- d )  test Rand period
001049  1               	LDBD 0+RndState		; push original state
001049  1               	LDAD 2+RndState
001049  1               	STAX SW,ModBMRB,0
001049  1               	STBX SW,ModBMRB,0
001049  1               	CLA			; 0.
001049  1               	STAX ZW,ModBMRB,0
001049  1               	STAX ZW,ModBMRB,0
001049  1               @3:
001049  1               	LDAA ZW			; increment d
001049  1               	INA
001049  1               	STAA ZW
001049  1               	BNZ @19
001049  1               	LDAX ZW,ModNBRB,2
001049  1               	INA
001049  1               	STAX ZW,ModNBRB,2
001049  1               	JSRD EX4A
001049  1               	JSRD Space
001049  1               @19:
001049  1               	JSRR Rand		; gen next number
001049  1               	INR ZW,2		;   drop result
001049  1               	XAY
001049  1               	LDAA SW			;  compare
001049  1               	SAB
001049  1               	BNZ @3
001049  1               	LDAX SW,ModNBRB,2
001049  1               	SUB AW,YW
001049  1               	BNZ @3
001049  1               
001049  1               	INR SW,4		; rdrop starting state
001049  1               	JMPD Swap		; fix count
001049  1               	.endif
001049  1               
001049  1               
001049  1  52 61 6E 64   FHdr 'RandM',0 ; ( umod -- u ) random integer between 0 & umod-1
00104D  1  4D 05 10 1F  
001051  1  95 81        RandM:	LDAX ZW,ModBRPB,0	; save umod
001053  1  B5 A2        	STAX SW,ModBMRB,0
001055  1  7B C8        	JSRR Rand		; get next random #
001057  1  F5 A2        	STBX SW,ModBMRB,0	; save hi part
001059  1  D5 A1        	LDBX SW,ModBRPB,0
00105B  1  F5 82        	STBX ZW,ModBMRB,0
00105D  1  79 06 E5     	JSRD UMSlashMod
001060  1  30 81        	INR ZW,2		; drop quotient
001062  1  09           	RSR
001063  1               
001063  1               
001063  1  44 65 66 65   FHdr 'Defer',0 ; ( "<spaces>name" -- )  https://forth-standard.org/standard/core/DEFER
001067  1  72 05 10 51  
00106B  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Create a definition for name with the execution semantics defined below.
00106B  1                  ; name Execution:
00106B  1                  ;   ( i * x -- j * x )
00106B  1                  ;   Execute the xt that name is set to execute. An ambiguous condition exists if name has not been set to execute an xt.
00106B  1  79 12 C2     Defer:	JSRD HeaderComma	; compile word header
00106E  1  90 17 8D     	LDAL Abort
001071  1  71 10 F5     	JMPD JmpCommaA
001074  1               
001074  1               
001074  1  44 65 66 65   FHdr 'Defer@',0 ; ( xt1 -- xt2 )  https://forth-standard.org/standard/core/DEFERFetch
001078  1  72 40 06 10  
00107C  1  6B           
00107D  1                  ;  xt2 is the execution token xt1 is set to execute. An ambiguous condition exists if xt1 is not the execution token of a word defined by DEFER, or if xt1 has not been set to execute an xt.
00107D  1               DeferAt:
00107D  1  9C           	LDAA ZW			; get xt1
00107E  1               	; check that the xt1 word is a Defer ?
00107E  1  D5 08 01     	LDBX AW,ModNBRB,1	; get jMPD operand
001081  1  FC           	STBA ZW			; store xt2
001082  1  09           	RSR
001083  1               
001083  1               
001083  1  44 65 66 65   FHdr 'Defer!',0 ; ( xt2 xt1 -- )  https://forth-standard.org/standard/core/DEFERStore
001087  1  72 21 06 10  
00108B  1  7D           
00108C  1                  ; Set the word xt1 to execute xt2. An ambiguous condition exists if xt1 is not for a word defined by DEFER.
00108C  1               DeferStore:
00108C  1  95 81        	LDAX ZW,ModBRPB,0	; pop xt1
00108E  1               	; check that the xt1 word is a Defer ?
00108E  1  D5 81        	LDBX ZW,ModBRPB,0	; pop xt2
001090  1  F5 08 01     	STBX AW,ModNBRB,1	; store xt2 into JMPD operand
001093  1  09           	RSR
001094  1               
001094  1               
001094  1               	.if 0
001094  1               
001094  1                FHdr 'Is',ha_immedate ;
001094  1                  ; Interpretation:
001094  1                  ;   ( xt "<spaces>name" -- )
001094  1                  ;   Skip leading spaces and parse name delimited by a space. Set name to execute xt.
001094  1                  ;   An ambiguous condition exists if name was not defined by DEFER.
001094  1                  ; Compilation:
001094  1                  ;   ( "<spaces>name" -- )
001094  1                  ;   Skip leading spaces and parse name delimited by a space. Append the run-time semantics given below to the current definition.
001094  1                  ;   An ambiguous condition exists if name was not defined by DEFER.
001094  1                  ; Run-time:
001094  1                  ;   ( xt -- )
001094  1                  ;   Set name to execute xt.
001094  1                  ; An ambiguous condition exists if POSTPONE, [COMPILE], ['] or ' is applied to IS.
001094  1                  ; https://forth-standard.org/standard/core/IS
001094  1               Is:	JSRD Tick		; look up the name
001094  1               	LDBD VState		; compiling?
001094  1               	BZ DeferStore
001094  1               
001094  1               	JSRD Swap
001094  1               	LDABL $90		; LDAL xt
001094  1               	JSRD CCommaA
001094  1               	JSRD Comma
001094  1               	LDABL $b1		; STAD name
001094  1               	JSRD CCommaA
001094  1               	JMPD Comma
001094  1               
001094  1               
001094  1                FHdr 'Action-Of',ha_immediate ; https://forth-standard.org/standard/core/ACTION-OF
001094  1                  ; Interpretation:
001094  1                  ;   ( "<spaces>name" -- xt )
001094  1                  ;   Skip leading spaces and parse name delimited by a space. xt is the execution token that name is set to execute.
001094  1                  ;   An ambiguous condition exists if name was not defined by DEFER, or if the name has not been set to execute an xt.
001094  1                  ; Compilation:
001094  1                  ;   ( "<spaces>name" -- )
001094  1                  ;   Skip leading spaces and parse name delimited by a space. Append the run-time semantics given below to the current definition.
001094  1                  ;   An ambiguous condition exists if name was not defined by DEFER.
001094  1                  ; Run-time:
001094  1                  ;   ( -- xt )
001094  1                  ;   xt is the execution token that name is set to execute. An ambiguous condition exists if name has not been set to execute an xt.
001094  1                  ;   An ambiguous condition exists if POSTPONE, [COMPILE], ['] or ' is applied to ACTION-OF.
001094  1               	JSRD Tick		; look up the inline name
001094  1               	LDAA ZW			; get name addr
001094  1               	LDABA AW		; check word 1st opcode
001094  1               	LDBBL $71		;    for JMPD
001094  1               	SABB
001094  1               	BNZ @Abort
001094  1               
001094  1               	LDAD VState		; compiling?
001094  1               	BZ DeferAt
001094  1               
001094  1               	LDABL $91		; LDAD name+1
001094  1               	JSRD CCommaA
001094  1               	JSRD OnePlus
001094  1               	JSRD Comma
001094  1               	JMPD PushAComma		; STAX ZW,ModBMRB,0	; push it
001094  1               
001094  1               	.endif
001094  1               
001094  1               
001094  1               	.if 0
001094  1               
001094  1                FHdr 'Align',ha_inline ; ( -- )  https://forth-standard.org/standard/core/ALIGN
001094  1                  ; If the data-space pointer is not aligned, reserve enough space to align it.
001094  1               	; do nothing, CPU6 doesn't care
001094  1               	.dbyt INL_End
001094  1               
001094  1               
001094  1                FHdr 'Aligned',ha_inline ; ( addr -- a-addr )  https://forth-standard.org/standard/core/ALIGNED
001094  1                  ; a-addr is the first aligned address greater than or equal to addr.
001094  1               		; do nothing, CPU6 doesn't care
001094  1               	.dbyt INL_End
001094  1               
001094  1               	.endif
001094  1               
001094  1               
001094  1               	.if 1
001094  1  50 6F 73 74   FHdr 'Postpone',ha_immediate ; ( "name" -- )
001098  1  70 6F 6E 65  
00109C  1  48 10 8C     
00109F  1                  ; Interpretation:
00109F  1                  ;   Interpretation semantics for this word are undefined.
00109F  1                  ; Compilation:
00109F  1                  ;   ( "<spaces>name" -- )
00109F  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Find name.
00109F  1                  ;   Append the compilation semantics of name to the current definition.
00109F  1                  ;   An ambiguous condition exists if name is not found.
00109F  1                  ; https://forth-standard.org/standard/core/POSTPONE
00109F  1               Postpone:
00109F  1  79 15 45     	JSRD TickNew		;find the word
0010A2  1  9C           	LDAA ZW			;get xt (aka nt)
0010A3  1  85 08 FD     	LDABX AW,ModNBRB,$fd	;get flags
0010A6  1               	.assert ha_immediate=$40, error, "code assumption"
0010A6  1  2D           	SLAB
0010A7  1  16 14        	BM CompileComma		; imemdiate, so do normal compile
0010A9  1               
0010A9  1               				; not immediate, so do deferred compilation
0010A9  1  79 11 2A     	JSRD LdaImmedComma	; ' "name"
0010AC  1  90 10 BF     	LDAL CompileCommaA	; COMPILE,
0010AF  1  71 10 E2     	JMPD JsrCommaA
0010B2  1               
0010B2  1               	.endif
0010B2  1               
0010B2  1               
0010B2  1               	.if 0
0010B2  1                FHdr 'Recurse',ha_immediate
0010B2  1                  ; Interpretation:
0010B2  1                  ;   Interpretation semantics for this word are undefined.
0010B2  1                  ; Compilation:
0010B2  1                  ;   ( -- )
0010B2  1                  ;   Append the execution semantics of the current definition to the current definition.
0010B2  1                  ;   An ambiguous condition exists if RECURSE appears in a definition after DOES>.
0010B2  1                  ; https://forth-standard.org/standard/core/RECURSE
0010B2  1               	LDBI VCurrent		; start of last word
0010B2  1               	JMPD JsrCommaA
0010B2  1               	.endif
0010B2  1               
0010B2  1               
0010B2  1               	.if 0
0010B2  1                FHdr '[Compile]',ha_immediate  ; https://forth-standard.org/standard/core/BracketCOMPILE
0010B2  1                  ; Interpretation:
0010B2  1                  ;   Interpretation semantics for this word are undefined.
0010B2  1                  ; Compilation:
0010B2  1                  ;   ( "<spaces>name" -- )
0010B2  1                  ;   Skip leading space delimiters. Parse name delimited by a space. Find name. If name has other than default
0010B2  1                  ; compilation semantics, append them to the current definition; otherwise append the execution semantics of name.
0010B2  1                  ; An ambiguous condition exists if name is not found.
0010B2  1               	JSRD Tick
0010B2  1               	JMPR CompileComma
0010B2  1               	.endif
0010B2  1               
0010B2  1               
0010B2  1  43 6F 6D 70   FHdr 'Compile,',0 ; ( addr -- ) compile a call to a word
0010B6  1  69 6C 65 2C  
0010BA  1  08 10 9F     
0010BD  1                  ; Not quite standard: it expects an nfa so it can look at the ha_inline flag bit
0010BD  1                  ; https://forth-standard.org/standard/core/COMPILEComma
0010BD  1               CompileComma:
0010BD  1  95 81        	LDAX ZW,ModBRPB,0	; pop addr from param stack
0010BF  1               CompileCommaA: ; nfa (name field addr, also code addr) in A
0010BF  1  C5 08 FD     	LDBBX AW,ModNBRB,$fd	; get flag & length byte
0010C2  1               	.assert ha_inline=$80, error, "ha_inline assumption"
0010C2  1  17 1E        	BP JsrCommaA		; not ha_inline, do JSR
0010C4  1  5C           	XAY			; copy inline bytes until marker
0010C5  1  9B           @11:	LDAA YW
0010C6  1  D0 09 09     	LDBL INL_End
0010C9  1  59           	SAB
0010CA  1  14 0C        	BZ @19
0010CC  1  45 01        	XFRB AL,AH
0010CE  1  7E 61        	PUSH YH,2
0010D0  1  7B 49        	JSRR CCommaA
0010D2  1  7F 61        	POP YH,2
0010D4  1  30 60        	INR YW,1
0010D6  1  73 ED        	JMPR @11
0010D8  1  09           @19:	RSR
0010D9  1               
0010D9  1               
0010D9  1  4A 73 72 2C   FHdr 'Jsr,',0 ; ( adr -- )  compile a "JSRD adr" to call a word
0010DD  1  04 10 BD     
0010E0  1  95 81        	LDAX ZW,ModBRPB,0	; pop adr
0010E2  1               JsrCommaA:
0010E2  1  B5 A2        	STAX SW,ModBMRB,0	; save addr
0010E4  1  80 79        	LDABL $79		; compile "JSRD direct" opcode
0010E6  1               Compile16:
0010E6  1  7B 33        	JSRR CCommaA		; compile opcode
0010E8  1  95 A1        	LDAX SW,ModBRPB,0	; compile 2byte operand, & return
0010EA  1  73 15        	JMPR CommaA
0010EC  1               
0010EC  1               
0010EC  1  4A 6D 70 2C   FHdr 'Jmp,',0 ; ( adr -- )  compile a "JMPD adr"
0010F0  1  04 10 E0     
0010F3  1               JmpComma:
0010F3  1  95 81        	LDAX ZW,ModBRPB,0
0010F5  1               JmpCommaA:
0010F5  1  B5 A2        	STAX SW,ModBMRB,0	; save operand
0010F7  1  80 71        	LDABL $71		; "JMPD abs" opcode
0010F9  1  73 EB        	JMPR Compile16
0010FB  1               
0010FB  1               
0010FB  1               
0010FB  1  2C 01 10 F3   FHdr ',',0 ; ( n -- )  Append n onto the dictionary.
0010FF  1                  ; https://forth-standard.org/standard/core/Comma
0010FF  1  95 81        Comma:	LDAX ZW,ModBRPB,0	; pop n
001101  1  D1 70 70     CommaA:	LDBD VDP		; store into dictionary
001104  1  B5 21        	STAX BW,ModBRPB,0
001106  1  3A           Comma2:	CLA			; store 0 (not required, helps in case of interrupted compile)
001107  1  B9           	STAA BW
001108  1  71 0F D7     	JMPD AllotCheck
00110B  1               
00110B  1               
00110B  1  32 2C 02 10   FHdr '2,',0 ; ( d -- )  Append d onto the dictionary
00110F  1  FF           
001110  1               TwoComma:
001110  1  7B ED        	JSRR Comma	; do hi word
001112  1  73 EB        	JMPR Comma	; do lo word, & return
001114  1               
001114  1               
001114  1  43 2C 02 11   FHdr 'C,',0 ; ( n -- )  Append byte n onto the dictionary.
001118  1  10           
001119  1                  ; https://forth-standard.org/standard/core/CComma
001119  1  95 81        CComma:	LDAX ZW,ModBRPB,0	; pop n
00111B  1  D1 70 70     CCommaA: LDBD VDP		; store
00111E  1  A5 21        	STABX BW,ModBRPB,0
001120  1  73 E4        	JMPR Comma2		; finish & return
001122  1               
001122  1               
001122  1               LdbaComma: ; ( d -- )  compile ldb # & lda #
001122  1  80 D0        	LDABL $d0		; LDBL n	do hi word
001124  1  7B 06        	JSRR LdComma
001126  1  73 02        	JMPR LdaImmedComma	;		do lo word
001128  1               
001128  1               LdaImmedCommaA: ; compile lda #
001128  1  B5 82        	STAX ZW,ModBMRB,0
00112A  1               LdaImmedComma: ; compile lda #
00112A  1  80 90        	LDABL $90		; LDAL n
00112C  1  7B ED        LdComma: JSRR CCommaA
00112E  1  73 CF        	JMPR Comma
001130  1               
001130  1               
001130  1                 .if 0
001130  1                FHdr 'Compile',0 ; ( -- )
001130  1                  ; see Compile,
001130  1                  ; When the word containing COMPILE executes, the execution address of the word
001130  1                  ; following COMPILE is copied (compiled) into the dictionary.  This allows
001130  1                  ; specific compilation situations to be handled in addition to simply compiling
001130  1                  ; an execution address (which the interpreter already does).
001130  1               Compile:
001130  1               	JSRD QComp	; verify we're compiling
001130  1               	LDAX SW,ModBRPB,0 ; get the word following the call to me
001130  1               	JMPR CompileCommaA ; compile the call, & return
001130  1                 .endif
001130  1               
001130  1               
001130  1  42 72 61 6E   FHdr 'Branch,',0 ; ( DestAddr branch_opcode -- ) compile a branch back
001134  1  63 68 2C 07  
001138  1  11 19        
00113A  1               BranchComma:
00113A  1  95 81        	LDAX ZW,ModBRPB,0	; pop opcode
00113C  1               BranchCommaA:
00113C  1  B5 A2        	STAX SW,ModBMRB,0	; save branch_opcode
00113E  1  DC           	LDBA ZW			; A=relative displacement of addr
00113F  1  31 21        	DCR BW,2
001141  1  91 70 70     	LDAD VDP
001144  1  51 20        	SUB AW,BW
001146  1  D0 00 80     	LDBL $80		; in range of an 8-bit displacement?
001149  1  59           	SAB
00114A  1  11 06        	BNL @Short
00114C  1  D0 FF 80     	LDBL $ff80
00114F  1  59           	SAB
001150  1  11 09        	BNL @Long
001152  1               
001152  1  BC           @Short:	STAA ZW			; drop addr, save displacement
001153  1  95 A1        	LDAX SW,ModBRPB,0	; compile branch_opcode
001155  1  79 11 1B     	JSRD CCommaA
001158  1  71 11 19     	JMPD CComma		; compile branch displacement, & return
00115B  1               
00115B  1  95 A1        @Long:	LDAX SW,ModBRPB,0	; get branch_opcode
00115D  1  D0 00 73     	LDBL $73		; unconditional branch opcode?
001160  1  49           	SABB
001161  1  14 90        	BZ JmpComma
001163  1  45 10        	XFRB AH,AL		; complement the branch opcode sense
001165  1  80 01        	LDABL 1
001167  1  44 10        	OREB AH,AL
001169  1  80 03        	LDABL 3			; set displacement to 3
00116B  1  79 11 01     	JSRD CommaA		; compile the branch
00116E  1  71 10 F3     	JMPD JmpComma
001171  1               
001171  1               
001171  1               ; FHdr '(0Branch',0 ; ( f A=addr -- )  The run-time procedure to conditionally branch.
001171  1               ;PZBranch: ; ( f A=addr -- )  0Branch runtime
001171  1               ;	LDBX ZW,ModBRPB,0	; if f is false
001171  1               ;	BNZ @9
001171  1               ;	XFR XW,BW
001171  1               ;@9:	RSR
001171  1               
001171  1               PZBranchComma: ; ( adr -- ) compile (0Branch)
001171  1  90 D5 81     	LDAL $D581		; LDBX ZW,ModBRPB,0 to pop & test flag
001174  1  79 11 01     	JSRD CommaA
001177  1  80 14        	LDABL $14		; compile BZ
001179  1  73 C1        	JMPR BranchCommaA
00117B  1               
00117B  1               
00117B  1               	.if 0
00117B  1                FHdr 'Ahead',0
00117B  1                  ; Interpretation:
00117B  1                  ;   Interpretation semantics for this word are undefined.
00117B  1                  ; Compilation:
00117B  1                  ;   ( C: -- orig )
00117B  1                  ;   Put the location of a new unresolved forward reference orig onto the control flow stack.
00117B  1                  ;   Append the run-time semantics given below to the current definition.
00117B  1                  ;   The semantics are incomplete until orig is resolved (e.g., by THEN).
00117B  1                  ;
00117B  1                  ; Run-time:
00117B  1                  ;   ( -- )
00117B  1                  ;   Continue execution at the location specified by the resolution of orig.
00117B  1               Ahead:
00117B  1               	JSRD Abort ;???
00117B  1               	.endif
00117B  1               
00117B  1               
00117B  1  49 66 42 11   FHdr 'If',ha_immediate	; ( f -- ) (run-time)
00117F  1  3A           
001180  1               			; ( -- addr n ) (compile)
001180  1                  ; Occurs in a colon-definition in form:
001180  1                  ;	IF (tp) ... ENDIF
001180  1                  ;	IF (tp ... ELSE (fp) ... ENDIF
001180  1                  ; At run-time, IF selects execution based on a bool flag.  If f is true
001180  1                  ; (non-zero), execution continues ahead thru the true part.  If f is false
001180  1                  ; (zero), execution skips till just after ELSE to execute the false part.
001180  1                  ; After either part, execution resumes after ENDIF . ELSE and its false part
001180  1                  ; are optional. If missing, false execution skips to just after ENDIF .
001180  1                  ;
001180  1                  ; At compile-time IF compiles 0BRANCH and reserves space for an offset at
001180  1                  ; addr.  addr and n are used later for resolution of the offset and
001180  1                  ; error testing.
001180  1                  ; https://forth-standard.org/standard/core/IF
001180  1  79 0F 61     If:	JSRD QComp		; verify we're compiling - this is bad news for interpreting
001183  1  90 17 8D     	LDAL Abort		; push dest addr
001186  1  B5 82        	STAX ZW,ModBMRB,0
001188  1  7B E7        	JSRR PZBranchComma	; compile (0Branch)
00118A  1  79 0C 0C     	JSRD Here		; push addr for fixup later
00118D  1  71 0A 6E     If7:	JMPD Two		; push "IF" pairing code, & return
001190  1               
001190  1               
001190  1  45 6C 73 65   FHdr 'Else',ha_immediate ; ( addr1 n1 -- addr2 ) (compiling)
001194  1  44 11 80     
001197  1                  ; Occurs within a colon-definition in the form:
001197  1                  ;	IF ... ELSE ... ENDIF
001197  1                  ; At run-time, ELSE executes after the true part following IF . ELSE forces
001197  1                  ; execution to skip over the following false part and resumes execution
001197  1                  ; after the ENDIF . It has no stack effects.
001197  1                  ;
001197  1                  ; At compile-time ELSE replaces BRANCH reserving a branch offset, leaves
001197  1                  ; the address addr2 and n2 for error testing.  ELSE also resolves the
001197  1                  ; pending forward branch from IF by calculation the offset from addr1
001197  1                  ; to HERE and storing at addr1.
001197  1                  ; https://forth-standard.org/standard/core/Dotq
001197  1  90 17 8D     Else:	LDAL Abort		; compile "jmp abort", addr to be fixed up later
00119A  1  79 10 F5     	JSRD JmpCommaA
00119D  1  7B 0C        	JSRR Then		; fixup the IF
00119F  1  79 0C 0C     	JSRD Here		; save addr for fixup later
0011A2  1  73 E9        	JMPR If7		; finish
0011A4  1               
0011A4  1               
0011A4  1  54 68 65 6E   FHdr 'Then',ha_immediate ; ( addr n -- ) (compile)
0011A8  1  44 11 97     
0011AB  1                  ; Occurs in a colon-definition in form:
0011AB  1                  ;	IF ... ENDIF
0011AB  1                  ;	IF ... ELSE ... THEN
0011AB  1                  ; At run-time, ENDIF serves only as the destination of a forward branch from
0011AB  1                  ; IF or ELSE . It marks the conclusion of the conditional structure.
0011AB  1                  ; THEN is another name for ENDIF.  Both names are supported in fig-FORTH.
0011AB  1                  ; See also IF and ELSE .
0011AB  1                  ;
0011AB  1                  ; At compile-time, ENDIF computes the forward branch offset from addr to
0011AB  1                  ; HERE and stores it at addr. n is used for error tests.
0011AB  1                  ; https://forth-standard.org/standard/core/THEN
0011AB  1  90 00 02     Then:	LDAL 2		; verify we're paired with an IF , & compiling
0011AE  1  79 0F 8C     	JSRD QPairsA
0011B1  1  D5 81        	LDBX ZW,ModBRPB,0	; fixup IF branch addr
0011B3  1  91 70 70     	LDAD VDP
0011B6  1  B5 28 FE     	STAX BW,ModNBRB,$fe
0011B9  1  09           	RSR		; return
0011BA  1               
0011BA  1               
0011BA  1               	.if 0
0011BA  1                FHdr 'EndIf',ha_immediate ;  FIG alias
0011BA  1               	JMPR Then
0011BA  1               	.endif
0011BA  1               
0011BA  1               
0011BA  1  42 65 67 69   FHdr 'Begin',ha_immediate ;  https://forth-standard.org/standard/core/BEGIN
0011BE  1  6E 45 11 AB  
0011C2  1                  ; Compiling: ( -- addr n )
0011C2  1                  ; Occurs in a colon-definition in the form:
0011C2  1                  ;	BEGIN ... UNTIL
0011C2  1                  ;	BEGIN ... AGAIN
0011C2  1                  ;	BEGIN ... WHILE ... REPEAT
0011C2  1                  ; At run-time, begin marks the start of a sequence that may be repetetively executed.
0011C2  1                  ; It serves as a return point from the corresponding UNTIL , AGAIN or REPEAT .
0011C2  1                  ; When executing UNTIL , a return to BEGIN will occur if the top of
0011C2  1                  ; the stack is false; for AGAIN and REPEAT a return to BEGIN always occurs.
0011C2  1                  ;
0011C2  1                  ; At compile time BEGIN leaves its return address and n for compiler error checking.
0011C2  1  79 0F 61     Begin:	JSRD QComp	; verify we're compiling
0011C5  1  79 0C 0C     	JSRD Here	; push dictionary addr
0011C8  1  71 0A 64     	JMPD One	; push "Begin" pairing code, & return
0011CB  1               
0011CB  1               
0011CB  1  55 6E 74 69   FHdr 'Until',ha_immediate ;  (     f -- ) (run-time)
0011CF  1  6C 45 11 C2  
0011D3  1               			  ;  ( adr n -- ) (compile)
0011D3  1                  ; Occurs withing a colon-definition in the form:
0011D3  1                  ;	BEGIN .. UNTIL
0011D3  1                  ; At run-time, UNTIL controls the conditional branch back to the corresponding
0011D3  1                  ; BEGIN .  If f is false, execution returns to just after BEGIN ;
0011D3  1                  ; if true, execution continues ahead.
0011D3  1                  ;
0011D3  1                  ; At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to addr.
0011D3  1                  ; n is used for error tests.
0011D3  1                  ; https://forth-standard.org/standard/core/UNTIL
0011D3  1  90 00 01     Until:	LDAL 1		; varify we're paired with a BEGIN, & compiling
0011D6  1  79 0F 8C     	JSRD QPairsA
0011D9  1  71 11 71     	JMPD PZBranchComma ; compile a 0Branch
0011DC  1               
0011DC  1               
0011DC  1  45 6E 64 43   FHdr 'End',ha_immediate ; FIG alias
0011E0  1  11 D3        
0011E2  1  73 EF        	JMPR Until
0011E4  1               
0011E4  1               
0011E4  1  41 67 61 69   FHdr 'Again',ha_immediate ; ( addr n -- ) (compiling)
0011E8  1  6E 45 11 E2  
0011EC  1                  ; Used in a colon-definition in the form:
0011EC  1                  ;	BEGIN ... AGAIN
0011EC  1                  ; At run-time, AGAIN forces execution to return to the corresponding BEGIN.
0011EC  1                  ; Three is no effect on the stack.  Execution cannot leave this loop (unless
0011EC  1                  ; R> DROP is executed one level below).
0011EC  1  90 00 01     Again:	LDAL 1		; verify we're paired with a BEGIN, & compiling
0011EF  1  79 0F 8C     	JSRD QPairsA
0011F2  1  80 73        	LDABL $73	; compile "jmpr adr", & return
0011F4  1  71 11 3C     	JMPD BranchCommaA
0011F7  1               
0011F7  1               
0011F7  1  57 68 69 6C   FHdr 'While',ha_immediate ; (    f -- ) (run-time)
0011FB  1  65 45 11 EC  
0011FF  1               				  ; ( ad1 n1 -- ad1 n1 ad2 n2 )
0011FF  1                  ; Occurs in a colon-definition in the form:
0011FF  1                  ;	BEGIN ... WHILE (tp) ... REPEAT
0011FF  1                  ; At run-time, WHILE selects conditional executing based on bool flag f.
0011FF  1                  ; If f is true (non-zero), WHILE continues execution of the true part thru to
0011FF  1                  ; REPEAT , which then branches back to BEGIN .  If f is false (zero), execution
0011FF  1                  ; skips to just after REPEAT , exiting the structure.
0011FF  1                  ;
0011FF  1                  ; At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the reserved
0011FF  1                  ; offset.  The stack values will be resolved by REPEAT .
0011FF  1                  ; https://forth-standard.org/standard/core/WHILE
0011FF  1  71 11 80     While:	JMPD If
001202  1               
001202  1               
001202  1  52 65 70 65   FHdr 'Repeat',ha_immediate ; ( addr n -- ) (compiling)
001206  1  61 74 46 11  
00120A  1  FF           
00120B  1                  ; Used withing a colon-definition in the form:
00120B  1                  ;	BEGIN ... WHILE ... REPEAT
00120B  1                  ; At run-time, REPEAT forces an unconditional branch back to just after
00120B  1                  ; the corresponding BEGIN .
00120B  1                  ;
00120B  1                  ; At compile-time, REPEAT compiles BRANCH and the offset from HERE to addr.
00120B  1                  ; n is used for pairing testing.
00120B  1                  ; https://forth-standard.org/standard/core/REPEAT
00120B  1  79 03 C4     Repeat:	JSRD ToR		; save While info
00120E  1  79 03 C4     	JSRD ToR
001211  1  7B D9        	JSRR Again		; compile branch to Begin
001213  1  79 03 BA     	JSRD RFrom		; restore While info
001216  1  79 03 BA     	JSRD RFrom
001219  1  73 90        	JMPR Then		; fixup While
00121B  1               
00121B  1               
00121B  1               	.if 0
00121B  1               
00121B  1               ;----------------------------------------------------------------------
00121B  1               ; Case
00121B  1               ;   9 Of ." JACK" EndOf
00121B  1               ;  10 Of ." QUEEN" EndOf
00121B  1               ;  11 Of ." KING" EndOf
00121B  1               ;  12 Of ." ACE" EndOf
00121B  1               ;       Dup 2 + .
00121B  1               ;  EndCase
00121B  1               
00121B  1               
00121B  1               	.if 0
00121B  1                FHdr 'Case',ha_Immediate ;  http://forth-standard.org/standard/core/CASE
00121B  1                  ; Interpretation: Interpretation semantics for this word are undefined.
00121B  1                  ; Compilation: ( C: -- case-sys )
00121B  1                  ;	Mark the start of the CASE. . .OF. . .ENDOF. . .ENDCASE structure. Append the run-time
00121B  1                  ;	semantics given below to the current definition.
00121B  1                  ; Run-time: ( -- )
00121B  1                  ;	continue execution.
00121B  1               Case:	LDAL Case
00121B  1               	STAX ZW,ModBMRB,0
00121B  1               	JMPD Zero
00121B  1               	.endif
00121B  1               
00121B  1               
00121B  1               	.if 0
00121B  1                FHdr '?Of',ha_Immediate ; accept flag
00121B  1               QOf:	JSRD Abort ;???
00121B  1               	lda #@x
00121B  1               	jsr CompileInlineA
00121B  1               	bra Of3
00121B  1               
00121B  1               @x:	PopAm
00121B  1               	tay
00121B  1               	bne @x4
00121B  1               	jmp Abort
00121B  1               @x4:	.word INL_End
00121B  1               	.endif
00121B  1               
00121B  1               
00121B  1                FHdr 'Of',ha_Immediate ;  http://forth-standard.org/standard/core/OF
00121B  1                  ; Interpretation: Interpretation semantics for this word are undefined.
00121B  1                  ; Compilation: ( C: -- of-sys )
00121B  1                  ;	Put of-sys onto the control flow stack. Append the run-time semantics given below to the
00121B  1                  ;	current definition. The semantics are incomplete until resolved by a consumer of of-sys
00121B  1                  ;	such as ENDOF.
00121B  1                  ; Run-time: ( x1 x2 -- | x1 )
00121B  1                  ;	If the two values on the stack are not equal, discard the top value and continue execution
00121B  1                  ;	at the location specified by the consumer of of-sys, e.g., following the next ENDOF.
00121B  1                  ;	Otherwise, discard both values and continue execution in line.
00121B  1               Of:	JSRD Abort ;???
00121B  1               	lda #OfX
00121B  1               	jsr CompileInlineA
00121B  1               Of3:	lda #Of
00121B  1               	jsr Mark2
00121B  1               	lda #$e8e8	; inx inx
00121B  1               	jmp CommaA
00121B  1               
00121B  1               OfX:	PopAm
00121B  1               	cmp 0,x
00121B  1               	bne *
00121B  1               	.word INL_End
00121B  1               
00121B  1               
00121B  1               	.if 0
00121B  1               
00121B  1                FHdr 'Of>',ha_Immediate
00121B  1               OfG:	lda #0 ;???	; (ble)
00121B  1               	JSRD Abort ;??? bra of2
00121B  1               
00121B  1               
00121B  1                FHdr 'Of>=',ha_Immediate
00121B  1               OfGe:	lda #0 ;???	; (blt)
00121B  1               	JSRD Abort ;??? bra of2
00121B  1               
00121B  1               
00121B  1                FHdr 'Of<',ha_Immediate
00121B  1               OfL:	lda #0 ;???	; (bge)
00121B  1               	JSRD Abort ;??? bra of2
00121B  1               
00121B  1               
00121B  1                FHdr 'Of<=',ha_Immediate
00121B  1               OfLe:	lda #0 ;???	; (bgt)
00121B  1               	JSRD Abort ;??? bra of2
00121B  1               
00121B  1               	.endif
00121B  1               
00121B  1               
00121B  1                FHdr 'EndOf',ha_Immediate ;  http://forth-standard.org/standard/core/ENDOF
00121B  1                  ; Interpretation: Interpretation semantics for this word are undefined.
00121B  1                  ; Compilation: ( C: case-sys1 of-sys -- case-sys2 )
00121B  1                  ;	Mark the end of the OF. . .ENDOF part of the CASE structure. The next location for a
00121B  1                  ;	transfer of control resolves the reference given by of-sys. Append the run-time semantics
00121B  1                  ;	given below to the current definition. Replace case-sys1 with case-sys2 on the controlflow
00121B  1                  ;	stack, to be resolved by ENDCASE.
00121B  1                  ; Run-time: ( -- )
00121B  1                  ;	continue execution at the location specified by the consumer of case-sys2.
00121B  1               EndOf:	JSRD Abort ;???
00121B  1               	lda 2,x
00121B  1               	cmp #Of
00121B  1               	bne @90
00121B  1               	lda 6,x
00121B  1               	cmp #Case
00121B  1               	bne @90
00121B  1               	lda 4,x
00121B  1               	ldy MPtr
00121B  1               	sty 4,x
00121B  1               	jsr JmpCommaA
00121B  1               
00121B  1               	lda MPtr	;fix the OF
00121B  1               	sec
00121B  1               	sbc 0,x		;  calc branch displacement
00121B  1               	cmp #$80	;  check range
00121B  1               	bcs @range
00121B  1               	dec 0,x
00121B  1               	sep #pm
00121B  1               	sta (0,x)
00121B  1               	rep #pm
00121B  1               	jmp DDrop
00121B  1               
00121B  1               ;	ldy 0,x		;fix the OF
00121B  1               ;	dey		;  short version in-range?
00121B  1               ;	dey
00121B  1               ;	dey
00121B  1               ;	sty @adr
00121B  1               ;	lda mp
00121B  1               ;	sec
00121B  1               ;	sbc @adr
00121B  1               ;	cmp #$80
00121B  1               ;	bcs @75
00121B  1               ;	dey		;  modify to short version
00121B  1               ;	dey
00121B  1               ;	sep #pm
00121B  1               ;	sta a:1,y	;    store displacement
00121B  1               ;	lda a:0,y	;    flip sense of branch
00121B  1               ;	eor #$20
00121B  1               ;	sta a:0,y
00121B  1               ;	lda #$89	;    pad with bit #
00121B  1               ;	sta a:2,y
00121B  1               ;	rep #pm
00121B  1               ;	lda #0
00121B  1               ;	sta a:3,y
00121B  1               ;	bra @79
00121B  1               ;
00121B  1               ;@75:	lda mp		; fix long version
00121B  1               ;	sta a:1,y
00121B  1               ;@79:	jmp DDrop
00121B  1               
00121B  1               @range:	jsr DotQuoteR
00121B  1               	.byte 12," Too large! "
00121B  1               @90:	jsr Abort
00121B  1               
00121B  1               
00121B  1                FHdr 'EndCase',ha_Immediate ;  http://forth-standard.org/standard/core/ENDCASE
00121B  1                  ; Interpretation: Interpretation semantics for this word are undefined.
00121B  1                  ; Compilation: ( C: case-sys -- )
00121B  1                  ;	Mark the end of the CASE. . .OF. . .ENDOF. . .ENDCASE structure. Use case-sys to resolve
00121B  1                  ;	the entire structure. Append the run-time semantics given below to the current definition.
00121B  1                  ; Run-time: ( x -- )
00121B  1                  ;	Discard the case selector x and continue execution.
00121B  1               EndCase:
00121B  1               	lda #$e8e8	; inx; inx  drop selector
00121B  1               	jsr CommaA
00121B  1               	lda 2,x
00121B  1               	cmp #Case
00121B  1               	bne @90
00121B  1               	ldy 0,x		;fix endof jmp list
00121B  1               	beq @19
00121B  1               @11:	lda a:1,y
00121B  1               	pha
00121B  1               	lda MPtr
00121B  1               	sta a:1,y
00121B  1               	ply
00121B  1               	bne @11
00121B  1               @19:	jmp DDrop
00121B  1               
00121B  1               @90:	jsr Abort
00121B  1               
00121B  1               	.endif
00121B  1               
00121B  1               
00121B  1  44 6F 42 12   FHdr 'Do',ha_immediate	; ( n1 n2 -- ) (execute)
00121F  1  0B           
001220  1               			; ( addr n -- ) (compile)
001220  1                  ; Occurs in a colon-definition in form:
001220  1                  ;	DO ... LOOP
001220  1                  ;	DO ... +LOOP
001220  1                  ; At run time, DO begins a sequence with repetitive execution controlled by a
001220  1                  ; loop limit n1 and an index with initial valie n2.  DO removes these from the
001220  1                  ; stack.  Upon reaching LOOP the index is incremented by one.  Until the new
001220  1                  ; index equals or exceeds the limit, execution loops back to just after DO ;
001220  1                  ; otherwise the loop parameters are discarded and execution continues ahead.
001220  1                  ; Both n1 and n2 are determined at run-time and may be the results of other
001220  1                  ; operations.  Within a loop 'I' will copy the current value of the index to
001220  1                  ; the stack.  See I Loop +LOOP LEAVE .
001220  1                  ; When compiling within the colon-definitions, DO compiles (DO) , leaves the
001220  1                  ; following addresss addr and n for later error checking.
001220  1                  ; https://forth-standard.org/standard/core/DO
001220  1  90 12 2C     Do:	LDAL PDo		; compile "jsr PDo"
001223  1  79 10 E2     	JSRD JsrCommaA
001226  1  79 0C 0C     	JSRD Here		; push addr
001229  1  71 0A 78     	JMPD Three		; push DO pairing code, & return
00122C  1               
00122C  1               PDo: ; runtime
00122C  1  71 03 CF     	JMPD TwoToR
00122F  1               ;	LDAX ZW,ModBRPB,0	; pop index
00122F  1               ;	LDBX ZW,ModBRPB,0	; pop limit
00122F  1               ;	STBX SW,ModBMRB,0	; push limit
00122F  1               ;	STAX SW,ModBMRB,0	; push index
00122F  1               ;	RSR			; return
00122F  1               
00122F  1               
00122F  1               	.if 0
00122F  1                FHdr '?DO',ha_immediate
00122F  1                  ; Interpretation:
00122F  1                  ;   Interpretation semantics for this word are undefined.
00122F  1                  ; Compilation:
00122F  1                  ;   ( C: -- do-sys )
00122F  1                  ;   Put do-sys onto the control-flow stack. Append the run-time semantics given below to the current definition.
00122F  1                  ;   The semantics are incomplete until resolved by a consumer of do-sys such as LOOP.
00122F  1                  ;
00122F  1                  ; Run-time:
00122F  1                  ;   ( n1 | u1 n2 | u2 -- ) ( R: -- loop-sys )
00122F  1                  ;   If n1 | u1 is equal to n2 | u2, continue execution at the location given by the consumer of do-sys.
00122F  1                  ;   Otherwise set up loop control parameters with index n2 | u2 and limit n1 | u1 and continue executing immediately following ?DO. Anything already on the return stack becomes unavailable until the loop control parameters are discarded. An ambiguous condition exists if n1 | u1 and n2 | u2 are not both of the same type.
00122F  1                  ; https://forth-standard.org/standard/core/qDO
00122F  1               	.endif
00122F  1               
00122F  1               
00122F  1  4C 65 61 76   FHdr 'Leave',0 ; ( -- )
001233  1  65 05 12 20  
001237  1                  ; Force termination of a DO-LOOP at the next opportunity by setting the loop limit
001237  1                  ; equal to the current value of the index.  The index itself remains unchanged, and
001237  1                  ; execution proceeds normally until LOOP or +LOOP is encountered.
001237  1                  ; https://forth-standard.org/standard/core/LEAVE
001237  1  95 A8 02     Leave:	LDAX SW,ModNBRB,2	; limit=index
00123A  1  BD           	STAA SW
00123B  1  09           	RSR			; return
00123C  1               
00123C  1               
00123C  1               	.if 0
00123C  1                FHdr 'Unloop',ha_immedate
00123C  1                  ; Interpretation:
00123C  1                  ;   Interpretation semantics for this word are undefined.
00123C  1                  ; Execution:
00123C  1                  ;   ( -- ) ( R: loop-sys -- )
00123C  1                  ;   Discard the loop-control parameters for the current nesting level.
00123C  1                  ;   An UNLOOP is required for each nesting level before the definition may be EXITed.
00123C  1                  ;   An ambiguous condition exists if the loop-control parameters are unavailable.
00123C  1               Unloop:	INR SW,4	; rdrop index & limit
00123C  1               	RSR
00123C  1               	.endif
00123C  1               
00123C  1               
00123C  1  49 01 12 37   FHdr 'I',0 ; ( -- n )
001240  1                  ; Used within a DO-LOOP to copy the loop index to the stack.
001240  1                  ; Other use is implementation dependent.
001240  1                  ; See R .
001240  1                  ; https://forth-standard.org/standard/core/I
001240  1  9D           I:	LDAA SW			; get 1st DO index
001241  1  B5 82        	STAX ZW,ModBMRB,0	; push it
001243  1  09           	RSR			; return
001244  1               
001244  1               
001244  1  4A 01 12 40   FHdr 'J',0 ; ( -- n )
001248  1                  ; Used within a DO-LOOP to copy the loop limit to the stack.
001248  1                  ; Other use is implementation dependent.
001248  1                  ; See I .
001248  1                  ; https://forth-standard.org/standard/core/J
001248  1  95 A8 04     J:	LDAX SW,ModNBRB,4	; get 2nd DO index
00124B  1  B5 82        	STAX ZW,ModBMRB,0	; push it
00124D  1  09           	RSR			; return
00124E  1               
00124E  1               
00124E  1  4C 6F 6F 70   FHdr 'Loop',ha_immediate; ( addr n -- ) (compiling)
001252  1  44 12 48     
001255  1                  ; Occurs in a colon-definition in form:
001255  1                  ;	DO ... LOOP
001255  1                  ; At run-time, LOOP selectively controls branching back to the corresponding
001255  1                  ; DO based on the loop index and limit.  The loop index is incremented by one
001255  1                  ; and compared to the limit.  The branch back to DO occurs until the index >= limit;
001255  1                  ; at than time, the parameters are discarded and execution continues ahead.
001255  1                  ;
001255  1                  ; At compile-time, uses addr to calculate an offset to DO .  n is used for error testing.
001255  1                  ; https://forth-standard.org/standard/core/LOOP
001255  1  90 00 03     Loop:	LDAL 3			; verify we're paired with a DO, & compiling
001258  1  79 0F 8C     	JSRD QPairsA
00125B  1               
00125B  1  90 12 66     	LDAL PLoop		; compile "jsr PLoop"
00125E  1  79 10 E2     Loop7:	JSRD JsrCommaA
001261  1  80 16        	LDABL $16		; compile "BM addr", & return
001263  1  71 11 3C     	JMPD BranchCommaA
001266  1               
001266  1               ;	FHdr '(Loop)',0 ; ( -- )  LOOP runtime
001266  1               PLoop:
001266  1  9D           	LDAA SW			; increment index
001267  1  38           	INA
001268  1  BD           	STAA SW
001269  1  D5 A8 02     	LDBX SW,ModNBRB,2	; signed compare to limit
00126C  1  59           	SAB
00126D  1  13 01        	BNF @Run2		; if overflow
00126F  1  3B           	IVA			;   correct sign
001270  1               @Run2:
001270  1  16 03        	BM @Run9		; if limit reached
001272  1  30 A3        	INR SW,4		;   rdrop index & limit
001274  1  3A           	CLA			;   clear neg flag to indicate fall thru
001275  1  09           @Run9:	RSR			; returns negative flag: clear=fall thru, set=loop back
001276  1               
001276  1               
001276  1  2B 4C 6F 6F   FHdr '+Loop',ha_immediate ; (      n1 -- ) (run)
00127A  1  70 45 12 55  
00127E  1               			   ; ( addr n2 -- ) (compile)
00127E  1                  ; Used in a colon-definition in the form:
00127E  1                  ;	DO  ...  n1 +LOOP
00127E  1                  ; At run-time, +LOOP selectively controls branching back to the corresponding
00127E  1                  ; DO based on n1, the loop index and the loop limit.  The signed increment
00127E  1                  ; n1 is added to the index and the total compared to the limit.  The branch
00127E  1                  ; back to DO occurs until the new index is >= the limit (n1>0), or until the
00127E  1                  ; new index is <= the limit (n1<0).  Upon exiting the loop, the parameters
00127E  1                  ; are discarded and execution continues ahead.
00127E  1                  ;
00127E  1                  ; At compile time, +LOOP compiles the run-time word (+LOOP) and the branch
00127E  1                  ; offset from HERE to the address left on the stack by DO.  n2 is used for
00127E  1                  ; compile time error checking.
00127E  1                  ; https://forth-standard.org/standard/core/PlusLOOP
00127E  1               PlusLoop:
00127E  1  90 00 03     	LDAL 3		; verify we're paired with a DO , & compiling
001281  1  79 0F 8C     	JSRD QPairsA
001284  1  90 12 89     	LDAL PPlusLoop	; compile "jsr PPlusLoop"
001287  1  73 D5        	JMPR Loop7	; & finish
001289  1               
001289  1               
001289  1               ; FHdr '(+Loop)',0 ; ( n -- )  The run-time procecdure compiled by +LOOP,
001289  1               		; which increments the loop index by n and tests for loop completion.
001289  1               PPlusLoop:
001289  1  95 81        	LDAX ZW,ModBRPB,0	; pop n
00128B  1  5C           	XAY
00128C  1  DD           	LDBA SW			; add n to index
00128D  1  58           	AAB
00128E  1  FD           	STBA SW
00128F  1  12 0C        	BF @Quit		; if overflow, we're done for sure
001291  1  95 A8 02     	LDAX SW,ModNBRB,2	; compare index with limit
001294  1  51 20        	SUB AW,BW
001296  1  13 01        	BNF @3			; overflow?
001298  1  3B           	IVA			;   correct overflowed sign
001299  1  54 60        @3:	ORE AW,YW		; take into account the sign of n
00129B  1  16 03        	BM @9			; if limit reached
00129D  1  30 A3        @Quit:	INR SW,4		;   rdrop index & limit
00129F  1  3A           	CLA			;   clear negative flag
0012A0  1  09           @9:	RSR			; returns negative flag: clear=fall thru, set=loop back
0012A1  1               
0012A1  1               
0012A1  1  43 72 65 61   FHdr 'Create',0 ;
0012A5  1  74 65 06 12  
0012A9  1  7E           
0012AA  1                  ; A defining word used in the form:
0012AA  1                  ;	CREATE cccc
0012AA  1                  ; by such words as CODE and CONSTANT to create a dictionary header for a Forth
0012AA  1                  ; definition.  The code field contains the address of the words parameter field.
0012AA  1                  ; The new word is created in the CURRENT vocabulary.
0012AA  1                  ; https://forth-standard.org/standard/core/CREATE
0012AA  1  79 12 C2     Create:	JSRD HeaderComma	; compile word header
0012AD  1  90 12 B3     	LDAL @Run		; compile "jsr @Run", & return
0012B0  1  71 10 E2     	JMPD JsrCommaA
0012B3  1               
0012B3  1  6D 82        @Run:	STXX ZW,ModBMRB,0	; push pfa
0012B5  1  65 A1        	LDXX SW,ModBRPB,0	; return to my caller's caller
0012B7  1  09           	RSR
0012B8  1               
0012B8  1               
0012B8  1  48 65 61 64   FHdr 'Header,',0 ; ( "name" -- )  compile a word header
0012BC  1  65 72 2C 07  
0012C0  1  12 AA        
0012C2  1                  ; name is next word in input buffer.
0012C2  1               HeaderComma:
0012C2  1  79 15 1A     	JSRD DFind		; check for name redefinition
0012C5  1               				; DFind also stores the name at HERE, including a preceding length
0012C5  1               				; byte that we don't use, but haven't discarded here yet.
0012C5  1  95 81        	LDAX ZW,ModBRPB,0	; found an existing word of the same name?
0012C7  1  14 0E        	BZ @2163
0012C9  1  30 81        	INR ZW,2		;   drop flags
0012CB  1               ;	JSRD CFA		;   CFA & NFA are the same in this implementation
0012CB  1  79 15 AC     	JSRD IdDot		;   type name
0012CE  1  90 00 04     	LDAL Err_IsntUnique	;   type message
0012D1  1  79 1A C4     	JSRD MessageA
0012D4  1  79 0D 01     	JSRD Space		;   type space
0012D7  1               @2163:
0012D7  1  3A           	CLA			; get name length
0012D8  1  82 70 70     	LDABI VDP
0012DB  1  C0 20        	LDBBL ha_length+1	; name too long?
0012DD  1  49           	SABB
0012DE  1  10 18        	BL @NameTooLong
0012E0  1  B5 A2        	STAX SW,ModBMRB,0	; save name length on return stack
0012E2  1               
0012E2  1  38           	INA			;   ???include the unused leading string char count byte
0012E3  1  79 0F D3     	JSRD AllotA		; skip over stored name
0012E6  1               
0012E6  1  95 A1        	LDAX SW,ModBRPB,0	; get original length
0012E8  1  79 11 1B     	JSRD CCommaA		; store flags & length
0012EB  1               
0012EB  1  92 70 80     	LDAI VCurrent		; store dictionary link
0012EE  1  79 11 01     	JSRD CommaA
0012F1  1  91 70 70     	LDAD VDP		; link into current vocabulary
0012F4  1  B2 70 80     	STAI VCurrent
0012F7  1               
0012F7  1  09           	RSR			; return
0012F8  1               
0012F8  1               @NameTooLong:
0012F8  1  79 17 8D     	JSRD Abort
0012FB  1               
0012FB  1               
0012FB  1  49 6E 6C 69   FHdr 'Inline',0 ; ( -- )
0012FF  1  6E 65 06 12  
001303  1  C2           
001304  1                  ; Mark the most recently made definition so that when encountered at compile time,
001304  1                  ; it will be copied inline instead of JSRd to.
001304  1               Inline:
001304  1  79 13 AE     	JSRD Exit		; compile 2nd RSR as an end-of-word marker
001307  1  80 80        	LDABL ha_inline
001309  1  73 1B        	JMPR XorFlags
00130B  1               
00130B  1               
00130B  1  49 6D 6D 65   FHdr 'Immediate',0 ; ( -- )
00130F  1  64 69 61 74  
001313  1  65 09 13 04  
001317  1                  ; Mark the most recently made definition so that when encountered at compile time,
001317  1                  ; it will be executed rather than being compiled.  i.e. the precedence bit in its
001317  1                  ; header is set.  This method allows definitions to handle unusual compiling
001317  1                  ; situations, rather than build them into the fundamental compiler.  The user may
001317  1                  ; force compilation of an immediate definition by preceding it with [COMPILE] .
001317  1                  ; https://forth-standard.org/standard/core/IMMEDIATE
001317  1               Immediate:
001317  1  80 40        	LDABL ha_immediate
001319  1  73 0B        	JMPR XorFlags
00131B  1               
00131B  1               
00131B  1  53 6D 75 64   FHdr 'Smudge',0 ; ( -- )
00131F  1  67 65 06 13  
001323  1  17           
001324  1                  ; Used during word definition to toggle the "smudge bit" in a definitions' name
001324  1                  ; field.  This prevents an uncompleted definition from being found during
001324  1                  ; dictionary searches, until compiling is completed without error.
001324  1  80 20        Smudge:	LDABL ha_smudge
001326  1               XorFlags:
001326  1  5C           	XAY			; Y=bits
001327  1  D2 70 80     	LDBI VCurrent		; B=word ptr
00132A  1  85 28 FD     	LDABX BW,ModNBRB,$fd	; xor flags
00132D  1  44 71        	OREB AL,YL
00132F  1  A5 28 FD     	STABX BW,ModNBRB,$fd
001332  1  09           	RSR
001333  1               
001333  1               
001333  1  56 61 72 69   FHdr 'Variable',0 ; ( "name" n -- )
001337  1  61 62 6C 65  
00133B  1  08 13 24     
00133E  1                  ; A defining word used in the form:
00133E  1                  ;	n VARIABLE cccc
00133E  1                  ; When VARIABLE is executed, it creates the definition cccc with its parameter field
00133E  1                  ; initialized to n.  When cccc is later executed, the address of it's parameter field
00133E  1                  ; (containing n) is left on the stack, so that a fetch or store may access this location.
00133E  1                  ; https://forth-standard.org/standard/core/VARIABLE
00133E  1               Variable:
00133E  1  79 12 AA     	JSRD Create	; create a word that pushes it's parameter address
001341  1  3A           Varia2:	CLA
001342  1  71 11 01     	JMPD CommaA	; alloc data space & store initial value
001345  1               
001345  1               
001345  1  32 56 61 72   FHdr '2Variable',0 ; ( "name" n -- )
001349  1  69 61 62 6C  
00134D  1  65 09 13 3E  
001351  1                  ; A defining word used in the form:
001351  1                  ;	d 2VARIABLE cccc
001351  1                  ; When 2VARIABLE is executed, it creates the definition cccc with its parameter field
001351  1                  ; initialized to d.  When cccc is later executed, the address of it's parameter field
001351  1                  ; (containing d) is left on the stack, so that a fetch or store may access this location.
001351  1                  ; https://forth-standard.org/standard/double/TwoVARIABLE
001351  1               TwoVariable:
001351  1  7B EB        	JSRR Variable		; header & 1st 2 bytes
001353  1  73 EC        	JMPR Varia2		; 2nd 2 bytes
001355  1               
001355  1               
001355  1  43 6F 6E 73   FHdr 'Constant',0 ; ( n "name" -- )
001359  1  74 61 6E 74  
00135D  1  08 13 51     
001360  1                  ; A definining word used in the form:
001360  1                  ;	n CONSTANT cccc
001360  1                  ; to create word cccc.
001360  1                  ; When cccc is lated executed, it will push the value of n to the stack.
001360  1                  ; https://forth-standard.org/standard/core/CONSTANT
001360  1               Constant:
001360  1  79 12 C2     	JSRD HeaderComma	; compile a word header
001363  1  79 15 DC     	JSRD LitComma		; compile "lda #n", "sta (-z)"
001366  1  71 13 AE     	JMPD Exit		; compile "rsr", & return
001369  1               
001369  1               
001369  1  32 43 6F 6E   FHdr '2Constant',0 ; ( d "name" -- )
00136D  1  73 74 61 6E  
001371  1  74 09 13 60  
001375  1                  ; A definining word used in the form:
001375  1                  ;	d 2CONSTANT cccc
001375  1                  ; to create word cccc.
001375  1                  ; When cccc is lated executed, it will push the value of d to the stack.
001375  1                  ; https://forth-standard.org/standard/double/TwoCONSTANT
001375  1               TwoConstant:
001375  1  79 12 C2     	JSRD HeaderComma	; compile a word header
001378  1  79 11 22     	JSRD LdbaComma		; compile "lda #d.lo; ldb #d.hi
00137B  1  90 02 F9     	LDAL PushBA 		; compile "JMPD PushBA"
00137E  1  71 10 F5     	JMPD JmpCommaA
001381  1               
001381  1               
001381  1               	.if 0
001381  1               
001381  1                FHdr 'Value',0
001381  1                  ; https://forth-standard.org/standard/core/VALUE
001381  1               Value:	JMPR Constant
001381  1               
001381  1               
001381  1                FHdr '2Value',0
001381  1                  ; https://forth-standard.org/standard/double/TwoVALUE
001381  1               TwoValue:
001381  1               	JMPR TwoConstant
001381  1               
001381  1               
001381  1                FHdr 'To',0
001381  1                  ; Interpretation:
001381  1                  ;   ( i * x "<spaces>name" -- )
001381  1                  ;   Skip leading spaces and parse name delimited by a space. Perform the "TO name run-time" semantics given in the definition for the defining word of name. An ambiguous condition exists if name was not defined by a word with "TO name run-time" semantics.
001381  1                  ;
001381  1                  ; Compilation:
001381  1                  ; ( "<spaces>name" -- )
001381  1                  ;   Skip leading spaces and parse name delimited by a space. Append the "TO name run-time" semantics given
001381  1                  ;   in the definition for the defining word of name to the current definition.
001381  1                  ;   An ambiguous condition exists if name was not defined by a word with "TO name run-time" semantics.
001381  1                  ; https://forth-standard.org/standard/core/TO
001381  1               To:	JSRD Abort ;???
001381  1               
001381  1               	.endif
001381  1               
001381  1               
001381  1  3A 41 13 75   FHdr ':',ha_immediate ; ( "name" -- )  Start compiling a word
001385  1                  ; Used in the form:
001385  1                  ;	: ccc  ...  ;
001385  1                  ; Creates a dictionary entry defining ccc as equivalent to the following
001385  1                  ; sequence of Forth word definitions '...' until the next ';' or ';CODE'.
001385  1                  ; The compiling process is done by the text interpreter as long as STATE is
001385  1                  ; non-zero.  Other details are that the CONTEXT vocabulary is set to the CURRENT
001385  1                  ; vocabulary and that WORDS with the precedence bit set (P) are executed
001385  1                  ; rather that being compiled.
001385  1                  ; https://forth-standard.org/standard/core/Colon
001385  1  79 12 C2     Colon:	JSRD HeaderComma	; compile word header
001388  1  79 13 24     	JSRD Smudge		; smudge the word so we won't find it until done
00138B  1  79 0F 78     Colon3:	JSRD QExec		; verify we're not already compiling
00138E  1  79 0F 9D     	JSRD SCSP		; save param stack index to compare later
001391  1  91 70 80     	LDAD VCurrent		; Context vocabulary = current vocabulary
001394  1  B1 70 7E     	STAD VContext
001397  1  73 27        	JMPR RBracket		; set compile mode, & return
001399  1               
001399  1               
001399  1  3B 41 13 85   FHdr ';',ha_immediate ; ( -- )  Terminates a colon-definition and stop further compilation.
00139D  1                  ; https://forth-standard.org/standard/core/Semi
00139D  1  79 0F AA     Semi:	JSRD QCSP		; check that param stack index = when we started compiling
0013A0  1  7B 0C        	JSRR Exit		; compile "rsr"
0013A2  1  79 13 24     	JSRD Smudge		; Un-smudge the word header
0013A5  1  73 10        	JMPR LBracket		; set interpret mode, & return
0013A7  1               
0013A7  1               
0013A7  1               	.if 0
0013A7  1                FHdr ':Noname',0 ; ( C: -- colon-sys ) ( S: -- xt )
0013A7  1                  ; Create an execution token xt, enter compilation state and start the current definition, producing colon-sys.
0013A7  1                  ; Append the initiation semantics given below to the current definition.
0013A7  1                  ;
0013A7  1                  ; The execution semantics of xt will be determined by the words compiled into the body of the definition.
0013A7  1                  ; This definition can be executed later by using xt EXECUTE.
0013A7  1                  ;
0013A7  1                  ; If the control-flow stack is implemented using the data stack, colon-sys shall be the topmost item on the data stack.
0013A7  1                  ; See 3.2.3.2 Control-flow stack.
0013A7  1               CNoname:
0013A7  1               	LDABL ha_smudge
0013A7  1               	JSRD CCommaA		; compile flags & length
0013A7  1               	CLA
0013A7  1               	JSRD CommaA		; compile fake dictionary link
0013A7  1               	JSRD Here		; push xt
0013A7  1               	JMPR Colon3
0013A7  1               	.endif
0013A7  1               
0013A7  1               
0013A7  1  45 78 69 74   FHdr 'Exit',ha_immediate ; ( -- ) https://forth-standard.org/standard/core/EXIT
0013AB  1  44 13 9D     
0013AE  1                  ; Interpretation: Interpretation semantics for this word are undefined.
0013AE  1                  ; Execution: ( -- ) ( R: nest-sys -- )
0013AE  1                  ;	Return control to the calling definition specified by nest-sys. Before executing EXIT
0013AE  1                  ;	within a do-loop, a program shall discard the loop-control parameters by executing UNLOOP.
0013AE  1  80 09        Exit:	LDABL $09		; compile a RSR ( replaces ;S call )
0013B0  1  71 11 1B     	JMPD CCommaA
0013B3  1               
0013B3  1               
0013B3  1  5B 41 13 AE   FHdr '[',ha_immediate ; ( -- )  Suspend compilation.
0013B7  1                  ; Used in a colon-definition in form:
0013B7  1                  ;	: xxx  [ words ]  more ;
0013B7  1                  ; The words after [ are executed, not compiled.  This allows
0013B7  1                  ; calculation or compilation exceptions before resuming compilation with ] .
0013B7  1                  ; See LITERAL ]
0013B7  1                  ; https://forth-standard.org/standard/core/Bracket
0013B7  1               LBracket:
0013B7  1  3A           	CLA
0013B8  1  B1 70 82     LBrac3:	STAD VState	; set state to interpreting
0013BB  1  09           	RSR		; return
0013BC  1               
0013BC  1               
0013BC  1  5D 01 13 B7   FHdr ']',0 ; ( -- )  Resume compilation, to the completion of a colon-definition.
0013C0  1                  ; See [
0013C0  1               RBracket:
0013C0  1  32 01        	CLR AW,1	; set state to compiling (store non-zero)
0013C2  1  73 F4        	JMPR LBrac3
0013C4  1               
0013C4  1               
0013C4  1               	.if 0
0013C4  1                FHdr 'Synonym',0 ; ( "<spaces>newname" "<spaces>oldname" -- )
0013C4  1                  ; For both strings skip leading space delimiters. Parse newname and oldname delimited by a space.
0013C4  1                  ; Create a definition for newname with the semantics defined below.
0013C4  1                  ; Newname may be the same as oldname; when looking up oldname, newname shall not be found.
0013C4  1                  ;
0013C4  1                  ; An ambiguous conditions exists if oldname can not be found or IMMEDIATE is applied to newname.
0013C4  1                  ; https://forth-standard.org/standard/tools/SYNONYM
0013C4  1               Synonym:
0013C4  1               	JSRD Colon	; start a new word
0013C4  1               	JSRD Tick	; look up old word
0013C4  1               	LDABL $71	; build JMPD
0013C4  1               	JSRD CCommaA
0013C4  1               	JSRD Comma
0013C4  1               	JMPD Semi	; end new word
0013C4  1               	.endif
0013C4  1               
0013C4  1               
0013C4  1  3B 43 6F 64   FHdr ';Code',ha_immediate
0013C8  1  65 45 13 C0  
0013CC  1                  ; Used in the form:
0013CC  1                  ;	: ccc  ....  ;CODE
0013CC  1                  ;		assembly mnemonics
0013CC  1                  ; Stop compilation and terminate a new defining word cccc by compiling (;CODE) .
0013CC  1                  ; Set the CONTEXT vocabulary to ASSEMBLER, assembling to machine code the following
0013CC  1                  ; menmonics.
0013CC  1                  ;
0013CC  1                  ; When cccc later executes in the form:
0013CC  1                  ;	cccc nnnn
0013CC  1                  ; the word nnnn will be created with its execution procedure given by the machine
0013CC  1                  ; code following cccc.  That is, when nnnn is executed, it does so by jumping to the
0013CC  1                  ; code after nnnn.  An existing defining word must exist in cccc prior to ;CODE .
0013CC  1                  ; https://forth-standard.org/standard/tools/SemiCODE
0013CC  1  79 0F AA     SCode:	JSRD QCSP	; make sure param stack is the same depth as when compile started
0013CF  1  90 13 DA     	LDAL PSCode	; compile "jsr PSCode"
0013D2  1  79 10 E2     	JSRD JsrCommaA
0013D5  1               
0013D5  1  7B E0        	JSRR LBracket	; state=interpret
0013D7  1  71 13 24     	JMPD Smudge	; un-smudge the word header
0013DA  1               
0013DA  1               
0013DA  1               ; FHdr '(;Code)',0 ;
0013DA  1                  ; The run-time procedure compiled by ;CODE, that rewrites the code field of the
0013DA  1                  ; most recently defined word to point to the following machine code sequence.
0013DA  1                  ; See ;CODE.
0013DA  1  D2 70 80     PSCode: LDBI VCurrent		; B=ptr to current word
0013DD  1  6D 28 01     	STXX BW,ModNBRB,1	; store in jsr operand of current word
0013E0  1  65 A1        	LDXX SW,ModBRPB,0	; pop my caller's addr
0013E2  1  09           	RSR
0013E3  1               
0013E3  1               
0013E3  1               	.if 0
0013E3  1                FHdr '<Builds',0 ;
0013E3  1                  ; Used within a colon-definition:
0013E3  1                  ;	: cccc <BUILDS ...
0013E3  1                  ;		DOES> ... ;
0013E3  1                  ; Each time cccc is executed, <BUILDS defines a new word with a high-level
0013E3  1                  ; execution procedure.  Executing cccc in the form:
0013E3  1                  ;	cccc nnnn
0013E3  1                  ; uses <BUILDS to create a dictionary entry for nnnn with a call to the DOES>
0013E3  1                  ; part for nnnn.  When nnnn is later executed, it has the address of its
0013E3  1                  ; parameter area on the stack and executes the words after DOES> in cccc.
0013E3  1                  ; <BUILDS and DOES> allow run-time procedures to be written in high-level
0013E3  1                  ; rather than in assembler code (as required by ;CODE ).
0013E3  1               Builds:	JMPD Create		; start a word with jsr, "jsr" address will be patched later
0013E3  1               	.endif
0013E3  1               
0013E3  1               
0013E3  1  44 6F 65 73   FHdr 'Does>',ha_immediate ;
0013E7  1  3E 45 13 CC  
0013EB  1                  ; A word which defines the run-time action withing a high-level defining word.
0013EB  1                  ; DOES> alters the code field and first parameter of the new word to execute
0013EB  1                  ; the sequence of compiled word addresses following DOES> .
0013EB  1                  ; Used in combination with <BUILDS . When the DOES> part executes it begins with the
0013EB  1                  ; address of the first parameter of the new word on the stack.
0013EB  1                  ; This allows interpretation using this area or its contents.
0013EB  1                  ; Typical uses include the Forth assembler, multidimensional arrays, and compiler generation.
0013EB  1                  ; https://forth-standard.org/standard/core/DOES
0013EB  1  90 13 DA     DoesG:	LDAL PSCode
0013EE  1  79 10 E2     	JSRD JsrCommaA
0013F1  1               
0013F1  1  90 6D 82     	LDAL $6D82	; compile "STXX ZW,ModBMRB,0" to push PFA
0013F4  1  79 11 01     	JSRD CommaA
0013F7  1  90 65 A1     	LDAL $65A1	; compile "LDXX SW,ModBRPB,0" to fix return stack
0013FA  1  71 11 01     	JMPD CommaA
0013FD  1               
0013FD  1               
0013FD  1  2E 28 42 13   FHdr '.(',ha_immediate ;  https://forth-standard.org/standard/core/Dotp
001401  1  EB           
001402  1                  ; Compilation:
001402  1                  ;   Perform the execution semantics given below.
001402  1                  ; Execution:
001402  1                  ;   ( "ccc<paren>" -- )
001402  1                  ; Parse and display ccc delimited by ) (right parenthesis). .( is an immediate word.
001402  1  D0 00 29     DotP:	LDBL ')'		; push ')'
001405  1  F5 82        DotP3:	STBX ZW,ModBMRB,0
001407  1  79 09 2E     	JSRD Word		; get counted string
00140A  1  79 0C 0C     	JSRD Here		; push counted string addr
00140D  1  79 08 63     	JSRD Count		; convert to addr & len
001410  1  71 0D 21     	JMPD Type		; type it & return
001413  1               
001413  1               
001413  1  2E 22 42 14   FHdr '."',ha_immediate ;
001417  1  02           
001418  1                  ; Used in the form
001418  1                  ;	." cccc"
001418  1                  ; Compiles an in-line string cccc (delimited by the trailing ") with an
001418  1                  ; execution procedure to transmit the text to the selected output device.
001418  1                  ; If execute outside a definition, ." will immediately print the text until
001418  1                  ; the final ".  The maximum number of chars may be an installation depended
001418  1                  ; value.  See (.") .
001418  1                  ; https://forth-standard.org/standard/core/Dotq
001418  1  D0 00 22     DotQ:	LDBL '"'
00141B  1  91 70 82     	LDAD VState		; interpreting?
00141E  1  14 E5        	BZ DotP3
001420  1               
001420  1  90 14 39     	LDAL PDotQuote		; compile "jsr PDotQuote"
001423  1  79 10 E2     	JSRD JsrCommaA
001426  1  73 00        	JMPR CountedStringComma
001428  1               
001428  1               
001428  1               CountedStringComma: ; compile a counted string
001428  1  90 00 22     	LDAL '"'		; push '"'
00142B  1  B5 82        	STAX ZW,ModBMRB,0
00142D  1  79 09 2E     	JSRD Word		; get counted string
001430  1  D1 70 70     	LDBD VDP		; alloc the space the string is using, & return
001433  1  3A           	CLA
001434  1  89           	LDABA BW
001435  1  38           	INA
001436  1  71 0F D3     	JMPD AllotA
001439  1               
001439  1               
001439  1               ; FHdr '(.")',0 ; ( -- )
001439  1                  ; The run-time procedure, compiled by ." which transmits the following
001439  1                  ; in-line text to the selected output device.  See ."
001439  1               PDotQuote:
001439  1  3A           	CLA		; get length
00143A  1  85 41        	LDABX XW,ModBRPB,0
00143C  1  6D 82        	STXX ZW,ModBMRB,0 ; push adr for TYPE
00143E  1  B5 82        	STAX ZW,ModBMRB,0 ; push length for TYPE
001440  1  50 04        	ADD XW,AW	; fix my return addr
001442  1  71 0D 21     	JMPD Type	; Type & return
001445  1               
001445  1               
001445  1               	.if 0
001445  1                FHdr 'SLiteral',0
001445  1                  ; Interpretation:
001445  1                  ;    Interpretation semantics for this word are undefined.
001445  1                  ; Compilation:
001445  1                  ;   ( c-addr1 u -- )
001445  1                  ;   Append the run-time semantics given below to the current definition.
001445  1                  ;
001445  1                  ; Run-time:
001445  1                  ;   ( -- c-addr2 u )
001445  1                  ;   Return c-addr2 u describing a string consisting of the characters specified by c-addr1 u
001445  1                  ;   during compilation. A program shall not alter the returned string.
001445  1                  ; https://forth-standard.org/standard/string/SLITERAL
001445  1               SLiteral:
001445  1               	JSRD Abort ;???
001445  1               	.endif
001445  1               
001445  1               
001445  1  53 22 42 14   FHdr 'S"',ha_immediate ; s-quote https://forth-standard.org/standard/core/Seq
001449  1  18           
00144A  1                  ; Modified to append a null to the string, so it's also zero-terminated.
00144A  1                  ; Interpretation: ( "string" -- addr len )
00144A  1                  ; Compilation: ( ccc(quote) -- )
00144A  1                  ;	Parse ccc delimited by " (double-quote). Append the run-time semantics given below to
00144A  1                  ;	the current definition.
00144A  1                  ; Run-time: ( -- c-addr u )
00144A  1                  ;	Return c-addr and u describing a string consisting of the characters ccc. A program shall
00144A  1                  ;	not alter the returned string.
00144A  1  91 70 82     SQuote:	LDAD VState		; compiling?
00144D  1  14 06        	BZ @19
00144F  1  90 14 77     	LDAL SQuoteR		;   compile JSRD
001452  1  79 10 E2     	JSRD JsrCommaA
001455  1               @19:
001455  1               
001455  1  90 00 22     	LDAL '"'		; get the counted string to VDP
001458  1  B5 82        	STAX ZW,ModBMRB,0
00145A  1  79 09 2E     	JSRD Word
00145D  1  D1 70 70     	LDBD VDP
001460  1  3A           	CLA
001461  1  85 21        	LDABX BW,ModBRPB,0
001463  1  F5 82        	STBX ZW,ModBMRB,0	; push addr
001465  1  B5 82        	STAX ZW,ModBMRB,0	; push length
001467  1  38           	INA			; allocate the space, & return
001468  1  79 0F D3     	JSRD AllotA
00146B  1  3A           	CLA			; append a null
00146C  1  79 11 1B     	JSRD CCommaA
00146F  1               
00146F  1  91 70 82     	LDAD VState		; compiling?
001472  1  14 02        	BZ @39
001474  1  30 83        	INR ZW,4		;   drop addr & length
001476  1               @39:
001476  1  09           	RSR
001477  1               
001477  1               
001477  1               ; FHdr '(S")',0 ; ( -- c-addr u )	run-time code for S"
001477  1  3A           SQuoteR: CLA			; get length byte
001478  1  85 41        	LDABX XW,ModBRPB,0
00147A  1  6D 82        	STXX ZW,ModBMRB,0	; push addr
00147C  1  B5 82        	STAX ZW,ModBMRB,0	; push length
00147E  1  50 04        	ADD XW,AW		; advance over the string data
001480  1  3E           	INXC			; also skip the trailing null
001481  1  09           	RSR
001482  1               
001482  1               
001482  1               	.if 0
001482  1                FHdr 'S\"',0
001482  1                  ; Interpretation:
001482  1                  ;   Interpretation semantics for this word are undefined.
001482  1                  ; Compilation:
001482  1                  ;   ( "ccc<quote>" -- )
001482  1                  ;   Parse ccc delimited by " (double-quote), using the translation rules below. Append the run-time semantics
001482  1                  ;   given below to the current definition.
001482  1               	JSRD Abort ;???
001482  1               	.endif
001482  1               
001482  1               
001482  1               	.if 0
001482  1                FHdr 'Environment?',0 ; ( c-addr u -- false | i * x true )
001482  1               EnvironmentQ:
001482  1               	JSRD Abort ;???
001482  1               	.endif
001482  1               
001482  1               
001482  1  28 46 69 6E   FHdr '(Find)',0 ; ( addr1 addr2 -- cfa b true ) (found)
001486  1  64 29 06 14  
00148A  1  4A           
00148B  1               		; ( addr1 addr2 --      false ) (notfound)
00148B  1                  ; Searches the dictionary starting at the code address addr2,
00148B  1                  ; matching to the counted string at addr1.
00148B  1                  ; Returns name address (= code address), length byte of name field and boolean true for a good match.
00148B  1                  ; If not match is found, only a boolean false is left.
00148B  1               PFind:
00148B  1  6D A2        	STXX SW,ModBMRB,0	; push X
00148D  1               @addr2 = 0	; current word addr; must be offset 0
00148D  1               @charlen = 2
00148D  1               @nameadr = 4	; * last char of pattern name
00148D  1               @len	= 6
00148D  1               @zw	= 8
00148D  1  55 80        	XFR AW,ZW
00148F  1  B5 A2        	STAX SW,ModBMRB,0	; @zw
001491  1  65 88 02     	LDXX ZW,ModNBRB,2	; get addr1
001494  1  3A           	CLA			; get length
001495  1  85 41        	LDABX XW,ModBRPB,0
001497  1  B5 A2        	STAX SW,ModBMRB,0	; @len
001499  1  5D           	XAB
00149A  1  50 42        	ADD BW,XW
00149C  1  F5 A2        	STBX SW,ModBMRB,0	; @nameadr
00149E  1  C5 28 FF     	LDBBX BW,ModNBRB,$ff	; get last char of name
0014A1  1  45 30        	XFRB AH,BL
0014A3  1  B5 A2        	STAX SW,ModBMRB,0	; @charlen
0014A5  1  55 80        	XFR AW,ZW		; @addr2
0014A7  1  30 01        	INR AW,2
0014A9  1  B5 A2        	STAX SW,ModBMRB,0
0014AB  1               
0014AB  1  65 A0        @21:	LDXX SW,ModBRB,@addr2	; reload word ptr
0014AD  1  95 A8 02     	LDAX SW,ModNBRB,@charlen ; reload constant regs
0014B0  1  5E           	XAZ
0014B1  1  90 DF 3F     	LDAL $df*$100+ha_length+ha_smudge
0014B4  1  65 48 FE     @23:	LDXX XW,ModNBRB,$fe	; follow dictionary link to next word
0014B7  1  14 4D        	BZ @notfound
0014B9  1  D5 48 FC     	LDBX XW,ModNBRB,$fc	; check last char & length
0014BC  1  54 82        	ORE BW,ZW		;   saved @charlen
0014BE  1  5A           	NAB			;   saved bitmask
0014BF  1  15 F3        	BNZ @23
0014C1  1  6D A0        	STXX SW,ModBRB,@addr2	; save word ptr
0014C3  1               
0014C3  1  31 42        	DCR XW,3		; X=1 + end of name in word
0014C5  1  95 A8 04     	LDAX SW,ModNBRB,@nameadr ; Y=1 + end of name pattern
0014C8  1  5C           	XAY
0014C9  1  95 A8 06     	LDAX SW,ModNBRB,@len	; Z=# chars in name
0014CC  1  5E           	XAZ
0014CD  1  80 DF        	LDABL $df
0014CF  1  45 18        	XFRB ZH,AL
0014D1  1               @32:				; for each char
0014D1  1  21 90        	DCRB ZL			;   decrement length
0014D3  1  16 1A        	BM @found
0014D5  1  85 42        	LDABX XW,ModBMRB,0	;   get name char
0014D7  1  C5 62        	LDBBX YW,ModBMRB,0	;   get pattern char
0014D9  1  44 13        	OREB BL,AL		;   compare for exact match
0014DB  1  14 F4        	BZ @32
0014DD  1  42 83        	ANDB BL,ZH		;   just a case mismatch?
0014DF  1  15 CA        	BNZ @21
0014E1  1  42 81        	ANDB AL,ZH		;   cvt char to uppercase
0014E3  1  C0 41        	LDBBL 'A'		;   >='A'
0014E5  1  49           	SABB
0014E6  1  11 C3        	BNL @21
0014E8  1  C0 5B        	LDBBL 'Z'+1		;   <='Z'
0014EA  1  49           	SABB
0014EB  1  11 E4        	BNL @32
0014ED  1  73 BC        	JMPR @21
0014EF  1               
0014EF  1               @found:
0014EF  1  65 A0        	LDXX SW,ModBRB,@addr2	; get addr2
0014F1  1  30 A7        	INR SW,@zw		; rdrop the work area
0014F3  1  95 A1        	LDAX SW,ModBRPB,0	; restore ZW
0014F5  1  5E           	XAZ
0014F6  1  6D 88 02     	STXX ZW,ModNBRB,2	; save cfa
0014F9  1  3A           	CLA			; save b
0014FA  1  85 48 FD     	LDABX XW,ModNBRB,$fd
0014FD  1  BC           	STAA ZW
0014FE  1  90 00 01     	LDAL 1			; push flag
001501  1  B5 82        	STAX ZW,ModBMRB,0
001503  1  65 A1        	LDXX SW,ModBRPB,0	; pop X
001505  1  09           	RSR
001506  1               
001506  1               @notfound:
001506  1  30 A7        	INR SW,@zw		; rdrop the work area
001508  1  95 A1        	LDAX SW,ModBRPB,0	; restore ZW
00150A  1  5E           	XAZ
00150B  1  30 81        	INR ZW,2		; drop addr2
00150D  1  3A           	CLA			; set flag false
00150E  1  BC           	STAA ZW
00150F  1  65 A1        	LDXX SW,ModBRPB,0	; pop X
001511  1  09           	RSR			; return
001512  1               
001512  1               
001512  1               	.if 0
001512  1                FHdr 'Find',0 ; ( c-addr -- c-addr 0 | xt 1 | xt -1 )
001512  1                  ; https://forth-standard.org/standard/core/FIND
001512  1               	JSRD Abort ;???
001512  1               	.endif
001512  1               
001512  1               
001512  1  2D 46 69 6E   FHdr '-Find',0	; ( "name" -- cfa b true  ) (found)
001516  1  64 05 14 8B  
00151A  1               		; ( "name" --       false ) (not found)
00151A  1                  ; Accepts the next text word (delimited by blanks) in the input stream to HERE,
00151A  1                  ; and searches the CONTEXT and then CURRENT vocabularies for a matching entry.
00151A  1                  ; If found, the dictionary entry's name field address (= CFA), its length byte,
00151A  1                  ; and a bool true is left.  Otherwise, only a bool false is left.
00151A  1  79 0A 83     DFind:	JSRD Bl			; get next word
00151D  1  79 09 2E     	JSRD Word
001520  1               
001520  1               	.if 0  ; debugging
001520  1               	JSRD PDotQuote
001520  1               	.byte 13," found word '"
001520  1               	JSRD Here
001520  1               	JSRD Count
001520  1               	JSRD Type
001520  1               	JSRD PDotQuote
001520  1               	.byte 2,"' "
001520  1               	.endif
001520  1               
001520  1  79 0C 0C     	JSRD Here		; search Context
001523  1  92 70 7E     	LDAI VContext
001526  1  B5 82        	STAX ZW,ModBMRB,0
001528  1  79 14 8B     	JSRD PFind
00152B  1  9C           	LDAA ZW			; if not found
00152C  1  15 0D        	BNZ @2073
00152E  1  30 81        	INR ZW,2		;    drop the false
001530  1  79 0C 0C     	JSRD Here		;    search Current
001533  1  92 70 80     	LDAI VCurrent
001536  1  B5 82        	STAX ZW,ModBMRB,0
001538  1  79 14 8B     	JSRD PFind
00153B  1  09           @2073:	RSR
00153C  1               
00153C  1               
00153C  1  27 41 15 1A   FHdr "'",ha_immediate ; ( "name" -- nfa )
001540  1                  ; Used in the form:
001540  1                  ;	' nnnn
001540  1                  ; Leaves the code address of dictionary word nnnn.  As a compiler
001540  1                  ; directive, executes in a colon-definition to compile the address as a
001540  1                  ; literal.  If the word is not found after a search of CONTEXT and CURRENT,
001540  1                  ; an appropriate error message is given.  Pronounced "tick".
001540  1                  ; https://forth-standard.org/standard/core/Tick
001540  1  7B 03        Tick:	JSRR TickNew
001542  1  71 15 D6     	JMPD Literal		; handle addr as literal
001545  1               
001545  1               TickNew: ; ANSI style
001545  1  79 15 1A     	JSRD DFind		; get name string, search active dictionarys
001548  1  79 05 C0     	JSRD ZEqual		; throw exception if not found
00154B  1  32 20        	CLR BW,Err_0
00154D  1  79 0F 54     	JSRD QErrY
001550  1  30 81        	INR ZW,2		; drop word flags
001552  1  09           	RSR
001553  1               
001553  1               
001553  1  4C 46 41 03   FHdr 'LFA',0 ; ( pfa -- lfa )
001557  1  15 40        
001559  1                  ; Convert the Parameter Field Address of a word to its Link Field Address.
001559  1  9C           LFA:	LDAA ZW
00155A  1  31 04        	DCR AW,3+2
00155C  1  BC           	STAA ZW
00155D  1  09           	RSR
00155E  1               
00155E  1               
00155E  1  43 46 41 03   FHdr 'CFA',0 ; ( pfa -- cfa )
001562  1  15 59        
001564  1                  ; Convert the Parameter Field Address of a word to its Code Field Address.
001564  1  9C           CFA:	LDAA ZW
001565  1  31 02        	DCR AW,3
001567  1  BC           	STAA ZW
001568  1  09           	RSR
001569  1               
001569  1               
001569  1  4E 46 41 03   FHdr 'NFA',0; ( pfa -- nfa )
00156D  1  15 64        
00156F  1                  ; Convert the Parameter Field Address of a word to its Name Field Address.
00156F  1  73 F3        NFA:	JMPR CFA		; NFA=CFA in this inplementaion
001571  1               
001571  1               
001571  1  50 46 41 03   FHdr 'PFA',0 ; ( nfa -- pfa )
001575  1  15 6F        
001577  1                  ; Convert the Name Field Address of a word to its Parameter Field Address.
001577  1  9C           PFA:	LDAA ZW			; NFA=CFA in this implementation
001578  1  30 02        	INR AW,3
00157A  1  BC           	STAA ZW
00157B  1  09           	RSR
00157C  1               
00157C  1               
00157C  1  3E 42 6F 64   FHdr '>Body',0 ; ( xt -- a-addr )
001580  1  79 05 15 77  
001584  1                  ; a-addr is the data-field address corresponding to xt.
001584  1                  ; An ambiguous condition exists if xt is not for a word defined via CREATE.
001584  1                  ; https://forth-standard.org/standard/core/toBODY
001584  1  73 F1        ToBody:	JMPR PFA
001586  1               
001586  1               
001586  1               	.if 0
001586  1               
001586  1                FHdr 'Name>Compile',0 ; ( nt -- x xt )
001586  1                  ; x xt represents the compilation semantics of the word nt.
001586  1                  ; The returned xt has the stack effect ( i * x x -- j * x ).
001586  1                  ; Executing xt consumes x and performs the compilation semantics of the word represented by nt.
001586  1                  ; https://forth-standard.org/standard/tools/NAMEtoCOMPILE
001586  1               NameToCompile:
001586  1               	JSRD Abort ;???
001586  1               
001586  1               
001586  1                FHdr 'Name>Interpret',0 ; ( nt -- xt | 0 )
001586  1                  ; xt represents the interpretation semantics of the word nt.
001586  1                  ; If nt has no interpretation semantics, NAME>INTERPRET returns 0.
001586  1                  ; https://forth-standard.org/standard/tools/NAMEtoINTERPRET
001586  1               NameToInterpret:
001586  1               	JSRD Abort ;???
001586  1               
001586  1               	.endif
001586  1               
001586  1               
001586  1  4E 61 6D 65   FHdr 'Name>String',0 ; ( nfa -- c_addr u )
00158A  1  3E 53 74 72  
00158E  1  69 6E 67 0B  
001592  1  15 84        
001594  1                  ; Get a word's name from its Name Field Address (aka CFA).
001594  1                  ;   https://forth-standard.org/standard/tools/NAMEtoSTRING
001594  1               NameToString:
001594  1  9C           	LDAA ZW		; get nfa
001595  1  31 02        	DCR AW,3
001597  1  5C           	XAY		; Y=cfa-3 (ptr to length & flags)
001598  1  8B           	LDABA YW	; get length
001599  1  D0 00 1F     	LDBL ha_length
00159C  1  52 20        	ANDC AW,BW
00159E  1  B5 82        	STAX ZW,ModBMRB,0 ; store length
0015A0  1  51 60        	SUB AW,YW	; calc start addr
0015A2  1  B5 88 02     	STAX ZW,ModNBRB,2 ; store addr
0015A5  1  09           	RSR
0015A6  1               
0015A6  1               ;@6:
0015A6  1               ; ???handle limited stored chars
0015A6  1               ;	bit #$80
0015A6  1               ;	beq @3
0015A6  1               ;	bra @7
0015A6  1               ;@6:	lda #'-'
0015A6  1               ;	jsr EmitA
0015A6  1               ;@7:	DCR N
0015A6  1               ;	bpl @6
0015A6  1               
0015A6  1               ;	pla
0015A6  1               ;	jmp Space
0015A6  1               
0015A6  1               
0015A6  1  49 64 2E 03   FHdr 'Id.',0 ; ( nfa -- )  Print a definition's name from its code field address.
0015AA  1  15 94        
0015AC  1  7B E6        IdDot:	JSRR NameToString
0015AE  1  79 0D 21     	JSRD Type
0015B1  1  71 0D 01     	JMPD Space
0015B4  1               
0015B4  1               
0015B4  1  5B 43 6F 6D   FHdr '[Compile]',ha_immediate
0015B8  1  70 69 6C 65  
0015BC  1  5D 49 15 AC  
0015C0  1               ; Used in a colon-definition in form:
0015C0  1               ;	: xxx [COMPILE] FORTH ;
0015C0  1               ; [COMPILE] will force the compilation of an immediate definition, that would otherwise
0015C0  1               ; execute during compilation.  The above example will select the FORTH vocabulary when xxx
0015C0  1               ; executes, rather than at compile time.
0015C0  1               BCompile:
0015C0  1  79 13 B7     	JSRD LBracket		; dont' have Tick compile it's results
0015C3  1  79 15 40     	JSRD Tick		; lookup the word
0015C6  1               ;	JSRR CFA		; CFA=NFA in this implementation
0015C6  1  79 10 BD     	JSRD CompileComma	; compile call
0015C9  1  71 13 C0     	JMPD RBracket		; back to compiling, & return
0015CC  1               
0015CC  1               
0015CC  1  4C 69 74 65   FHdr 'Literal',ha_immediate ; ( n -- ) (compiling)
0015D0  1  72 61 6C 47  
0015D4  1  15 C0        
0015D6  1               ; If compiling, then compile the stack value n as a 16 bit literal. This
0015D6  1               ; definition is immediate so that it will execute during a colon definition.
0015D6  1               ; The intended use is:
0015D6  1               ;	: xxx [ calculate ] LITERAL ;
0015D6  1               ; Compilation is suspended for the compile time calculation of a value.
0015D6  1               ; Compilation is resumed and LITERAL compiles this value.
0015D6  1               ; https://forth-standard.org/standard/core/LITERAL
0015D6  1               Literal:
0015D6  1  91 70 82     	LDAD VState		; interpreting?
0015D9  1  15 01        	BNZ LitComma
0015DB  1  09           	RSR
0015DC  1               
0015DC  1               LitComma:
0015DC  1  79 11 2A     	JSRD LdaImmedComma	; compile "LDAL n"
0015DF  1               PushAComma:			; compile "sta (-z)"
0015DF  1  90 B5 82     	LDAL $B582
0015E2  1  71 11 01     	JMPD CommaA
0015E5  1               
0015E5  1               
0015E5  1               
0015E5  1  32 4C 69 74   FHdr '2Literal',ha_immediate ; ( d -- d ) (executing)
0015E9  1  65 72 61 6C  
0015ED  1  48 15 D6     
0015F0  1               			     ; ( d --   ) (compiling)
0015F0  1                  ; If compiling, compile a stack double number into a literal.  Later execution
0015F0  1                  ; of the definition containing the literal will push it to the stack.
0015F0  1                  ; If executing, the number will remain on the stack.
0015F0  1                  ; https://forth-standard.org/standard/double/TwoLITERAL
0015F0  1               TwoLiteral:
0015F0  1  91 70 82     	LDAD VState		; interpreting?
0015F3  1  14 0C        	BZ @2242
0015F5  1               
0015F5  1  79 11 22     	JSRD LdbaComma		; compile "ldy #d.hi" "lda #d.lo"
0015F8  1  79 15 DF     	JSRD PushAComma		; compile "STAX ZW,ModBMRB,0"
0015FB  1  90 F5 82     	LDAL $F582		; compile "STBX ZW,ModBMRB,0"
0015FE  1  71 11 01     	JMPD CommaA
001601  1               
001601  1  09           @2242:	RSR			; return
001602  1               
001602  1               
001602  1  5B 43 68 61   FHdr '[Char]',ha_immediate ; compile a character literal
001606  1  72 5D 46 15  
00160A  1  F0           
00160B  1                  ; compile: ( "c" -- )
00160B  1                  ; run: ( -- c )
00160B  1                  ; Also: Number interprets 'c' as a character literal.
00160B  1               ; https://forth-standard.org/standard/core/BracketCHAR
00160B  1  7B 09        BChar:	JSRR Char
00160D  1  73 C7        	JMPR Literal		; make a literal, & return
00160F  1               
00160F  1               
00160F  1  43 68 61 72   FHdr 'Char',0 ; ( "<spaces>name" -- char )  Get value of ASCII char
001613  1  04 16 0B     
001616  1                  ; https://forth-standard.org/standard/core/CHAR
001616  1                  ; Skip leading space delimiters. Parse name delimited by a space. Put the value of its first character onto the stack.
001616  1  79 0A 83     Char:	JSRD Bl			; get next word
001619  1  79 09 2E     	JSRD Word
00161C  1  D1 70 70     	LDBD VDP		; point at counted string
00161F  1  3A           	CLA			; get 1st char
001620  1  85 28 01     	LDABX BW,ModNBRB,1
001623  1  B5 82        	STAX ZW,ModBMRB,0	; push it
001625  1  09           	RSR
001626  1               
001626  1               
001626  1  5B 27 5D 43   FHdr "[']",ha_immediate ; compile a word address literal
00162A  1  16 16        
00162C  1                  ; https://forth-standard.org/standard/core/BracketTick
00162C  1  79 15 40     BTB:	JSRD Tick
00162F  1  73 A5        	JMPR Literal
001631  1               
001631  1               
001631  1  3B 53 02 16   FHdr ';S',0 ; ( -- )  Stop interpretation of a screen.
001635  1  2C           
001636  1                  ; Not anymore!: ;S was also the run-time word compiled at the
001636  1                  ; end of a colon-defintion which returns execution to the calling procedure.
001636  1  65 A1        SemiS:	LDXX SW,ModBRPB,0 ; drop our RSR addr, so we'll return to Interpret's caller
001638  1  09           	RSR		; return
001639  1               
001639  1               
001639  1  00 41 16 36   FHdr 0,ha_immediate ; ( -- )  end-of-buffer
00163D  1                  ; This is the dictionary entry for a name of one char of ASCII null.
00163D  1                  ; It is the execution procedure to terminate interpretation of a line of text from the terminal
00163D  1                  ; or within a disc buffer, as disk buffers always have a null just beyond the end.
00163D  1  91 70 74     X_:	LDAD VBlk	; terminal?
001640  1  14 F4        	BZ SemiS
001642  1               
001642  1  3A           	CLA
001643  1  B1 70 76     	STAD VIn	; at the beginning of the Blk
001646  1  91 70 74     	LDAD VBlk	; step to next Blk
001649  1  30 0F        	INR AW
00164B  1  B1 70 74     	STAD VBlk
00164E  1  B5 82        	STAX ZW,ModBMRB,0 ; push Blk
001650  1  79 0A 5B     	JSRD Zero	;   as a double
001653  1  79 0A AC     	JSRD BScr	; divide by blocks/screen
001656  1  79 06 E5     	JSRD UMSlashMod	;  ( u_rem u_quot )
001659  1  30 81        	INR ZW,2	; drop quot
00165B  1  95 81        	LDAX ZW,ModBRPB,0 ; at end_of_screen?
00165D  1  15 05        	BNZ @1828
00165F  1  79 0F 78     	JSRD QExec	;   verify we're interpreting
001662  1  65 A1        	LDXX SW,ModBRPB,0 ;   pop my RSR addr, so we'll return to Interpret's caller
001664  1  09           @1828:	RSR		; return
001665  1               
001665  1               
001665  1  49 6E 74 65   FHdr 'Interpret',0 ;
001669  1  72 70 72 65  
00166D  1  74 09 16 3D  
001671  1                  ; The other text interpreter which sequentially executes or compiles text from the
001671  1                  ; input stream (terminal or disc) depending on STATE .  If the word name cannot be
001671  1                  ; found after a search of CONTEXT and then CURRENT it is converted to a number
001671  1                  ; according to the current base.  That also failing, an error message echoing the
001671  1                  ; name with a " ?" will be given.
001671  1                  ; Text input will be taken according to the convention for WORD.  If a decimal point
001671  1                  ; is found as part of a number, a double number value will be left.  The decimal
001671  1                  ; point has no other purpose than to force this action.
001671  1                  ; See NUMBER
001671  1               Interpret:
001671  1  79 0F 31     @2272:	JSRD QStack		; check stack bounds
001674  1               
001674  1  81 70 90     	LDABD VLineComment	; ignore remainder of line?
001677  1  14 19        	BZ @49
001679  1  3A           	CLA
00167A  1  A1 70 90     	STABD VLineComment
00167D  1  D1 70 74     	LDBD VBlk		; reading from disk?
001680  1  15 02        	BNZ @51
001682  1  7B B9        	JSRR X_			;  do end-of-line
001684  1  91 70 76     @51:	LDAD VIn		; go fwd to next C/L boundary
001687  1  D0 00 3F     	LDBL 64-1		; C/L 1-
00168A  1  58           	AAB
00168B  1  90 FF C0     	LDAL $FFC0		; C/L Invert
00168E  1  5A           	NAB
00168F  1  F1 70 76     	STBD VIn
001692  1               @49:
001692  1  79 15 1A     	JSRD DFind		; get next word from input & lookup
001695  1  95 81        	LDAX ZW,ModBRPB,0	; found?
001697  1  14 16        	BZ @2289
001699  1  95 81        	LDAX ZW,ModBRPB,0	; get flags & name_length
00169B  1  D1 70 82     	LDBD VState		; compiling?
00169E  1  14 0A        	BZ @2284
0016A0  1  C0 40        	LDBBL ha_immediate	; immediate flag set?
0016A2  1  4A           	NABB
0016A3  1  15 05        	BNZ @2284
0016A5  1               ;	JSRD CFA		; pfa to cfa
0016A5  1  79 10 BD     	JSRD CompileComma	; compile a jsr to it
0016A8  1  73 C7        	JMPR @2272		; next word
0016AA  1               
0016AA  1               @2284:
0016AA  1               ;	JSRD CFA		; pfa to cfa
0016AA  1  79 08 59     	JSRD Execute		; execute it
0016AD  1  73 C2        	JMPR @2272		; next word
0016AF  1               
0016AF  1  79 0C 0C     @2289:	JSRD Here		; convert it to a number
0016B2  1  79 09 E8     	JSRD Number
0016B5  1  91 70 86     	LDAD VDPL		; contained a '.'?
0016B8  1  38           	INA
0016B9  1  14 05        	BZ @2299
0016BB  1  79 15 F0     	JSRD TwoLiteral		; compile a double-cell literal
0016BE  1  73 B1        	JMPR @2272		; next word
0016C0  1               
0016C0  1  30 81        @2299:	INR ZW,2		; convert double-cell number to single-cell (drop hi cell)
0016C2  1  79 15 D6     	JSRD Literal		; compile a single-cell literal
0016C5  1  73 AA        	JMPR @2272
0016C7  1               
0016C7  1               
0016C7  1  56 6F 63 61   FHdr 'Vocabulary',0 ; ( "name" -- )
0016CB  1  62 75 6C 61  
0016CF  1  72 79 0A 16  
0016D3  1  71           
0016D4  1                  ; A defining word used in the form:
0016D4  1                  ;	VOCABULARY cccc
0016D4  1                  ; to create a vocabulary definition cccc .  Subsequent use of cccc will make it the CONTEXT
0016D4  1                  ; vocabulary which is searched first by INTERPRET .  The sequence "cccc DEFINITIONS" will
0016D4  1                  ; also make ccc the CURRENT vocabulary into which new definitions are placed.
0016D4  1                  ;
0016D4  1                  ; In fig-FORTH, cccc will be so chained as to include all definitions of the
0016D4  1                  ; vocabulary in which cccc is itself defined.  All vocabularys ultimately chain back to
0016D4  1                  ; Forth .  By convention, vocabulary names are to be declared IMMEDIATE .
0016D4  1                  ; See VOC-LINK
0016D4  1                  ; See Forth for a sample vocabulary word.
0016D4  1               Vocabulary:
0016D4  1  79 12 C2     	JSRD HeaderComma	; compile a word header
0016D7  1  79 13 17     	JSRD Immediate		; make it immediate
0016DA  1  90 16 F2     	LDAL DoVoc		; compile "jsr DoVoc"
0016DD  1  79 10 E2     	JSRD JsrCommaA
0016E0  1               
0016E0  1  92 70 80     	LDAI VCurrent		; compile dictionary anchor
0016E3  1  79 11 01     	JSRD CommaA
0016E6  1  D1 70 70     	LDBD VDP		; link into vocabulary chain
0016E9  1  91 70 72     	LDAD VVoc_Link
0016EC  1  F1 70 72     	STBD VVoc_Link
0016EF  1  71 11 01     	JMPD CommaA
0016F2  1               
0016F2  1               
0016F2  1               DoVoc: ; set Context to this vocabulary
0016F2  1  69 70 7E     	STXD VContext
0016F5  1  65 A1        	LDXX SW,ModBRPB,0	; pop pfa
0016F7  1  09           	RSR			; return
0016F8  1               
0016F8  1               
0016F8  1  46 6F 72 74   FHdr 'Forth',ha_immediate ; The primary vocabulary.
0016FC  1  68 45 16 D4  
001700  1                  ; Execution makes FORTH the CONTEXT vocabulary.
001700  1                  ; Until additional user vocabularies are defined, new user definitions become part
001700  1                  ; of FORTH .  FORTH is immediate, so it will execute during the creation of a
001700  1                  ; colon-definition, to select this vocabularty at compile time.
001700  1  79 16 F2     Forth:	JSRD DoVoc	; use direct addressing, so PFA offset looks like other Vocab words
001703  1  00 00        XFor:	.dbyt 0		; points to latest word in this vocabulary
001705  1  00 00        	.dbyt 0		; vocab link, ends at zero
001707  1               
001707  1               
001707  1  44 65 66 69   FHdr 'Definitions',0 ; Set the CURRENT vocabulary to the CONTEXT vocabulary.
00170B  1  6E 69 74 69  
00170F  1  6F 6E 73 0B  
001713  1  17 00        
001715  1                  ; Used in the form:
001715  1                  ;	cccc DEFINITIONS
001715  1                  ; In the example, executing vocabulary name cccc made it the CONTEXT vocabulary
001715  1                  ; and executing DEFINITIONS made both specify vocabulary cccc .
001715  1                  ; https://forth-standard.org/standard/search/DEFINITIONS
001715  1               Definitions:
001715  1  91 70 7E     	LDAD VContext		; get context dictionary
001718  1  B1 70 80     	STAD VCurrent		; set as current dictionary
00171B  1  09           	RSR
00171C  1               
00171C  1               
00171C  1  28 41 17 15   FHdr '(',ha_immediate ;
001720  1                  ; Used in the form:
001720  1                  ;	( cccc)
001720  1                  ; Ignore a comment that will be delimited by a right parenthesis on the same line.
001720  1                  ; May occur during execution or in a colon-definition.
001720  1                  ; A blank after the leading parenthesis is required.
001720  1                  ; https://forth-standard.org/standard/core/p
001720  1  90 00 29     OParen:	LDAL ')'	; push ')'
001723  1  B5 82        	STAX ZW,ModBMRB,0
001725  1  71 09 2E     	JMPD Word	; get the string delimited by ')', & return
001728  1               
001728  1               
001728  1  5C 41 17 20   FHdr '\',ha_immediate ; ignore rest of input line
00172C  1                  ; https://forth-standard.org/standard/block/bs
00172C  1                  ; https://forth-standard.org/standard/core/bs
00172C  1  32 01        	CLR AW,1
00172E  1  A1 70 90     	STABD VLineComment
001731  1  09           	RSR
001732  1               
001732  1               
001732  1               	.if 0
001732  1                FHdr 'Refill',0 ; ( -- flag )
001732  1                  ; Attempt to fill the input buffer from the input source, returning a true flag if successful.
001732  1                  ; When the input source is the user input device, attempt to receive input into the terminal input buffer.
001732  1                  ; If successful, make the result the input buffer, set >IN to zero, and return true.
001732  1                  ; Receipt of a line containing no characters is considered successful.
001732  1                  ; If there is no input available from the current input source, return false.
001732  1                  ;
001732  1                  ; When the input source is a string from EVALUATE, return false and perform no other action.
001732  1                  ; https://forth-standard.org/standard/block/REFILL
001732  1               	JSRD Abort ;???
001732  1               	.endif
001732  1               
001732  1               
001732  1  51 75 69 74   FHdr 'Quit',0 ; ( -- )
001736  1  04 17 2C     
001739  1                  ; Clear the return stack, stop compilation, and return control to the operators
001739  1                  ; terminal.  No message is given.
001739  1                  ; https://forth-standard.org/standard/core/QUIT
001739  1  3A           Quit:	CLA
00173A  1  A1 70 90     	STABD VLineComment	; disable line ignore
00173D  1  B1 70 74     	STAD VBlk		; input from console
001740  1  B1 70 82     	STAD VState		; interpret mode
001743  1               @2388:				; begin
001743  1  79 02 31     	JSRD EmptyRStack	;   empty return stack
001746  1  79 0C EC     	JSRD CR			;   newline
001749  1  79 0E BA     	JSRD Query		;   get string to TIB
00174C  1  79 16 71     	JSRD Interpret		;   interpret words in the string
00174F  1  91 70 82     	LDAD VState		;   compiling?
001752  1  15 07        	BNZ @2399
001754  1  79 14 39     	JSRD PDotQuote		;     type " OK"
001757  1  03 20 4F 4B  	.byte 3,' OK'
00175B  1               @2399:
00175B  1  73 E6        	JMPR @2388		;  again
00175D  1               
00175D  1               
00175D  1  41 62 6F 72   FHdr 'Abort"',ha_immediate ; Abort with inline message
001761  1  74 22 46 17  
001765  1  39           
001766  1                  ; compile: ( "string" -- )
001766  1                  ; run: ( f -- )
001766  1  79 0F 61     AbortQ:	JSRD QComp		; verify we're compiling
001769  1  90 17 72     	LDAL @Run		; compile JSR
00176C  1  79 10 E2     	JSRD JsrCommaA
00176F  1  71 14 28     	JMPD CountedStringComma
001772  1               
001772  1               @Run: ; runtime
001772  1  3A           	CLA			; get inline string length
001773  1  85 41        	LDABX XW,ModBRPB,0
001775  1  D5 81        	LDBX ZW,ModBRPB,0	; pop f
001777  1  15 03        	BNZ @RunErr
001779  1  50 04        	ADD XW,AW		; skip inline string
00177B  1  09           	RSR
00177C  1               
00177C  1  F5 82        @RunErr: STBX ZW,ModBMRB,0	; push string addr
00177E  1  B5 82        	STAX ZW,ModBMRB,0	; push string length
001780  1  79 0D 21     	JSRD Type		; type it
001783  1  73 08        	JMPR Abort		; abort
001785  1               
001785  1               
001785  1  41 62 6F 72   FHdr 'Abort',0 ;
001789  1  74 05 17 66  
00178D  1                  ; Clears the stacks and enter the execution state.  Return control to the
00178D  1                  ; operators terminal, printing a message appropriate to the installation.
00178D  1  79 02 45     Abort:	JSRD EmptyStack		; empty the param stack
001790  1  79 03 A6     	JSRD RAt		; type address that called us
001793  1  79 1D 0D     	JSRD EX4
001796  1  79 0D 4A     	JSRD Decimal		; set base to decimal
001799  1  79 18 B3     	JSRD DR0		; select disc drive 0
00179C  1  79 0C EC     	JSRD CR			; newline
00179F  1  79 14 39     	JSRD PDotQuote		; type literal
0017A2  1  19 66 69 67  	.byte 25,'fig-FORTH CPU6 subroutine'
0017A6  1  2D 46 4F 52  
0017AA  1  54 48 20 43  
0017AE  1  50 55 36 20  
0017B2  1  73 75 62 72  
0017B6  1  6F 75 74 69  
0017BA  1  6E 65        
0017BC  1  79 17 00     	JSRD Forth		; make Forth vocabulary current
0017BF  1  79 17 15     	JSRD Definitions	;   & definitions
0017C2  1  71 17 39     	JMPD Quit		; restart the interpreter
0017C5  1               
0017C5  1               
0017C5  1  43 6F 6C 64   FHdr 'Cold',0 ;	Cold start the system.
0017C9  1  04 17 8D     
0017CC  1                  ; May be called from the terminal to remove application programs and restart.
0017CC  1               Cold:
0017CC  1               ;	LDABL $40	; Add & link test 1
0017CC  1               ;	LDBBL $80
0017CC  1               ;	AABB
0017CC  1               ;	BNL @11
0017CC  1               ;	HLT
0017CC  1               ;@11:
0017CC  1               
0017CC  1               ;	LDABL $40	; Add & link test 2
0017CC  1               ;	LDBBL $fe
0017CC  1               ;	AABB
0017CC  1               ;	BL @12
0017CC  1               ;	HLT
0017CC  1               ;@12:
0017CC  1               
0017CC  1               ;	LDBBL $40	; Sub & link test 1
0017CC  1               ;	LDABL 2
0017CC  1               ;	SABB
0017CC  1               ;	BNL @13		;   no borrow
0017CC  1               ;	HLT
0017CC  1               ;@13:
0017CC  1               
0017CC  1               ;	LDBBL $40		; Sub & link test 2
0017CC  1               ;	LDABL $42
0017CC  1               ;	SABB
0017CC  1               ;	BL @14			;   borrow
0017CC  1               ;	HLT
0017CC  1               ;@14:
0017CC  1               
0017CC  1               ;	LDAL $c000
0017CC  1               ;	XAS
0017CC  1               ;	LDAL $8800		; to diag ROM CPU test
0017CC  1               ;	XAZ
0017CC  1               ;	JMPD $8849
0017CC  1               
0017CC  1  3A           	CLA			; disable RAM disk
0017CD  1  B1 70 5C     	STAD RamDiskCount
0017D0  1               
0017D0  1  91 02 0C     	LDAD ORIG+$0C		; Initialize Forth vocabulary
0017D3  1  B1 17 03     	STAD XFor
0017D6  1  80 16        	LDABL 2+VVoc_Link-VUser	; user variables to initialize
0017D8  1  73 02        	JMPR L2433
0017DA  1               
0017DA  1               Warm: ; warm start the system
0017DA  1  80 10        	LDABL 2+VWarning-VUser	; user variaboles to initialize
0017DC  1               L2433:
0017DC  1  60 02 0C     	LDXL ORIG+$0c		; init some user variables from cold start area
0017DF  1  D0 70 5E     	LDBL VUser
0017E2  1  55 26        	XFR YW,BW
0017E4  1  C5 41        @2437:	LDBBX XW,ModBRPB,0
0017E6  1  E5 61        	STBBX YW,ModBRPB,0
0017E8  1  29           	DCAB
0017E9  1  17 F9        	BP @2437
0017EB  1               
0017EB  1  79 02 31     	JSRD EmptyRStack	; empty return stack
0017EE  1               
0017EE  1  79 02 45     	JSRD EmptyStack		; empty param stack
0017F1  1  79 0D 4A     	JSRD Decimal
0017F4  1               ;	JSRD UMStarTest1
0017F4  1               ;	JSRD UMSlashModTest1
0017F4  1               ;	JSRD MSlashModTest1
0017F4  1               
0017F4  1               ;	LDAL 12345		; test decimal print
0017F4  1               ;	STAX ZW,ModBMRB,0
0017F4  1               ;	JSRD Dot
0017F4  1               
0017F4  1  71 17 8D     	JMPD Abort		; And off we go!
0017F7  1               
0017F7  1               
0017F7  1               	.if 0
0017F7  1                FHdr 'Using',0 ; ( "filename" -- )  Open a block file
0017F7  1               Using:	JSRD Bl
0017F7  1               	JSRD Word
0017F7  1               	HLT ; open the filename as a block file
0017F7  1               	RSR
0017F7  1               	.endif
0017F7  1               
0017F7  1               
0017F7  1  55 73 65 03   FHdr 'Use',0 ; ( -- addr )  variable:
0017FB  1  17 CC        
0017FD  1  90 70 00     Use:	LDAL VUse
001800  1  B5 82        	STAX ZW,ModBMRB,0
001802  1  09           	RSR
001803  1               
001803  1               
001803  1  50 72 65 76   FHdr 'Prev',0 ; ( -- adr )  variable:
001807  1  04 17 FD     
00180A  1  90 70 02     Prev:	LDAL VPrev
00180D  1  B5 82        	STAX ZW,ModBMRB,0
00180F  1  09           	RSR
001810  1               
001810  1               
001810  1  46 69 72 73   FHdr 'First',0 ; ( -- adr )  constant: address of the first (lowest) block buffer.
001814  1  74 05 18 0A  
001818  1  90 71 A1     First:	LDAL DArea
00181B  1  B5 82        	STAX ZW,ModBMRB,0
00181D  1  09           	RSR
00181E  1               
00181E  1               
00181E  1  4C 69 6D 69  FHdr 'Limit',0 ; ( -- adr )  constant: address just above the highest memory available
001822  1  74 05 18 18  
001826  1               		; for a disc buffer.
001826  1  90 75 B1     Limit:	LDAL DAreaEnd
001829  1  B5 82        	STAX ZW,ModBMRB,0
00182B  1  09           	RSR
00182C  1               
00182C  1               
00182C  1  2B 42 75 66   FHdr '+Buf',0 ; ( addr1 -- addr2 f )
001830  1  04 18 26     
001833  1               ; Advance the disc buffer address addr1 to the address of the next buffer addr2.
001833  1               ; Bool f is false when addr2 is the buffer presently pointed to by variable PREV.
001833  1  90 01 04     PBuf:	LDAL 2+SectorSize+2	 ; hold block #, one sector, ??? two num
001836  1  DC           	LDBA ZW
001837  1  50 20        	ADD AW,BW
001839  1  D1 18 27     	LDBD Limit+1
00183C  1  59           	SAB
00183D  1  10 03        	BL @2691
00183F  1  91 18 19     	LDAD First+1
001842  1  BC           @2691:	STAA ZW
001843  1  D1 70 02     	LDBD VPrev
001846  1  54 20        	ORE AW,BW
001848  1  B5 82        	STAX ZW,ModBMRB,0
00184A  1  09           	RSR
00184B  1               
00184B  1               
00184B  1  55 70 64 61   FHdr 'Update',0 ; ( -- )
00184F  1  74 65 06 18  
001853  1  33           
001854  1                  ; Marks the most recently referenced block (pointed to by PREV ) as altered.
001854  1                  ; The block will subsequently be transferred automatically to disc should its
001854  1                  ; buffer be required for storage of a different block.
001854  1                  ; https://forth-standard.org/standard/block/UPDATE
001854  1  D0 80 00     Update:	LDBL $8000	; set the hi bit of the block # in the PREV block
001857  1  91 70 02     	LDAD VPrev
00185A  1  5C           	XAY
00185B  1  9B           	LDAA YW
00185C  1  53 20        	ORI AW,BW
00185E  1  BB           	STAA YW
00185F  1  09           	RSR
001860  1               
001860  1               
001860  1               	.if 0
001860  1                FHdr 'Save-Buffers',0 ; ( -- )  Transfer the contents of each UPDATEd block buffer to mass storage. Mark all buffers as unmodified.
001860  1                  ; https://forth-standard.org/standard/block/SAVE-BUFFERS
001860  1               Save_Buffers:
001860  1               	JSRD Abort ;???
001860  1               	.endif
001860  1               
001860  1               
001860  1  46 6C 75 73   FHdr 'Flush',0 ; ( -- )  Flush modified blocks back to disk
001864  1  68 05 18 54  
001868  1                  ; https://forth-standard.org/standard/block/FLUSH
001868  1  91 18 19     Flush:	LDAD First+1		; for each available block buffer
00186B  1  B5 A2        @2835:	STAX SW,ModBMRB,0
00186D  1  90 7F FF     	LDAL $7FFF		;   alloc a buffer for block $7fff
001870  1  B5 82        	STAX ZW,ModBMRB,0	;     ( removing the existing contents )
001872  1  79 18 CC     	JSRD Buffer
001875  1  30 81        	INR ZW,2		;   drop the addr
001877  1  95 A1        	LDAX SW,ModBRPB,0	;  next available block buffer
001879  1  D0 01 04     	LDBL SectorSize+4
00187C  1  50 20        	ADD AW,BW
00187E  1  D1 18 27     	LDBD Limit+1
001881  1  59           	SAB
001882  1  11 E7        	BNL @2835
001884  1  09           	RSR			; return
001885  1               
001885  1               
001885  1  45 6D 70 74   FHdr "Empty-Buffers",0 ; ( -- )  Mark all block-buffers as empty
001889  1  79 2D 42 75  
00188D  1  66 66 65 72  
001891  1  73 0D 18 68  
001895  1                  ; not necessarily affecting the contents.
001895  1                  ; Updated blocks are not written to the disc.
001895  1                  ; This is also an initialization procedure before first use of the disc.
001895  1                  ; https://forth-standard.org/standard/block/EMPTY-BUFFERS
001895  1               Empty_Buffers:
001895  1  91 18 19     	LDAD First+1		; init Use & Prev
001898  1  B1 70 00     	STAD VUse
00189B  1  B1 70 02     	STAD VPrev
00189E  1               
00189E  1  79 18 18     	JSRD First	; zero all the disc buffer bytes, & return
0018A1  1  79 18 26     	JSRD Limit
0018A4  1  79 02 CC     	JSRD Over
0018A7  1  79 05 1C     	JSRD Subtract
0018AA  1  71 0C 98     	JMPD Erase
0018AD  1               
0018AD  1               
0018AD  1  44 52 30 03  	FHdr 'DR0',0 ; ( -- )  select disc drive 0
0018B1  1  18 95        
0018B3  1  3A           DR0:	CLA
0018B4  1  B1 70 7C     DRA:	STAD VOffset	; Offset=0
0018B7  1  09           	RSR		; return
0018B8  1               
0018B8  1               
0018B8  1  44 52 31 03  	FHdr 'DR1',0 ; ( -- )  select disc drive 1
0018BC  1  18 B3        
0018BE  1  90 03 20     DR1:	LDAL Sectors	; Offset=sectors	(sectors per drive)
0018C1  1  73 F1        	JMPR DRA
0018C3  1               
0018C3  1               
0018C3  1  42 75 66 66   FHdr 'Buffer',0 ; ( n -- addr )  Obtain the next memory buffer, assigning it to block n.
0018C7  1  65 72 06 18  
0018CB  1  BE           
0018CC  1                  ; If the contents of the buffer is marked as updated, it is written to the disk.
0018CC  1                  ; The block is not read from the disc.
0018CC  1                  ; The address left is the first cell within the buffer for data storage.
0018CC  1                  ; https://forth-standard.org/standard/block/BUFFER
0018CC  1  91 70 00     Buffer:	LDAD VUse
0018CF  1  B5 82        	STAX ZW,ModBMRB,0
0018D1  1  79 18 33     @2758:	JSRD PBuf
0018D4  1  95 81        	LDAX ZW,ModBRPB,0
0018D6  1  14 F9        	BZ @2758
0018D8  1               
0018D8  1  D1 70 00     	LDBD VUse		;modified?
0018DB  1  99           	LDAA BW
0018DC  1  17 10        	BP @2776
0018DE  1  30 21        	INR BW,2		;  write old buffer contents
0018E0  1  F5 82        	STBX ZW,ModBMRB,0
0018E2  1  D0 7F FF     	LDBL $7fff
0018E5  1  5A           	NAB
0018E6  1  F5 82        	STBX ZW,ModBMRB,0
0018E8  1  79 0A 5B     	JSRD Zero
0018EB  1  79 1B 21     	JSRD RSlashW
0018EE  1               @2776:
0018EE  1               
0018EE  1  95 81        	LDAX ZW,ModBRPB,0	; save this block buffer address
0018F0  1  B1 70 00     	STAD VUse
0018F3  1  5C           	XAY
0018F4  1               
0018F4  1  D5 81        	LDBX ZW,ModBRPB,0	; store block #
0018F6  1  FB           	STBA YW
0018F7  1  D0 01 02     	LDBL 2+SectorSize	; insert terminating nulls
0018FA  1  58           	AAB
0018FB  1  3A           	CLA
0018FC  1  B9           	STAA BW
0018FD  1  55 60        	XFR AW,YW
0018FF  1  B1 70 02     	STAD VPrev
001902  1               
001902  1  38           	INA			; return data buffer addr
001903  1  38           	INA
001904  1  B5 82        	STAX ZW,ModBMRB,0
001906  1  09           	RSR
001907  1               
001907  1               
001907  1  42 6C 6F 63   FHdr 'Block',0 ; ( n -- addr )  Leave the memory address of the block buffer containing block n.
00190B  1  6B 05 18 CC  
00190F  1                  ; If the block
00190F  1                  ; is not already in memory, it is transferred from disc to which ever buffer was
00190F  1                  ; least recently written.  If the block occupying that buffer has been marked as
00190F  1                  ; updated, it is rewritten to disc before block n is read into the buffer.
00190F  1                  ; See also BUFFER, R/W UPDATE FLUSH
00190F  1                  ; https://forth-standard.org/standard/block/BLOCK
00190F  1  95 81        Block:	LDAX ZW,ModBRPB,0	; calc physical block #
001911  1  D1 70 7C     	LDBD VOffset
001914  1  58           	AAB
001915  1  B5 A2        	STAX SW,ModBMRB,0
001917  1               
001917  1  91 70 02     	LDAD VPrev		; Start at VPrev
00191A  1  B5 81        	STAX ZW,ModBRPB,0
00191C  1  9C           	LDAA ZW			; if not block match
00191D  1  98           	LDAA AW
00191E  1  DD           	LDBA SW
00191F  1  54 20        	ORE AW,BW
001921  1  3D           	SLA
001922  1  14 31        	BZ @2830
001924  1               
001924  1               @2805:				;   begin
001924  1  79 18 33     	JSRD PBuf		;     step to next buffer
001927  1  95 81        	LDAX ZW,ModBRPB,0	;     if it is VUse
001929  1  15 1E        	BNZ @2818
00192B  1  30 81        	INR ZW,2		;       drop
00192D  1  79 03 A6     	JSRD RAt		;       allocate buffer
001930  1  79 18 CC     	JSRD Buffer
001933  1  79 02 E9     	JSRD Dup		;       read contents
001936  1  79 03 A6     	JSRD RAt
001939  1  79 0A 64     	JSRD One
00193C  1  79 1B 21     	JSRD RSlashW
00193F  1  DC           	LDBA ZW			;       point at header
001940  1  31 21        	DCR BW,2
001942  1  FC           	STBA ZW
001943  1  90 01 02     	LDAL 2+SectorSize	;       insert terminating nulls
001946  1  58           	AAB
001947  1  3A           	CLA
001948  1  B9           	STAA BW
001949  1               @2818:				;      then
001949  1  9C           	LDAA ZW			;    until block match
00194A  1  98           	LDAA AW
00194B  1  DD           	LDBA SW
00194C  1  54 20        	ORE AW,BW
00194E  1  3D           	SLA
00194F  1  15 D3        	BNZ @2805
001951  1  9C           	LDAA ZW			;   set VPrev
001952  1  B1 70 02     	STAD VPrev
001955  1               
001955  1               @2830:				;  then
001955  1  30 A1        	INR SW,2		; rdrop
001957  1  71 04 BE     	JMPD TwoPlus		; point at data
00195A  1               
00195A  1               
00195A  1  28 4C 69 6E   FHdr '(Line)',0 ; ( n_line n_screen -- addr count )
00195E  1  65 29 06 19  
001962  1  0F           
001963  1                  ; Convert the line number n_line and the screen n_screen to the disc buffer address
001963  1                  ; containing the data.  A count of 64 indicates the full line text length.
001963  1  79 03 C4     PLine:	JSRD ToR		; save n_screen
001966  1  79 0A 90     	JSRD CSlashL		; get chars per line
001969  1  79 0A 9E     	JSRD BBuf		; get bytes per disc buffer
00196C  1  79 07 CC     	JSRD StarSlashMod	; convert n_line to disc block # & offset
00196F  1  79 03 BA     	JSRD RFrom		; get n_screen
001972  1  79 0A AC     	JSRD BScr		; get disc blocks per screen
001975  1  79 07 96     	JSRD Star		; convert screen to disc blocks
001978  1  79 04 DD     	JSRD Plus		; add screen blocks to line blocks
00197B  1  7B 92        	JSRR Block		; read the disc block
00197D  1  79 04 DD     	JSRD Plus		; add offset
001980  1  71 0A 90     	JMPD CSlashL		; get chars per line, & return
001983  1               
001983  1               
001983  1  2E 4C 69 6E   FHdr '.Line',0 ; ( n_line n_screen -- )
001987  1  65 05 19 63  
00198B  1               DotLine:
00198B  1  79 19 63     	JSRD PLine
00198E  1  79 08 97     	JSRD DTrailing
001991  1  71 0D 21     	JMPD Type
001994  1               
001994  1               
001994  1  4D 65 73 73   FHdr 'Message',0 ; ( n -- )
001998  1  61 67 65 07  
00199C  1  19 8B        
00199E  1                  ; Print on the selected output device the text of line n relative to screen 4
00199E  1                  ; of drive 0.  n may be positive or negative.  MESSAGE may be used to print
00199E  1                  ; incidental text such as report headers.  If WARNING is zero, the message will
00199E  1                  ; simply be printed as a number (disc unavailable).
00199E  1               Message:
00199E  1  9C           	LDAA ZW		; n=0 gives no message
00199F  1  14 20        	BZ @2886
0019A1  1  D0 00 17     	LDBL @IndexCount ; built-in message?
0019A4  1  59           	SAB
0019A5  1  11 2A        	BNL @Int
0019A7  1  D1 70 6C     @Ext:	LDBD VWarning	; short messages?
0019AA  1  14 18        	BZ @2888
0019AC  1  90 00 04     	LDAL 4		; messages start in block 4
0019AF  1  B5 82        	STAX ZW,ModBMRB,0
0019B1  1  91 70 7C     	LDAD VOffset
0019B4  1  B5 82        	STAX ZW,ModBMRB,0
0019B6  1  79 0A AC     	JSRD BScr
0019B9  1  79 07 B4     	JSRD Slash
0019BC  1  79 05 1C     	JSRD Subtract
0019BF  1  73 CA        	JMPR DotLine	; type the line, & return
0019C1  1               
0019C1  1  30 81        @2886:	INR ZW,2	; drop n
0019C3  1  09           	RSR		; return
0019C4  1               
0019C4  1  79 14 39     @2888:	JSRD PDotQuote	; type literal
0019C7  1  06 4D 73 67  	.byte 6,'Msg # '
0019CB  1  20 23 20     
0019CE  1  71 0E 62     	JMPD Dot	; type n, & return
0019D1  1               
0019D1  1               
0019D1  1               @Int:	; internal message text?
0019D1  1  D0 19 E4     	LDBL @Index	; get index
0019D4  1  58           	AAB
0019D5  1  3A           	CLA
0019D6  1  89           	LDABA BW
0019D7  1  14 CE        	BZ @Ext		; if we don't have one, try external
0019D9  1  D0 19 FB     	LDBL @Msg
0019DC  1  58           	AAB
0019DD  1  FC           	STBA ZW
0019DE  1  79 08 63     	JSRD Count
0019E1  1  71 0D 21     	JMPD Type
0019E4  1               
0019E4  1  00 01 0D 00  @Index:	.byte 0,@Msg1-@Msg,@Msg2-@Msg,0
0019E8  1  1D 00 2A 35  	.byte @Msg4-@Msg,0,@Msg6-@Msg,@Msg7-@Msg
0019EC  1  44 00 00 00  	.byte @Msg8-@Msg,0,0,0
0019F0  1  00 00 00 00  	.byte 0,0,0,0
0019F4  1  00 51 5E 6B  	.byte 0,@Msg17-@Msg,@Msg18-@Msg,@Msg19-@Msg
0019F8  1  83 9B B3     	.byte @Msg20-@Msg,@Msg21-@Msg,@Msg22-@Msg
0019FB  1               @IndexCount = *-@Index
0019FB  1               
0019FB  1  00           @Msg:	.byte 0
0019FC  1  0B 45 6D 70  @Msg1:	.byte 11,'Empty stack'
001A00  1  74 79 20 73  
001A04  1  74 61 63 6B  
001A08  1  0F 44 69 63  @Msg2:	.byte 15,'Dictionary full'
001A0C  1  74 69 6F 6E  
001A10  1  61 72 79 20  
001A14  1  66 75 6C 6C  
001A18  1  0C 49 73 6E  @Msg4:	.byte 12,"Isn't unique"
001A1C  1  27 74 20 75  
001A20  1  6E 69 71 75  
001A24  1  65           
001A25  1  0A 44 69 73  @Msg6:	.byte 10,'Disc range'
001A29  1  63 20 72 61  
001A2D  1  6E 67 65     
001A30  1  0E 53 74 61  @Msg7:	.byte 14,"Stack overflow"
001A34  1  63 6B 20 6F  
001A38  1  76 65 72 66  
001A3C  1  6C 6F 77     
001A3F  1  0C 44 69 73  @Msg8:	.byte 12,"Disk I/O err"
001A43  1  6B 20 49 2F  
001A47  1  4F 20 65 72  
001A4B  1  72           
001A4C  1  0C 43 6F 6D  @Msg17:	.byte 12,'Compile only'
001A50  1  70 69 6C 65  
001A54  1  20 6F 6E 6C  
001A58  1  79           
001A59  1  0C 45 78 65  @Msg18:	.byte 12,'Execute only'
001A5D  1  63 75 74 65  
001A61  1  20 6F 6E 6C  
001A65  1  79           
001A66  1  17 43 6F 6E  @Msg19:	.byte 23,'Conditionals not paired'
001A6A  1  64 69 74 69  
001A6E  1  6F 6E 61 6C  
001A72  1  73 20 6E 6F  
001A76  1  74 20 70 61  
001A7A  1  69 72 65 64  
001A7E  1  17 44 65 66  @Msg20:	.byte 23,'Definition not finished'
001A82  1  69 6E 69 74  
001A86  1  69 6F 6E 20  
001A8A  1  6E 6F 74 20  
001A8E  1  66 69 6E 69  
001A92  1  73 68 65 64  
001A96  1  17 49 6E 20  @Msg21:	.byte 23,'In protected dictionary'
001A9A  1  70 72 6F 74  
001A9E  1  65 63 74 65  
001AA2  1  64 20 64 69  
001AA6  1  63 74 69 6F  
001AAA  1  6E 61 72 79  
001AAE  1  15 55 73 65  @Msg22:	.byte 21,'Use only when loading'
001AB2  1  20 6F 6E 6C  
001AB6  1  79 20 77 68  
001ABA  1  65 6E 20 6C  
001ABE  1  6F 61 64 69  
001AC2  1  6E 67        
001AC4  1               
001AC4  1               
001AC4  1               MessageA: ; entry with n in A
001AC4  1  B5 82        	STAX ZW,ModBMRB,0
001AC6  1  71 19 9E     	JMPD Message
001AC9  1               
001AC9  1               
001AC9  1               	.if 0
001AC9  1               
001AC9  1                FHdr 'Source',0 ; ( -- c-addr u )
001AC9  1                  ; c-addr is the address of, and u is the number of characters in, the input buffer.
001AC9  1                  ; https://forth-standard.org/standard/core/SOURCE
001AC9  1               	JSRD Abort ;???
001AC9  1               
001AC9  1               
001AC9  1                FHdr 'Source-Id',0 ; ( -- 0 | -1 )
001AC9  1                  ; Identifies the input source as follows:
001AC9  1                  ; SOURCE-ID	Input source
001AC9  1                  ;   -1	String (via EVALUATE)
001AC9  1                  ;    0	User input device
001AC9  1                  ; https://forth-standard.org/standard/core/SOURCE-ID
001AC9  1               	JSRD Abort ;???
001AC9  1               
001AC9  1               
001AC9  1                FHdr 'Restore-Input',0 ; ( xn ... x1 n -- flag )
001AC9  1                  ; Attempt to restore the input source specification to the state described by x1 through xn.
001AC9  1                  ; flag is true if the input source specification cannot be so restored.
001AC9  1                  ;
001AC9  1                  ; An ambiguous condition exists if the input source represented by the arguments is not the same as the current input source.
001AC9  1                  ; https://forth-standard.org/standard/core/RESTORE-INPUT
001AC9  1               	JSRD Abort ;???
001AC9  1               
001AC9  1               
001AC9  1                FHdr 'Save-Input',0 ; ( -- xn ... x1 n )
001AC9  1                  ; x1 through xn describe the current state of the input source specification for later use by RESTORE-INPUT.
001AC9  1                  ; https://forth-standard.org/standard/core/SAVE-INPUT
001AC9  1               	JSRD Abort ;???
001AC9  1               
001AC9  1               
001AC9  1                FHdr 'Evaluate',0 ; ( i * x c-addr u -- j * x )
001AC9  1                  ; https://forth-standard.org/standard/block/EVALUATE
001AC9  1                  ; https://forth-standard.org/standard/core/EVALUATE
001AC9  1               Evaluate:
001AC9  1               	JSRD Abort ;???
001AC9  1               
001AC9  1               	.endif
001AC9  1               
001AC9  1               
001AC9  1  4C 6F 61 64   FHdr 'Load',0 ; ( n -- )  Begin interpretation of screen n.
001ACD  1  04 19 9E     
001AD0  1                  ; Loading will terminate at the end of the screen or at ;S .
001AD0  1                  ; See ;S -->
001AD0  1                  ; https://forth-standard.org/standard/block/LOAD
001AD0  1  91 70 74     Load:	LDAD VBlk	; save existing Blk & In
001AD3  1  B5 A2        	STAX SW,ModBMRB,0
001AD5  1  91 70 76     	LDAD VIn
001AD8  1  B5 A2        	STAX SW,ModBMRB,0
001ADA  1  3A           	CLA
001ADB  1  B1 70 76     	STAD VIn	; In=0
001ADE  1  79 0A AC     	JSRD BScr	; Blk=n*(blocks_per_screen)
001AE1  1  79 07 96     	JSRD Star
001AE4  1  95 81        	LDAX ZW,ModBRPB,0
001AE6  1  B1 70 74     	STAD VBlk
001AE9  1               
001AE9  1  79 16 71     	JSRD Interpret	; interpret the disc block
001AEC  1               
001AEC  1  95 A1        	LDAX SW,ModBRPB,0 ; restore Blk & In
001AEE  1  B1 70 76     	STAD VIn
001AF1  1  95 A1        	LDAX SW,ModBRPB,0
001AF3  1  B1 70 74     	STAD VBlk
001AF6  1  09           	RSR		; return
001AF7  1               
001AF7  1               
001AF7  1  2D 2D 3E 43   FHdr '-->',ha_immediate ; ( -- )  Continue interpretation with the next disc screen.
001AFB  1  1A D0        
001AFD  1  79 0F C0     NextB:	JSRD QLoad	; verify that we're LOADing
001B00  1  3A           	CLA
001B01  1  B1 70 76     	STAD VIn	; offset in block =0
001B04  1  79 0A AC     	JSRD BScr	; move Blk to start of next screen
001B07  1  91 70 74     	LDAD VBlk
001B0A  1  B5 82        	STAX ZW,ModBMRB,0
001B0C  1  79 02 CC     	JSRD Over
001B0F  1  79 07 BF     	JSRD Mod
001B12  1  79 05 1C     	JSRD Subtract
001B15  1  79 0B 33     	JSRD Blk
001B18  1  71 07 E8     	JMPD PlusStore
001B1B  1               
001B1B  1               
001B1B  1               	.if 0
001B1B  1                FHdr 'Thru',0 ; ( i * x u1 u2 -- j * x )
001B1B  1                  ; LOAD the mass storage blocks numbered u1 through u2 in sequence.
001B1B  1                  ; Other stack effects are due to the words LOADed.
001B1B  1                  ; https://forth-standard.org/standard/block/THRU
001B1B  1               Thru:	JSRD Abort ;???
001B1B  1               	.endif
001B1B  1               
001B1B  1               
001B1B  1               	.if 0
001B1B  1                FHdr 'Include',0 ; ( "filename" -- )  Interpret text from the file
001B1B  1               	JSRD Abort ; ???do something
001B1B  1               	RSR
001B1B  1               	.endif
001B1B  1               
001B1B  1               
001B1B  1  52 2F 57 03   FHdr 'R/W',0 ; ( addr blk f -- )  The fig-FORTH standard disc read-write linkage.
001B1F  1  1A FD        
001B21  1                  ; addr specifies the source or destination block buffer,
001B21  1                  ; blk is the sequential number of the referenced block;
001B21  1                  ; and f is a flag for f=0 write and f=1 read.
001B21  1                  ; R/W determines the location on mass storage, performs the read-write and
001B21  1                  ; performs any error checking.
001B21  1               RSlashW:
001B21  1  D1 70 5C     	LDBD RamDiskCount	; is the RAM disk initialized?
001B24  1  15 03        	BNZ @RD
001B26  1               
001B26  1               	; we have no disk yet!
001B26  1  79 17 8D     @Abort:	JSRD Abort
001B29  1               
001B29  1               @RD: ; Use RAM disk
001B29  1  95 88 02     	LDAX ZW,ModNBRB,2	; block # in range?
001B2C  1  59           	SAB
001B2D  1  10 F7        	BL @Abort
001B2F  1  35 07        	SLR AW,8		; cvt to bytes
001B31  1  D1 70 5A     	LDBD RamDiskStart
001B34  1  58           	AAB
001B35  1  9C           	LDAA ZW			; get f
001B36  1  14 0F        	BZ @RdWrite
001B38  1               
001B38  1               @RdRead:			; move from RAM disk to buffer
001B38  1  95 88 04     	LDAX ZW,ModNBRB,4
001B3B  1  F5 88 04     	STBX ZW,ModNBRB,4
001B3E  1  B5 88 02     	STAX ZW,ModNBRB,2
001B41  1  90 01 00     @Rd2:	LDAL 256
001B44  1  71 0C 29     	JMPD CMove
001B47  1               
001B47  1               @RdWrite:			; move from buffer to RAM disk
001B47  1  F5 88 02     	STBX ZW,ModNBRB,2
001B4A  1  73 F5        	JMPR @Rd2
001B4C  1               
001B4C  1               
001B4C  1  52 61 6D 44   FHdr 'RamDisk',0 ; ( n -- )  alloc n blocks of RAM disk, & init
001B50  1  69 73 6B 07  
001B54  1  1B 21        
001B56  1  D1 70 70     	LDBD VDP		; remember where RAM disk starts
001B59  1  F1 70 5A     	STBD RamDiskStart
001B5C  1  9C           	LDAA ZW
001B5D  1  F5 82        	STBX ZW,ModBMRB,0
001B5F  1  B1 70 5C     	STAD RamDiskCount
001B62  1  35 07        	SLR AW,8
001B64  1  BC           	STAA ZW
001B65  1  B5 82        	STAX ZW,ModBMRB,0
001B67  1  79 0F D1     	JSRD Allot
001B6A  1  71 0C 98     	JMPD Erase
001B6D  1               
001B6D  1               
001B6D  1  46 6F 72 67   FHdr 'Forget',0 ; ( "name" -- )
001B71  1  65 74 06 1B  
001B75  1  56           
001B76  1                  ; https://forth-standard.org/standard/tools/FORGET
001B76  1                  ; Executed in the form:
001B76  1                  ;	FORGET cccc
001B76  1                  ; Deletes definition named cccc from the dictionary with all entries
001B76  1                  ; physically following it.  In fig-FORTH, an error message will occur
001B76  1                  ; if the CURRENT and CONTEXT vocabularies are not currently the same.
001B76  1  79 15 40     Forget:	JSRD Tick		; get "name" text & look up in dictionary
001B79  1  9C           	LDAA ZW			; check Fence (assumes startup image is below user dictionary space)
001B7A  1  D1 70 6E     	LDBD VFence
001B7D  1  59           	SAB
001B7E  1  10 06        	BL @3
001B80  1  D0 00 15     	LDBL Err_InProtectedDictionary
001B83  1  79 0F 6A     	JSRD ErrorY
001B86  1               @3:
001B86  1               
001B86  1  9C           @3220:	LDAA ZW			; while addr < latest vocabulary word
001B87  1  D1 70 72     	LDBD VVoc_Link
001B8A  1  59           	SAB
001B8B  1  10 0F        	BL @3225
001B8D  1  79 17 00     	JSRD Forth
001B90  1  79 17 15     	JSRD Definitions
001B93  1  91 70 72     	LDAD VVoc_Link		;   unlink
001B96  1  98           	LDAA AW
001B97  1  B1 70 72     	STAD VVoc_Link
001B9A  1  73 EA        	JMPR @3220
001B9C  1               @3225:
001B9C  1               
001B9C  1  95 81        	LDAX ZW,ModBRPB,0	; pop forgotten word ptr
001B9E  1  5C           	XAY
001B9F  1  31 62        	DCR YW,3		; point at flags & length byte
001BA1  1               
001BA1  1  3A           	CLA
001BA2  1  8B           	LDABA YW		; fix VDP
001BA3  1  C0 1F        	LDBBL ha_length
001BA5  1  5A           	NAB
001BA6  1               ;	cmp VWidth		;   name truncated?
001BA6  1               
001BA6  1  51 62        	SUB BW,YW
001BA8  1  31 20        	DCR BW,1		;  -1 for junk name length count
001BAA  1  F1 70 70     	STBD VDP
001BAD  1               
001BAD  1  95 68 01     	LDAX YW,ModNBRB,1	; fix dictionary
001BB0  1  D1 70 72     	LDBD VVoc_Link
001BB3  1  B5 28 FE     	STAX BW,ModNBRB,$fe
001BB6  1               
001BB6  1  09           	RSR
001BB7  1               
001BB7  1               
001BB7  1               	.if 0
001BB7  1                FHdr 'Marker',0 ; ( "<spaces>name" -- )
001BB7  1                  ;   Skip leading space delimiters. Parse name delimited by a spac'e.
001BB7  1                  ;   Create a definition for name with the execution semantics defined below.
001BB7  1                  ; name Execution:
001BB7  1                  ;   ( -- )
001BB7  1                  ;   Restore all dictionary allocation and search order pointers to the state they had just prior to the definition of name.
001BB7  1                  ;   Remove the definition of name and all subsequent definitions. Restoration of any structures still existing that could refer to deleted definitions or deallocated data space is not necessarily provided. No other contextual information such as numeric base is affected.
001BB7  1               Marker:	JSRD Abort ;???
001BB7  1               	.endif
001BB7  1               
001BB7  1               
001BB7  1               	.if 0
001BB7  1                FHdr 'TraverseE-WordList',0 ; ( i * x xt wid -- j * x )
001BB7  1                  ; Remove wid and xt from the stack. Execute xt once for every word in the wordlist wid, passing the name token nt of the word to xt,
001BB7  1                  ; until the wordlist is exhausted or until xt returns false.
001BB7  1                  ;
001BB7  1                  ; The invoked xt has the stack effect ( k * x nt -- l * x flag ).
001BB7  1                  ;
001BB7  1                  ; If flag is true, TRAVERSE-WORDLIST will continue with the next name, otherwise it will return.
001BB7  1                  ; TRAVERSE-WORDLIST does not put any items other than nt on the stack when calling xt,
001BB7  1                  ; so that xt can access and modify the rest of the stack.
001BB7  1                  ;
001BB7  1                  ; TRAVERSE-WORDLIST may visit words in any order, with one exception: words with the same name are called in the order
001BB7  1                  ; newest-to-oldest (possibly with other words in between).
001BB7  1                  ;
001BB7  1                  ; An ambiguous condition exists if words are added to or deleted from the wordlist wid during the execution of TRAVERSE-WORDLIST.
001BB7  1                  ; https://forth-standard.org/standard/tools/TRAVERSE-WORDLIST
001BB7  1               Traverse_WordList:
001BB7  1               	JSRD Abort ;???
001BB7  1               	.endif
001BB7  1               
001BB7  1               
001BB7  1  4C 69 73 74   FHdr 'List',0 ; ( n -- )  Display the ASCII text of screen n on the selected output device.
001BBB  1  04 1B 76     
001BBE  1                  ; SCR contains the screen number during and after this process.
001BBE  1                  ; https://forth-standard.org/standard/block/LIST
001BBE  1  79 0D 4A     List:	JSRD Decimal	; Base=decimal
001BC1  1  79 0C EC     	JSRD CR		; newline
001BC4  1  9C           	LDAA ZW		; Scr=n
001BC5  1  B1 70 7A     	STAD VScr
001BC8  1  79 14 39     	JSRD PDotQuote	; type literal
001BCB  1  06 53 43 52  	.byte 6,'SCR # '
001BCF  1  20 23 20     
001BD2  1  79 0E 62     	JSRD Dot	; type n
001BD5  1  3A           	CLA		; for line=0 to 16
001BD6  1  B5 A2        @3620:	STAX SW,ModBMRB,0 ;   save line#
001BD8  1  79 0C EC     	JSRD CR		;   newline
001BDB  1  79 03 A6     	JSRD RAt	;   type current line# in 3 chars
001BDE  1  79 0A 78     	JSRD Three
001BE1  1  79 0E 39     	JSRD DotR
001BE4  1  79 0D 01     	JSRD Space	;   type a space
001BE7  1  79 03 A6     	JSRD RAt	;   type the line
001BEA  1  91 70 7A     	LDAD VScr
001BED  1  B5 82        	STAX ZW,ModBMRB,0
001BEF  1  79 19 8B     	JSRD DotLine
001BF2  1  95 A1        	LDAX SW,ModBRPB,0 ;  next line
001BF4  1  38           	INA
001BF5  1  C0 10        	LDBBL 16
001BF7  1  49           	SABB
001BF8  1  15 DC        	BNZ @3620
001BFA  1  71 0C EC     	JMPD CR		; newline, & return
001BFD  1               
001BFD  1               
001BFD  1  49 6E 64 65   FHdr 'Index',0 ; ( from to -- )  Print the first line of each screen over the range from, to.
001C01  1  78 05 1B BE  
001C05  1                  ; This is used to view the comment lines of an area on disc screens.
001C05  1  79 0C EC     Index:	JSRD CR		; newline
001C08  1  9C           	LDAA ZW		; to++
001C09  1  38           	INA
001C0A  1  BC           	STAA ZW
001C0B  1               @3647:			; for screen#=from to to
001C0B  1  79 0C EC     	JSRD CR		;   newline
001C0E  1  79 02 CC     	JSRD Over	;   type screen# in 3 chars
001C11  1  79 0A 78     	JSRD Three
001C14  1  79 0E 39     	JSRD DotR
001C17  1  79 0D 01     	JSRD Space	;   type space
001C1A  1  79 0A 5B     	JSRD Zero	;   type 1st line of screen
001C1D  1  79 02 CC     	JSRD Over
001C20  1  79 19 8B     	JSRD DotLine
001C23  1  79 0C C1     	JSRD QTerminalA	;   console key available?
001C26  1  15 0B        	BNZ @break
001C28  1  95 88 02     	LDAX ZW,ModNBRB,2 ;  next
001C2B  1  38           	INA
001C2C  1  B5 88 02     	STAX ZW,ModNBRB,2
001C2F  1  DC           	LDBA ZW
001C30  1  59           	SAB
001C31  1  10 D8        	BL @3647
001C33  1  30 83        @break:	INR ZW,4	; drop parameters
001C35  1  80 0C        	LDABL $0C	; form feed for printer, & return
001C37  1  71 0C D7     	JMPD EmitA
001C3A  1               
001C3A  1               
001C3A  1  54 72 69 61   FHdr 'Triad',0 ; ( scr -- )
001C3E  1  64 05 1C 05  
001C42  1                  ; Display on the selected output device the three screens which include that numbered
001C42  1                  ; scr, beginning with a screen evenly divisable by 3.  Output is suitable for source text
001C42  1                  ; records, and includes a reference line at the bottom taken from line 15 of screen 4.
001C42  1  79 0A 78     Triad:	JSRD Three	; floor scr to multiple of 3
001C45  1  79 07 B4     	JSRD Slash
001C48  1  79 0A 78     	JSRD Three
001C4B  1  79 07 96     	JSRD Star
001C4E  1  79 0A 78     	JSRD Three	; end=scr+3
001C51  1  79 02 CC     	JSRD Over
001C54  1  79 04 DD     	JSRD Plus
001C57  1  79 02 A1     	JSRD Swap
001C5A  1  79 12 2C     	JSRD PDo		; (Do)
001C5D  1               @3681:
001C5D  1  79 0C EC     	JSRD CR		;   newline
001C60  1  79 12 40     	JSRD I		;   type screen I
001C63  1  79 1B BE     	JSRD List
001C66  1  79 12 66     	JSRD PLoop	;  (Loop)
001C69  1  16 F2        	BM @3681
001C6B  1  79 0C EC     	JSRD CR		; newline
001C6E  1  90 00 0F     	LDAL Err_TriadFooter ; type message $F
001C71  1  79 1A C4     	JSRD MessageA
001C74  1  79 0C EC     	JSRD CR		; newline
001C77  1  80 0C        	LDABL $0C	; form feed for printer, & return
001C79  1  71 0C D7     	JMPD EmitA
001C7C  1               
001C7C  1               
001C7C  1               	.if 0
001C7C  1               
001C7C  1                FHdr 'Parse-Name',0 ; ( "<spaces>name<space>" -- c-addr u )
001C7C  1                  ; Skip leading space delimiters. Parse name delimited by a space.
001C7C  1                  ;
001C7C  1                  ; c-addr is the address of the selected string within the input buffer and u is its length in characters.
001C7C  1                  ; If the parse area is empty or contains only white space, the resulting string has length zero.
001C7C  1                  ; https://forth-standard.org/standard/core/PARSE-NAME
001C7C  1               
001C7C  1               
001C7C  1                FHdr 'Parse',0 ; ( char "ccc<char>" -- c-addr u )  Parse ccc delimited by the delimiter char.
001C7C  1                  ;
001C7C  1                  ; c-addr is the address (within the input buffer) and u is the length of the parsed string.
001C7C  1                  ; If the parse area was empty, the resulting string has a zero length.
001C7C  1                  ; https://forth-standard.org/standard/core/PARSE
001C7C  1               
001C7C  1               	.endif
001C7C  1               
001C7C  1               
001C7C  1  56 4C 69 73   FHdr 'VList',0 ; ( -- )  FIG alias
001C80  1  74 05 1C 42  
001C84  1  73 08        	JMPR Words
001C86  1               
001C86  1               
001C86  1  57 6F 72 64   FHdr 'Words',0 ; ( -- )  List the names of the definitions in the context vocabulary.
001C8A  1  73 05 1C 84  
001C8E  1                  ; https://forth-standard.org/standard/tools/WORDS
001C8E  1  92 70 7E     Words:	LDAI VContext	; start at head of dictionary in Context vocabulary
001C91  1  B5 82        	STAX ZW,ModBMRB,0
001C93  1  73 09        	JMPR @3710
001C95  1               
001C95  1  91 70 78     @3706:	LDAD VOut	; out of screen width?
001C98  1  D1 0A 91     	LDBD CSlashL+1
001C9B  1  59           	SAB
001C9C  1  11 07        	BNL @3716
001C9E  1  79 0C EC     @3710:	JSRD CR		;   newline
001CA1  1  3A           	CLA
001CA2  1  B1 70 78     	STAD VOut	;   Out=0
001CA5  1               @3716:
001CA5  1  79 02 E9     	JSRD Dup	; type name
001CA8  1  79 15 AC     	JSRD IdDot
001CAB  1  79 0D 01     	JSRD Space	; type space
001CAE  1  79 0C C1     	JSRD QTerminalA	; terminal input char?
001CB1  1  15 07        	BNZ @9
001CB3  1  9C           	LDAA ZW		; goto next dictionary entry
001CB4  1  95 08 FE     	LDAX AW,ModNBRB,$fe
001CB7  1  BC           	STAA ZW
001CB8  1  15 DB        	BNZ @3706	; end of dictionary?
001CBA  1  30 81        @9:	INR ZW,2	; drop addr
001CBC  1  09           	RSR		; return
001CBD  1               
001CBD  1               
001CBD  1  42 79 65 03  	FHdr 'Bye',0 ; ( - )  Exit to the system monitor, leaving a re-entry to Forth, if possible.
001CC1  1  1C 8E        
001CC3  1                  ; https://forth-standard.org/standard/tools/BYE
001CC3  1               Bye:
001CC3  1  00           	HLT		; stop the simulator
001CC4  1  09           	RSR		; return
001CC5  1               
001CC5  1               
001CC5  1               ;----------------------------------------------------------------------
001CC5  1               ; Additional words
001CC5  1               
001CC5  1               
001CC5  1  2E 53 02 1C   FHdr '.S',0 ; ( ... -- ... ) non-destructive param stack print
001CC9  1  C3           
001CCA  1                  ; https://forth-standard.org/standard/tools/DotS
001CCA  1  91 70 64     DotS:	LDAD VS0		;start at top-of-stack
001CCD  1  73 0B        	JMPR @8
001CCF  1               
001CCF  1  D5 02        @1:	LDBX AW,ModBMRB,0	; get next cell value
001CD1  1  B5 A2        	STAX SW,ModBMRB,0	; save ptr
001CD3  1  F5 82        	STBX ZW,ModBMRB,0	; print value
001CD5  1  79 0E 62     	JSRD Dot
001CD8  1  95 A1        	LDAX SW,ModBRPB,0	; restore ptr
001CDA  1  55 82        @8:	XFR BW,ZW		; done?
001CDC  1  59           	SAB
001CDD  1  15 F0        	BNZ @1
001CDF  1               
001CDF  1  09           	RSR
001CE0  1               
001CE0  1               
001CE0  1               ; FHdr 'EX1',0 ; ( n -- )  type 1 hex digit
001CE0  1  95 81        EX1:	LDAX ZW,ModBRPB,0	; pop n
001CE2  1  D0 00 0F     EX1A:	LDBL $f			; get lo 4 bits
001CE5  1  52 20        	ANDC AW,BW
001CE7  1  C0 0A        	LDBBL 10		; convert to ASCII char
001CE9  1  49           	SABB
001CEA  1  11 04        	BNL @3
001CEC  1  C0 07        	LDBBL 7
001CEE  1  40 31        	ADDB AL,BL
001CF0  1  C0 30        @3:	LDBBL '0'
001CF2  1  40 31        	ADDB AL,BL
001CF4  1  71 0C D7     	JMPD EmitA		; type, & return
001CF7  1               
001CF7  1               
001CF7  1  45 58 32 03   FHdr 'EX2',0 ; ( n -- )  type 2 hex digits
001CFB  1  1C CA        
001CFD  1  95 81        EX2:	LDAX ZW,ModBRPB,0
001CFF  1  B5 82        EX2A:	STAX ZW,ModBMRB,0
001D01  1  34 03        	SRR AW,4
001D03  1  7B DD        	JSRR EX1A
001D05  1  73 D9        	JMPR EX1
001D07  1               
001D07  1               
001D07  1  45 58 34 03   FHdr 'EX4',0 ; ( n -- ) type 4 hex digits
001D0B  1  1C FD        
001D0D  1  8C           EX4:	LDABA ZW		; type hi byte
001D0E  1  7B EF        	JSRR EX2A
001D10  1  73 EB        	JMPR EX2		; type lo byte, & return
001D12  1               
001D12  1  B5 82        EX4A:	STAX ZW,ModBMRB,0
001D14  1  73 F7        	JMPR EX4
001D16  1               
001D16  1               
001D16  1  45 58 38 03   FHdr 'EX8',0 ; ( d -- ) type 8 hex digits
001D1A  1  1D 0D        
001D1C  1  7B EF        EX8:	JSRR EX4		; type hi word
001D1E  1  73 ED        	JMPR EX4		; type lo word, & return
001D20  1               
001D20  1               
001D20  1  44 75 6D 70   FHdr 'Dump',0 ; ( adr len -- )  Dump memory range
001D24  1  04 1D 1C     
001D27  1                  ; https://forth-standard.org/standard/tools/DUMP
001D27  1               Dump:
001D27  1               @11:				; begin
001D27  1  79 0C EC     	JSRD CR			;   newline
001D2A  1  79 02 CC     	JSRD Over		;   type addr
001D2D  1  7B DE        	JSRR EX4
001D2F  1  C0 10        	LDBBL 16		;   for each byte in line
001D31  1  E5 A2        @21:	STBBX SW,ModBMRB,0
001D33  1  79 0D 01     	JSRD Space
001D36  1  D5 88 02     	LDBX ZW,ModNBRB,2	;     get byte
001D39  1  85 21        	LDABX BW,ModBRPB,0
001D3B  1  F5 88 02     	STBX ZW,ModNBRB,2
001D3E  1  7B BF        	JSRR EX2A		;     type byte
001D40  1  C5 A1        	LDBBX SW,ModBRPB,0
001D42  1  9C           	LDAA ZW			;     decrement len
001D43  1  39           	DCA
001D44  1  BC           	STAA ZW
001D45  1  14 06        	BZ @end
001D47  1  21 30        	DCRB BL			;    next byte in line
001D49  1  15 E6        	BNZ @21
001D4B  1  73 DA        	JMPR @11		;  next line
001D4D  1               
001D4D  1  30 83        @end:	INR ZW,4		; drop len & adr
001D4F  1  71 0D 01     	JMPD Space
001D52  1               
001D52  1               
001D52  1  53 65 65 4C   FHdr 'SeeLatest',0 ; ( -- )  dump latest word's code
001D56  1  61 74 65 73  
001D5A  1  74 09 1D 27  
001D5E  1               SeeLatest:
001D5E  1  D2 70 80     	LDBI VCurrent		; start of last word
001D61  1  F5 82        	STBX ZW,ModBMRB,0
001D63  1  91 70 70     	LDAD VDP		; length
001D66  1  59           	SAB
001D67  1  F5 82        	STBX ZW,ModBMRB,0
001D69  1  73 BC        	JMPR Dump		; dump, & return
001D6B  1               
001D6B  1               
001D6B  1               ; FHdr 'CC@',0 ; ( -- ud )  Get emulator cycle counter
001D6B  1               ;CCAt:	cop?? $f5	; get simulator cycle count in BA
001D6B  1               ;	STAX ZW,ModBMRB,0 ; push it
001D6B  1               ;	STBX ZW,ModBMRB,0
001D6B  1               ;	RSR
001D6B  1               
001D6B  1               
001D6B  1               
001D6B  1               	.if 0
001D6B  1                FHdr 'Modify',0 ; ( adr -- )  \ Centurion TOS-like memory modify
001D6B  1               	JSRD Abort
001D6B  1               @l:
001D6B  1               	JSRD Space
001D6B  1               	LDABX ZW,ModABRB,0	; type existing value
001D6B  1               	JSRD EX2A
001D6B  1               
001D6B  1               	CLR ZW,0    ; get the byte
001D6B  1               	JSRR @HKey
001D6B  1               	BL @9
001D6B  1               	JSRR @HKey
001D6B  1               	BL @9
001D6B  1               
001D6B  1               
001D6B  1               
001D6B  1               
001D6B  1               
001D6B  1               
001D6B  1               
001D6B  1               
001D6B  1               @HKey:	PUSH YW,2
001D6B  1               	JSRD KeyA
001D6B  1               	POP YW,2
001D6B  1               	LDBBL 'A'		; alpha?
001D6B  1               	SABB
001D6B  1               	BNL @HKNum
001D6B  1               	LDABL $5f		; uppercase
001D6B  1               	NABB
001D6B  1               	LDABL 10
001D6B  1               	ADDB AL,BL
001D6B  1               	LDBBL 16
001D6B  1               	SABB
001D6B  1               	BNL @HKOK
001D6B  1               @HKErr:	SL
001D6B  1               	RSR
001D6B  1               
001D6B  1               @HKOK:	SHL YW,4
001D6B  1               	ORIB YL,BL
001D6B  1               	RL
001D6B  1               	RSR
001D6B  1               
001D6B  1               @HkNum:	LDBBL '0'
001D6B  1               	SABB
001D6B  1               	BNL @HKErr
001D6B  1               	XFRB AL,BL
001D6B  1               	LDABL 10
001D6B  1               	SABB
001D6B  1               	BNL @HKOK
001D6B  1               	JMPR @HKErr
001D6B  1               
001D6B  1               	.endif
001D6B  1               
001D6B  1               ;-----------------------------------------------------------------------------
001D6B  1               ; CCDP interface
001D6B  1               ; https://github.com/tergav17/CCDP
001D6B  1               
001D6B  1               ; status
001D6B  1               ;	0: Successful, 0 bytes returned
001D6B  1               ;	1: Successful, 16 bytes returned
001D6B  1               ;	2: Successful, 256 bytes returned
001D6B  1               ;	254: Execution Failure, 0 bytes returned
001D6B  1               ;	255: Communication Failure, 0 bytes returned
001D6B  1               
001D6B  1               combuf		= $1C0  ; command line text
001D6B  1               
001D6B  1  53 79 73 5F   FHdr 'Sys_Done',0 ; ( -- )  Returns to the CCDP command prompt
001D6F  1  44 6F 6E 65  
001D73  1  08 1D 5E     
001D76  1  71 01 00     	JMPD $100	; return to CCDP (also just RSR)
001D79  1               
001D79  1  54 74 79 5F   FHdr 'Tty_PutC',0 ; ( c -- )  Puts a character on the terminal
001D7D  1  50 75 74 43  
001D81  1  08 1D 76     
001D84  1               Tty_PutC:
001D84  1  D5 81        	LDBX ZW,ModBRPB,0	; pop c
001D86  1               Tty_PutC_A:
001D86  1  71 01 03     	JMPD $103
001D89  1               
001D89  1  54 74 79 5F   FHdr 'Tty_PutB',0 ; ( n -- )  Puts a byte in hex on the terminal
001D8D  1  50 75 74 42  
001D91  1  08 1D 84     
001D94  1               Tty_PutB:
001D94  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n
001D96  1  71 01 06     	JMPD $106
001D99  1               
001D99  1  54 74 79 5F   FHdr 'Tty_PutW',0 ; ( n -- )  Puts a word in hex on the terminal
001D9D  1  50 75 74 57  
001DA1  1  08 1D 94     
001DA4  1               Tty_PutW:
001DA4  1  D5 81        	LDBX ZW,ModBRPB,0	; pop n
001DA6  1  71 01 09     	JMPD $109
001DA9  1               
001DA9  1  54 74 79 5F   FHdr 'Tty_PutS',0 ; ( adr -- )  Puts a string on the terminal (zero terminated)
001DAD  1  50 75 74 53  
001DB1  1  08 1D A4     
001DB4  1               Tty_PutS:
001DB4  1  D5 81        	LDBX ZW,ModBRPB,0	; pop adr
001DB6  1  71 01 0C     	JMPD $10C	; type .asciz string pointed to by BW
001DB9  1               
001DB9  1  54 74 79 5F   FHdr 'Tty_GetC',0 ; ( -- c )  Gets a character from the terminal
001DBD  1  47 65 74 43  
001DC1  1  08 1D B4     
001DC4  1               Tty_GetC_A = $10f
001DC4  1               Tty_GetC:
001DC4  1  79 01 0F     	JSRD Tty_GetC_A
001DC7  1  22 00        TtPs1:	CLRB AH
001DC9  1  B5 82        	STAX ZW,ModBMRB,0	; push c
001DCB  1  09           	RSR
001DCC  1               
001DCC  1  54 74 79 5F   FHdr 'Tty_GetS',0 ; ( adr len -- )  Gets a line of characters from the terminal
001DD0  1  47 65 74 53  
001DD4  1  08 1D C4     
001DD7  1               Tty_GetS:
001DD7  1  95 81        	LDAX ZW,ModBRPB,0	; pop len
001DD9  1  39           	DCA
001DDA  1  D5 81        	LDBX ZW,ModBRPB,0	; pop adr
001DDC  1  71 01 12     	JMPD $112
001DDF  1               
001DDF  1  54 74 79 5F   FHdr 'Tty_Next',0 ; ( -- f )  Is there is a character to read?
001DE3  1  4E 65 78 74  
001DE7  1  08 1D D7     
001DEA  1               Tty_Next_A = $12d
001DEA  1               Tty_Next:
001DEA  1  79 01 2D     	JSRD Tty_Next_A
001DED  1  73 D8        	JMPR TtPs1		; push f
001DEF  1               
001DEF  1  46 73 5F 4F   FHdr 'Fs_Open',0 ; ( fn_addr -- status )  Opens up a file for use, any currently opened file is closed
001DF3  1  70 65 6E 07  
001DF7  1  1D EA        
001DF9  1               Fs_Open:
001DF9  1  DC           	LDBA ZW			; get fn_addr
001DFA  1  79 01 15     	JSRD $115
001DFD  1  73 54        	JMPR FsSt1		; store status
001DFF  1               
001DFF  1  46 73 5F 43   FHdr 'Fs_Close',0 ; ( -- status )
001E03  1  6C 6F 73 65  
001E07  1  08 1D F9     
001E0A  1               Fs_Close:
001E0A  1  79 01 18     	JSRD $118
001E0D  1  73 B8        	JMPR TtPs1		; push status
001E0F  1               
001E0F  1  46 73 5F 4D   FHdr 'Fs_Make',0 ; ( fn_addr -- status )  Makes a new file, but does not open it
001E13  1  61 6B 65 07  
001E17  1  1E 0A        
001E19  1               Fs_Make:
001E19  1  DC           	LDBA ZW			; get fn_addr
001E1A  1  79 01 1B     	JSRD $11B
001E1D  1  73 34        	JMPR FsSt1		; store status
001E1F  1               
001E1F  1  46 73 5F 44   FHdr 'Fs_Delete',0 ; ( fn_addr -- status )  Deletes an existing file
001E23  1  65 6C 65 74  
001E27  1  65 09 1E 19  
001E2B  1               Fs_Delete:
001E2B  1  DC           	LDBA ZW			; get fn_addr
001E2C  1  79 01 1E     	JSRD $11E
001E2F  1  73 22        	JMPR FsSt1		; store status
001E31  1               
001E31  1  46 73 5F 4C   FHdr 'Fs_List',0 ; ( n_entry buf_addr -- status )  Lists a filename and size from the directory
001E35  1  69 73 74 07  
001E39  1  1E 2B        
001E3B  1               Fs_List:
001E3B  1  D5 81        	LDBX ZW,ModBRPB,0	; pop buf_adddr
001E3D  1  9C           	LDAA ZW			; get n_entry
001E3E  1  79 01 21     	JSRD $121
001E41  1  73 10        	JMPR FsSt1		; store status
001E43  1               
001E43  1  46 73 5F 52   FHdr 'Fs_Read',0 ; ( buf_addr block -- status )  Reads a block from a file
001E47  1  65 61 64 07  
001E4B  1  1E 3B        
001E4D  1               Fs_Read:
001E4D  1  95 81        	LDAX ZW,ModBRPB,0	; pop block
001E4F  1  DC           	LDBA ZW			; get buf_addr
001E50  1  79 01 24     	JSRD $124
001E53  1  22 00        FsSt1:	CLRB AH			; store status
001E55  1  BC           	STAA ZW
001E56  1  09           	RSR
001E57  1               
001E57  1  46 73 5F 57   FHdr 'Fs_Write',0 ; ( buf_addr block -- status )  Writes a block to a file
001E5B  1  72 69 74 65  
001E5F  1  08 1E 4D     
001E62  1               Fs_Write:
001E62  1  95 81        	LDAX ZW,ModBRPB,0	; pop block
001E64  1  DC           	LDBA ZW			; get buf_addr
001E65  1  79 01 27     	JSRD $127
001E68  1  73 E9        	JMPR FsSt1
001E6A  1               
001E6A  1  47 65 6E 5F   FHdr 'Gen_HToL',0 ; ( ascii -- u )  Converts a hex number in ASCII into a value
001E6E  1  48 54 6F 4C  
001E72  1  08 1E 62     
001E75  1               Gen_HToL:
001E75  1  DC           	LDBA ZW		; get ascii
001E76  1  79 01 2A     	JSRD $12A
001E79  1  73 D8        	JMPR FsSt1	; store u
001E7B  1               
001E7B  1               ;-----------------------------------------------------------------------------
001E7B  1               ; Assembler & disassembler
001E7B  1               
001E7B  1               
001E7B  1  53 79 6D 03   FHdr 'Sym',0 ; ( adr -- )  Type symbolic version of any adr
001E7F  1  1E 75        
001E81  1  95 81        Sym:	LDAX ZW,ModBRPB,0
001E83  1  B5 A2        SymA:	STAX SW,ModBMRB,0
001E85  1  31 AB        	DCR SW,@adr		; alloc work area
001E87  1               @adr	 = 12 ; adr to convert
001E87  1               @voc	 = 10 ;	adr of vocabulary
001E87  1               @cur	 =  8 ; adr of current word (nfa, cfa)
001E87  1               @off	 =  6 ; offset this time
001E87  1               @bestadr =  4 ; adr of best word (nfa, cfa)
001E87  1               @bestoff =  2 ; offset from best word
001E87  1               @type	 =  0 ; type of word
001E87  1               
001E87  1  90 FF FF     	LDAL .loword(-1)
001E8A  1  B5 A8 02     	STAX SW,ModNBRB,@bestoff
001E8D  1               
001E8D  1  91 70 72     	LDAD VVoc_Link		;for each vocabulary
001E90  1  B5 A8 0A     @71:	STAX SW,ModNBRB,@voc
001E93  1               
001E93  1  95 08 FE     	LDAX AW,ModNBRB,$fe	;  for each word in the vocabulary
001E96  1  B5 A8 08     @01:	STAX SW,ModNBRB,@cur
001E99  1  14 25        	BZ @09
001E9B  1  5C           	XAY
001E9C  1               
001E9C  1  D5 A8 0C     	LDBX SW,ModNBRB,@adr	;    check current word
001E9F  1  55 60        	XFR AW,YW
001EA1  1  51 20        	SUB AW,BW
001EA3  1  D5 A8 02     	LDBX SW,ModNBRB,@bestoff
001EA6  1  59           	SAB
001EA7  1  10 0C        	BL @04
001EA9  1  B5 A8 02     	STAX SW,ModNBRB,@bestoff
001EAC  1  55 62        	XFR BW,YW
001EAE  1  F5 A8 04     	STBX SW,ModNBRB,@bestadr
001EB1  1  3A           	CLA
001EB2  1  B5 A8 00     	STAX SW,ModNBRB,@type
001EB5  1               @04:
001EB5  1               
001EB5  1               ;	LDABA YW		;  a special kind of word?
001EB5  1               ;	LDBBL $79		;    (jsrd)
001EB5  1               ;	SABB
001EB5  1               ;	BZ @21
001EB5  1               ;	LDBBL $90		;    (ldal)
001EB5  1               ;	SABB
001EB5  1               ;	BNZ @06
001EB5  1               
001EB5  1               ;	LDAX YW,ModNBRB,3	;  a literal?
001EB5  1               ;	HLT ;LDBL $??		;    STAX ZW,ModBMRB,0
001EB5  1               ;	BNZ @06
001EB5  1               ;	LDABX YW,ModNBRB,5
001EB5  1               ;	LDBBL $09		;    RSR
001EB5  1               ;	SABB
001EB5  1               ;	BNZ @06
001EB5  1               ; HLT ;??	lda @adr		;    check literal value
001EB5  1               ;	sec
001EB5  1               ;	sbc a:1,y
001EB5  1               ;	sec
001EB5  1               ;	bra @27
001EB5  1               
001EB5  1               ;@21:	rep #pm			;  a variable?
001EB5  1               ;	lda a:1,y
001EB5  1               ;	cmp #PCreate
001EB5  1               ;	bne @06
001EB5  1               ;	lda @adr
001EB5  1               ;	sec
001EB5  1               ;	sbc @cur
001EB5  1               ;	dec a
001EB5  1               ;	dec a
001EB5  1               ;	dec a
001EB5  1               
001EB5  1               ;@27:	cmp @bestoff
001EB5  1               ;	bcs @06
001EB5  1               ;	sta @bestoff
001EB5  1               ;	sty @bestadr
001EB5  1               ;	lda #$8000
001EB5  1               ;	sta @type
001EB5  1               
001EB5  1  95 68 FE     @06:	LDAX YW,ModNBRB,$fe	;  next word
001EB8  1  15 DC        	BNZ @01
001EBA  1  D5 A8 0A     	LDBX SW,ModNBRB,@voc	; next vocabulary
001EBD  1  99           	LDAA BW
001EBE  1  15 D0        	BNZ @71
001EC0  1               @09:
001EC0  1               ;-------------------
001EC0  1  95 A8 02     	LDAX SW,ModNBRB,@bestoff
001EC3  1  45 00        	XFRB AH,AH
001EC5  1  15 24        	BNZ @69
001EC7  1               
001EC7  1  79 14 39     	JSRD PDotQuote
001ECA  1  03 20 7B 20  	.byte 3," { "
001ECE  1               
001ECE  1               ;	bit @type
001ECE  1               ;	bpl @8
001ECE  1               ;	JSRD DotQuoteR
001ECE  1               ;	.byte 2,"' "
001ECE  1               ;@8:
001ECE  1  95 A8 04     	LDAX SW,ModNBRB,@bestadr ; type name
001ED1  1  B5 82        	STAX ZW,ModBMRB,0
001ED3  1  79 15 AC     	JSRD IdDot
001ED6  1               
001ED6  1  95 A8 02     	LDAX SW,ModNBRB,@bestoff
001ED9  1  14 0B        	BZ @7
001EDB  1  80 2B        	LDABL '+'
001EDD  1  79 0C D7     	JSRD EmitA
001EE0  1  95 A8 02     	LDAX SW,ModNBRB,@bestoff
001EE3  1  79 1D 12     	JSRD EX4A
001EE6  1               @7:
001EE6  1  79 14 39     	JSRD PDotQuote
001EE9  1  01 7D        	.byte 1,"}"
001EEB  1               @69:
001EEB  1               
001EEB  1  30 AD        	INR SW,@adr+2		; rdrop work area
001EED  1  09           	RSR
001EEE  1               
001EEE  1               
001EEE  1               	.if 0
001EEE  1               
001EEE  1                FHdr "See",0 ; ( (spaces)name -- )	; https://forth-standard.org/standard/tools/SEE
001EEE  1                  ; Display a disassembly of the named words definition.
001EEE  1               See:	JSRD Tick
001EEE  1               	JSRR DisAsm
001EEE  1               	INR ZW,2
001EEE  1               	RSR
001EEE  1               
001EEE  1               
001EEE  1                FHdr "SeeLatest",0 ; ( -- ) ; disassemble latest word
001EEE  1               SeeLatest:
001EEE  1               	LDAI VCurrrent
001EEE  1               	STAX ZW,ModBMRB,0
001EEE  1               @1:	JSRD Disasm1
001EEE  1               	LDAA ZW
001EEE  1               	LDBD MPtr
001EEE  1               	SAB
001EEE  1               	BNL @1
001EEE  1               	INR ZW,2
001EEE  1               	JSRD CR
001EEE  1               	JMPD CR
001EEE  1               
001EEE  1               
001EEE  1                FHdr "DisAsm",0 ; ( adr -- adr )	Disasemble a run of code
001EEE  1               DisAsm:	LDAL 100
001EEE  1               @2:	STAX SW,ModBMRB,0	; Y=adr
001EEE  1               	LDAA ZW
001EEE  1               	XAY
001EEE  1               	LDABA AW		; get opcode
001EEE  1               	LDBBL $71		;  JMPD
001EEE  1               	SABB
001EEE  1               	BZ @jmp
001EEE  1               	LDBBL $73		;  JMPR
001EEE  1               	SAB
001EEE  1               	BZ @4
001EEE  1               	LDBBL $09		;  RSR
001EEE  1               	SABB
001EEE  1               	BZ @4
001EEE  1               ;	LDBBL $79		;  JSRD
001EEE  1               ;	SABB
001EEE  1               ;	BNZ @5
001EEE  1               ;	LDAX YW,ModNBRB,1
001EEE  1               ;	LDBL FConsR
001EEE  1               ;	SAB
001EEE  1               ;	BZ @4
001EEE  1               ;	jsr PushAddrQ
001EEE  1               ;	bne @5
001EEE  1               @4:	LDBBL 1
001EEE  1               	STBA SW
001EEE  1               @5:
001EEE  1               	JSRD ADsm
001EEE  1               ;	JSRD dsn
001EEE  1               	LDAX SW,ModBRPB,0
001EEE  1               	DCA
001EEE  1               	BNZ @2
001EEE  1               	JMPD CR
001EEE  1               
001EEE  1               @jmp:	LDAX YW,ModNBRB,$fe
001EEE  1               	LDBL $fff0
001EEE  1               	NAB
001EEE  1               	LDABL $1003
001EEE  1               	SAB
001EEE  1               	BNZ @4
001EEE  1               	JMPR @5
001EEE  1               
001EEE  1               ;---------------------------------------------------------------------------
001EEE  1               
001EEE  1                FHdr "Disasm1",0 ; ( addr-1 -- addr-2 )  Disassemble 1 CPU6 instruction
001EEE  1                  ; Using self contained tables
001EEE  1               Disasm1:
001EEE  1               	JSRD CR			; new line
001EEE  1               	JSRD PDotQuote		; tab over hex part
001EEE  1               	.byte 2,9,9
001EEE  1               	LDBA ZW			; save starting addr
001EEE  1               	STBX SW,ModBMRB,0
001EEE  1               
001EEE  1               	JSRD @Fetch1		; fetch opcode
001EEE  1               	SLA			; get @Code table entry
001EEE  1               	LDBL @Code
001EEE  1               	AAB
001EEE  1               	LDBA BW
001EEE  1               	STBX ZW,ModBMRB,0
001EEE  1               
001EEE  1               	CLA			;type opcode name
001EEE  1               	XFR AL,BH
001EEE  1               	LDBL @Mnemonics
001EEE  1               	AAB
001EEE  1               	JMPR @18
001EEE  1               @11:	STBX SW,ModBMRB,0
001EEE  1               	JSRD EmitA
001EEE  1               	LDBX SW,ModBMRB,0
001EEE  1               @18:	LDABX BW,ModBRPB,0
001EEE  1               	BNZ @11
001EEE  1               
001EEE  1               	JSRD Space
001EEE  1               
001EEE  1               	LDAX ZW,ModNBRB,1	; get format entry from @Code entry
001EEE  1               	CLRB AH
001EEE  1               	LDBL @Formats
001EEE  1               	AAB
001EEE  1               @FmtN2:	CLA			; get next format char
001EEE  1               	LDABX BW,ModBRPB,0
001EEE  1               	BZ @Fmt99
001EEE  1               	STBX ZW,ModBMRB,0
001EEE  1               	LDBBL $20		; a function?
001EEE  1               	SABB
001EEE  1               	BNL @FEmit
001EEE  1               
001EEE  1               	LDBL @Formats		; call format routine
001EEE  1               	AAB
001EEE  1               	JSRX BW,ModBRB,0
001EEE  1               @FmtN8:	LDBX ZW,ModBRPB,0	; get fmt ptr
001EEE  1               	JMPR @FmtN2
001EEE  1               
001EEE  1               @FEmit:	JSRD EmitA
001EEE  1               	JMPR @FmtN8
001EEE  1               
001EEE  1               @Fmt99:				; end of format string
001EEE  1               
001EEE  1               
001EEE  1                HLT ;	??pla		;discard opcode
001EEE  1               	JSRD PDotQuote	;to begin of line
001EEE  1               	.byte 1,$0d
001EEE  1               	LDAA ZW		;type addr
001EEE  1               	JSRD EX4A
001EEE  1               	JSRD Space
001EEE  1                HLT ;???	pla
001EEE  1               	ldy #5
001EEE  1               @22:	phy
001EEE  1               	pha
001EEE  1               	tay
001EEE  1               	lda a:0,y	;type bytes
001EEE  1               	jsr EX2A
001EEE  1               	pla
001EEE  1               	ply
001EEE  1               	dey
001EEE  1               	beq @28
001EEE  1               	ina
001EEE  1               	cmp 0,x
001EEE  1               	bcc @22
001EEE  1               @28:	rts ; jmp CR
001EEE  1               
001EEE  1               
001EEE  1               @Fetch1: ; fetch next byte
001EEE  1               	LDBA SW
001EEE  1               	CLA
001EEE  1               	LDABX BW,ModBRPB,0
001EEE  1               	STBA SW
001EEE  1               	RSB
001EEE  1               
001EEE  1               @Fetch2: ; fetch next word
001EEE  1               	LDBA SW
001EEE  1               	LDAX BW,ModBRPB,0
001EEE  1               	STBA SW
001EEE  1               	RSB
001EEE  1               
001EEE  1               
001EEE  1               @Formats:
001EEE  1               	.dbyt 0,@Fmt1,@Fmt2,@Fmt3
001EEE  1               	.dbyt @Fmt4,@Fmt5,@Fmt6,@Fmt7
001EEE  1               	.dbyt @Fmt8,@Fmt9,@Fmt10,@Fmt11
001EEE  1               	.dbyt @Fmt12,@Fmt13,@Fmt14
001EEE  1               
001EEE  1               @Fmt1: ; 1 byte literal
001EEE  1               	JSRD @Fetch1		; fetch a byte
001EEE  1               	JSRD EX2A
001EEE  1               	JMPD @FmtNext
001EEE  1               
001EEE  1               @Fmt2: ; 2 byte literal
001EEE  1               	JSRD @Fetch2		; fetch a word
001EEE  1               	JSRD EX4A
001EEE  1               	JMPD @FmtNext
001EEE  1               
001EEE  1               @Fmt3: ; 1byte relative
001EEE  1               	JSRD @Fetch1		; fetch a signed byte
001EEE  1               	XFRB AH,AL
001EEE  1               	SRR AW,8
001EEE  1               	AAB			; add to location
001EEE  1               	JSRD EX4A
001EEE  1               	JMPD @FmtNext
001EEE  1               
001EEE  1               @Fmt4: ; byte register
001EEE  1               	JSRD @Fetch1		; fetch a byte
001EEE  1               	STABX ZW,ModBMRB,0	; save a copy
001EEE  1               	JSRR @RegB		; do dest reg
001EEE  1               	LDABL ','
001EEE  1               	JSRD EmitA
001EEE  1               	LDAX ZW,ModBRPB,0	; do src reg
001EEE  1               	SLL AW,4
001EEE  1               	JSRD @RegB
001EEE  1               	JMPD @FmtNext
001EEE  1               
001EEE  1               @RegR:	STABX SW,ModBMRB,0	; save
001EEE  1               	SRA			; do register letter
001EEE  1               	LDAL 7
001EEE  1               	NAB
001EEE  1               	LDAL @RegRA
001EEE  1               	AAB
001EEE  1               	LDAA BW
001EEE  1               	JSRD EmitA
001EEE  1               	LDABX SW,ModBMRB,0	; do register part
001EEE  1               	RSR
001EEE  1               
001EEE  1               @RegRA:	.byte 'ABXYZSCP'
001EEE  1               
001EEE  1               @RegB:	JSRR @RegR
001EEE  1               	SRA
001EEE  1               	LDABL 'H'
001EEE  1               	BNL @RegB3
001EEE  1               	LDABL 'L'
001EEE  1               @RegB3:	JMPD EmitA
001EEE  1               
001EEE  1               @Fmt5: ; word register & constant+1
001EEE  1               	HLT ;???
001EEE  1               
001EEE  1               @Fmt6: ; word register & constant
001EEE  1               	HLT ;???
001EEE  1               
001EEE  1               @Fmt7: ; dest byte registers
001EEE  1               	HLT ;???
001EEE  1               
001EEE  1               @Fmt8: ; src byte register
001EEE  1               	HLT ;???
001EEE  1               
001EEE  1               @Fmt9: ; dest word register
001EEE  1               	HLT ;???
001EEE  1               
001EEE  1               @Fmt10: ; src word register
001EEE  1               	HLT ;???
001EEE  1               
001EEE  1               @Fmt11: ; word indexed
001EEE  1               	HLT ;???
001EEE  1               
001EEE  1               @Fmt12: ; byte indexed
001EEE  1               	HLT ;???
001EEE  1               
001EEE  1               @Fmt13: ; register in opcode
001EEE  1               	LDBA SW			; get opcode again
001EEE  1               	CLA
001EEE  1               	LDABX BW,ModBMRB,0
001EEE  1               	SLA
001EEE  1               	JSRD @RegR
001EEE  1                HLT ;???
001EEE  1               
001EEE  1               
001EEE  1               
001EEE  1               ; https://github.com/Nakazoto/CenturionComputer/wiki/Instructions
001EEE  1               
001EEE  1               
001EEE  1               ; Modifier	Note
001EEE  1               ;  0 ; (r)	Index
001EEE  1               ;  1 ; (r+)	Index; Index returned, incremented by ^
001EEE  1               ;  2 ; (-r)	Decrement and Index
001EEE  1               ;  4 ; @(r)	Index indirect
001EEE  1               ;  5 ; @(r+)	Index indirect; Index returned, incremented by ^
001EEE  1               ;  6 ; @(-r)	Decrement and index indirect
001EEE  1               ;  8 ; n(r)	Index with displacement
001EEE  1               ;  9 ; n(r+)	Index with displacement; Index returned, incremented by ^
001EEE  1               ; $A ; n(-r)	Decrement and index with displacement
001EEE  1               ; $C ; @n(r)	Index with displacement indirect
001EEE  1               ; $D ; @n(r+)	Index with displacement indirect, Index returned, incremented by ^
001EEE  1               ; $E ; @n(-r)	Decrement and index with displacement indirect
001EEE  1               
001EEE  1               @Inh:	.byte 0 ; inherent
001EEE  1               @Rel:	.byte " ",3 ; 8bit relative
001EEE  1               @RelInd: .byte " (",3,")",0 ; 8bit relative indirect
001EEE  1               @BReg:	.byte " ",4,0 ; byte register
001EEE  1               @WReg1:	.byte " ",5,0 ; word register & constant+1
001EEE  1               @WReg:	.byte " ",6,0 ; word register & constant
001EEE  1               @DRB:	.byte " ",7,",",8,0 ; src & dest byte registers
001EEE  1               @DRW:	.byte " ",9,",",10,0 ; src & dest word registers (& extensions)
001EEE  1               @LitW:	.byte " #",2,0 ; literal word
001EEE  1               @LitB:	.byte " #",1,0 ; literal byte
001EEE  1               @Direct: .byte " ",2,0 ; direct
001EEE  1               @Indirect: .byte " (",2,")",0 ; indirect
001EEE  1               @WX:	.byte " ",11,0 ; word indexed
001EEE  1               @BX:	.byte " ",12,0 ; byte indexed
001EEE  1               @A:	.byte " ",13,0 ; register in opcode
001EEE  1               
001EEE  1               
001EEE  1               @Mnemonics:
001EEE  1               @mIll:	.byte "??",0
001EEE  1               @mHlt:	.byte "HLT",0
001EEE  1               @mNop:	.byte "NOP",0
001EEE  1               @mSF:	.byte "SF",0
001EEE  1               @mRF:	.byte "RF",0
001EEE  1               @mEI:	.byte "EI",0
001EEE  1               @mDI:	.byte "DI",0
001EEE  1               @mSL:	.byte "SL",0
001EEE  1               @mRL:	.byte "RL",0
001EEE  1               @mCL:	.byte "CL",0
001EEE  1               @mRSR:	.byte "RSR",0
001EEE  1               @mRI:	.byte "RI",0
001EEE  1               @mRIM:	.byte "RIM",0
001EEE  1               @mELO:	.byte "ELO",0
001EEE  1               @mPCX:	.byte "PCX",0
001EEE  1               @mDLY:	.byte "DLY",0
001EEE  1               @mRSys:	.byte "RSYS",0
001EEE  1               
001EEE  1               @mBL:	.byte "BL",0
001EEE  1               @mBNL:	.byte "BNL",0
001EEE  1               @mBF:	.byte "BF",0
001EEE  1               @mBNF:	.byte "BNF",0
001EEE  1               @mBZ:	.byte "BZ",0
001EEE  1               @mBNZ:	.byte "BNZ",0
001EEE  1               @mBM:	.byte "BM",0
001EEE  1               @mBF:	.byte "BF",0
001EEE  1               @mBGZ:	.byte "BGZ",0
001EEE  1               @mBLE:	.byte "BLE",0
001EEE  1               @mBS1:	.byte "BS1",0
001EEE  1               @mBS2:	.byte "BS2",0
001EEE  1               @mBS3:	.byte "BS3",0
001EEE  1               @mBS4:	.byte "BS4",0
001EEE  1               @mBTM:	.byte "BTM",0
001EEE  1               @mBEP:	.byte "BEP",0
001EEE  1               
001EEE  1               @mINRB:	.byte "INRB",0
001EEE  1               @mDCRB:	.byte "DCRB",0
001EEE  1               @mCLRB:	.byte "CLRB",0
001EEE  1               @mIVRB:	.byte "IVRB",0
001EEE  1               @mSRRB:	.byte "SRRB",0
001EEE  1               @mSLRB:	.byte "SLRB",0
001EEE  1               @mRRRB:	.byte "RRRB",0
001EEE  1               @mRLRB:	.byte "RLRB",0
001EEE  1               @mINAB:	.byte "INAB",0
001EEE  1               @mDCAB:	.byte "DCAB",0
001EEE  1               @mCLAB:	.byte "CLAB",0
001EEE  1               @mIVAB:	.byte "IVAB",0
001EEE  1               @mSRAB:	.byte "SRAB",0
001EEE  1               @mSLAB:	.byte "SLAB",0
001EEE  1               
001EEE  1               @mINR:	.byte "INR",0
001EEE  1               @mDCR:	.byte "DCR",0
001EEE  1               @mCLR:	.byte "CLR",0
001EEE  1               @mIVR:	.byte "IVR",0
001EEE  1               @mSRR:	.byte "SRR",0
001EEE  1               @mSLR:	.byte "SLR",0
001EEE  1               @mRRR:	.byte "RRR",0
001EEE  1               @mRLR:	.byte "RLR",0
001EEE  1               @mINA:	.byte "INA",0
001EEE  1               @mDCA:	.byte "DCA",0
001EEE  1               @mCLA:	.byte "CLA",0
001EEE  1               @mIVA:	.byte "IVA",0
001EEE  1               @mSRA:	.byte "SRA",0
001EEE  1               @mSLA:	.byte "SLA",0
001EEE  1               @mINX:	.byte "INX",0
001EEE  1               @mDCX:	.byte "DCX",0
001EEE  1               
001EEE  1               @mADDB:	.byte "ADDB",0
001EEE  1               @mSUBB:	.byte "SUBB",0
001EEE  1               @mANDB:	.byte "ANDB",0
001EEE  1               @mORIB:	.byte "ORIB",0
001EEE  1               @mOREB:	.byte "OREB",0
001EEE  1               @mXFRB:	.byte "XFRB",0
001EEE  1               @mAABB:	.byte "AABB",0
001EEE  1               @mSABB:	.byte "SABB",0
001EEE  1               @mNABB:	.byte "NABB",0
001EEE  1               @mXAXB:	.byte "XAXB",0
001EEE  1               @mXAYB:	.byte "XAYB",0
001EEE  1               @mXABB:	.byte "XABB",0
001EEE  1               @mXAZB:	.byte "XAZB",0
001EEE  1               @mXASB:	.byte "XASB",0
001EEE  1               
001EEE  1               @mADD:	.byte "ADD",0
001EEE  1               @mSUB:	.byte "SUB",0
001EEE  1               @mAND:	.byte "AND",0
001EEE  1               @mORI:	.byte "ORI",0
001EEE  1               @mORE:	.byte "ORE",0
001EEE  1               @mXFR:	.byte "XFR",0
001EEE  1               @mAAB:	.byte "AAB",0
001EEE  1               @mSAB:	.byte "SAB",0
001EEE  1               @mNAB:	.byte "NAB",0
001EEE  1               @mXAX:	.byte "XAX",0
001EEE  1               @mXAY:	.byte "XAY",0
001EEE  1               @mXAB:	.byte "XAB".0
001EEE  1               @mXAZ:	.byte "XAZ",0
001EEE  1               @mXAS:	.byte "XAS",0
001EEE  1               
001EEE  1               @mLDX:	.byte "LDX",0
001EEE  1               @mSTX:	.byte "STX",0
001EEE  1               @mJMP:	.byte "JMP",0
001EEE  1               @mSYSCALL: .byte "SYSCALL",0
001EEE  1               @mJSR:	.byte "JSR",0
001EEE  1               
001EEE  1               @mLDAB:	.byte "LDAB",0
001EEE  1               @mLDA:	.byte "LDA",0
001EEE  1               
001EEE  1               @mSTAB:	.byte "STAB",0
001EEE  1               @mSTA:	.byte "STA",0
001EEE  1               
001EEE  1               @mLDBB:	.byte "LDBB",0
001EEE  1               @mLDB:	.byte "LDB",0
001EEE  1               
001EEE  1               @mSTBB:	.byte "STBB",0
001EEE  1               @mSTB:	.byte "STB",0
001EEE  1               
001EEE  1               @mPUSH:	.byte "PUSH",0
001EEE  1               @mPOP:	.byte "POP",0
001EEE  1               
001EEE  1               @mMUL:	.byte "MUL",0
001EEE  1               @mDIV:	.byte "DIV",0
001EEE  1               
001EEE  1               
001EEE  1                 .macro CodeE Mnem,Fmt
001EEE  1               	.byte Mnem-@Mnem,Fmt
001EEE  1               	.endmacro
001EEE  1               
001EEE  1               @Code: ; indexed by 1st opcode byte
001EEE  1                 CodeE @mHlt,@Inh	;00
001EEE  1                 CodeE @mNop,@Inh	;01
001EEE  1                 CodeE @mSF,@Inh	;02
001EEE  1                 CodeE @mRF,@Inh	;03
001EEE  1                 CodeE @mEI,@Inh	;04
001EEE  1                 CodeE @mDI,@Inh	;05
001EEE  1                 CodeE @mSL,@Imh	;06
001EEE  1                 CodeE @mRL,@Inh	;07
001EEE  1                 CodeE @mCL,@Inh	;08
001EEE  1                 CodeE @mRSR,@Inh	;09
001EEE  1                 CodeE @mRI,@Inh	;0a
001EEE  1                 CodeE @mRIM,@Inh	;0b
001EEE  1                 CodeE @mELO,@Inh	;0c
001EEE  1                 CodeE @mPCX,@Inh	;0d
001EEE  1                 CodeE @mDLY,@Inh	;0e
001EEE  1                 CodeE @mRSys,@Inh	;0f
001EEE  1                 CodeE @mBL,@Rel	;10
001EEE  1                 CodeE @mBNL,@Rel	;11
001EEE  1                 CodeE @mBF,@Rel	;12
001EEE  1                 CodeE @mBNF,@Rel	;13
001EEE  1                 CodeE @mBZ,@Rel	;14
001EEE  1                 CodeE @mBNZ,@Rel	;15 BNZ adr ; Branch if V (Z) flag clear
001EEE  1                 CodeE @mBM,@Rel	;16 BM adr ; Branch if Minus flag set
001EEE  1                 CodeE @mBF,@Rel	;17 BP adr ; Branch on Positive (Minus flag clear)
001EEE  1                 CodeE @mBGZ,@Rel	;18 BGZ adr ; Branch if Greater Than 0 (!V && !Minus)
001EEE  1                 CodeE @mBLE,@Rel	;19 BLE adr ; Branch if Less Than or Equal to 0 (V | Minus)
001EEE  1                 CodeE @mBS1,@Rel	;1a BS1 adr ; Branch if Sense Switch 1 Set
001EEE  1                 CodeE @mBS2,@Rel	;1b BS2 adr ; Branch if Sense Switch 2 Set
001EEE  1                 CodeE @mBS3,@Rel	;1c BS3 adr ; Branch if Sense Switch 3 Set
001EEE  1                 CodeE @mBS4,@Rel	;1d BS4 adr ; Branch if Sense Switch 4 Set
001EEE  1                 CodeE @mBTM,@Rel	;1e BTM Rel ; Branch on TTY Mark (Changed for CPU6?)
001EEE  1                 CodeE @mBEP,@Rel	;1f BEP Rel ; Branch on Even Parity (Changed for CPU6?)
001EEE  1                 CodeE @mINRB,@BReg	;20 increment register upper byte or lower byte
001EEE  1                 CodeE @mDCRB,@BReg	;21 decrement register upper byte or lower byte
001EEE  1                 CodeE @mCLRB,@BReg	;22 clear register upper byte or lower byte
001EEE  1                 CodeE @mIVRB,@BReg	;23 invert register byte
001EEE  1                 CodeE @mSRRB,@BReg	;24 shift register byte right (sign extend)
001EEE  1                 CodeE @mSLRB,@BReg	;25 shift register byte left (0 shifted in)
001EEE  1                 CodeE @mRRRB,@BReg	;26 rotate register byte right (thru link flag)
001EEE  1                 CodeE @mRLRB,@BReg	;27
001EEE  1                 CodeE @mINAB,@Inh	;28 Increment AL register
001EEE  1                 CodeE @mDCAB,@Inh	;29 Decrement AL register
001EEE  1                 CodeE @mCLAB,@Inh	;2a Clear AL register
001EEE  1                 CodeE @mIVAB,@Inh	;2b Invert AL register
001EEE  1                 CodeE @mSRAB,@Inh	;2c Shift AL register right (sign extend)
001EEE  1                 CodeE @mSLAB,@Inh	;2d Shift AL register left (0 shifted in)
001EEE  1                 CodeE @mIll,@Inh	;2e Memory mapping
001EEE  1                 CodeE @mIll,@Inh	;2f DMA
001EEE  1                 CodeE @mINR,@WReg1	;30 increment register word
001EEE  1                 CodeE @mDCR,@WReg1	;31 decrement register word
001EEE  1                 CodeE @mCLR,@WReg	;32 clear register word
001EEE  1                 CodeE @mIVR,@WReg	;33 invert register word
001EEE  1                 CodeE @mSRR,@WReg1	;34 shift register right (sign extend)
001EEE  1                 CodeE @mSLR,@WReg1	;35 shift register left (0 shifted in)
001EEE  1                 CodeE @mRRR,@WReg1	;36 rotate register right (thru link flag)
001EEE  1                 CodeE @mRLR,@WReg1	;37 rotate register left (thru link flag)
001EEE  1                 CodeE @mINA,@Inh	;38 Increment AW register
001EEE  1                 CodeE @mDCA,@Inh	;39 Decrement AW register
001EEE  1                 CodeE @mCLA,@Inh	;3a Clear AW register
001EEE  1                 CodeE @mIVA,@Inh	;3b Invert AW register
001EEE  1                 CodeE @mSRA,@Inh	;3c Shift AW register right (sign extend)
001EEE  1                 CodeE @mSLA,@Inh	;3d Shift AW register left (0 shifted in)
001EEE  1                 CodeE @mINX,@Inh	;3e Increment XW register
001EEE  1                 CoddE @mDCX,@Inh	;3f Decrement XW register
001EEE  1                 CodeE @mADDB,@DRB	;40 DestReg,SrcReg ; Add byte Src to Dest
001EEE  1                 CodeE @mSUBB,@DRB	;41 DestReg,SrcReg ; Subtract byte Src to Dest
001EEE  1                 CodeE @mANDB,@DRB	;42 DestReg,SrcReg ; AND byte Src to Dest
001EEE  1                 CodeE @mORIB,@DRB	;43 DestReg,SrcReg ; OR byte Src to Dest
001EEE  1                 CodeE @mOREB,@DRB	;44 DestReg,SrcReg ; XOR byte Src to Dest
001EEE  1                 CodeE @mXFRB,@DRB	;45 DestReg,SrcReg ; Copy byte of Src register into byte of Dest register
001EEE  1                 CodeE @mIll,@Inh	;46
001EEE  1                 CodeE @mIll,@Inh	;47
001EEE  1                 CodeE @mAABB,@Inh	;48 BL+=AL
001EEE  1                 CodeE @mSABB,@Inh	;49 BL=AL-BL
001EEE  1                 CodeE.@mNABB,@Inh	;4a BL&=AL
001EEE  1                 CodeE @mXAXB,@Inh	;4b XL=AL
001EEE  1                 CodeE @mXAYB,@Inh	;4c YL=AL
001EEE  1                 CodeE @mXABB,@Inh	;4d BL=AL
001EEE  1                 CodeE @mXAZB,@Inh	;4e ZL=AL
001EEE  1                 CodeE @mXASL,@Inh	;4f SL=AL
001EEE  1                 CodeE @mADD,@DRW	;50 DestReg,SrcReg ; Add word Src to Dest
001EEE  1                 CoddE @mSUB,@DRW	;51 DestReg,SrcReg ; Subtract byte Src to Dest
001EEE  1                 CodeE @mANDC,@DRW	;52 DestReg,SrcReg ; AND word Src to Dest
001EEE  1                 CodeE @mORI,@DRW	;53 DestReg,SrcReg ; OR word Src to Dest
001EEE  1                 CodeE @mORE,@DRW	;54 DestReg,SrcReg ; XOR word Src to Dest
001EEE  1                 CodeE @mXFR,@DRW	;55 DestReg,SrcReg ; Copy Src register into Dest register
001EEE  1                 CodeE @mIll,@Inh	;56 ??
001EEE  1                 CodeE @mIll,@Inh	;57 ??
001EEE  1                 CodeE @mAAB,@Inh	;58 BW+=AW
001EEE  1                 CodeE @mSAB,@Inh	;59 BW=AW-BW
001EEE  1                 CodeE @mNAB,@Inh	;5a BW&=AW
001EEE  1                 CodeE @mXAX,@Inh	;5b XW=AW
001EEE  1                 CodeE @mXAY,@Inh	;5c YW=AW
001EEE  1                 CodeE @mXAB,@Inh	;5d BW=AW
001EEE  1                 CodeE @mXAZ,@Inh	;5e ZW=AW
001EEE  1                 CodeE @mXAS,@Inh	;5f SW=AW
001EEE  1                 CodeE @mLDX,@LitW	;60 Load immediate into XW
001EEE  1                 CodeE @mLDX,@Direct	;61 Load direct address into XW
001EEE  1                 CodeE @mLDX,@Indirect	;62 Load indirect address into XW
001EEE  1                 CodeE @mLDX,@Rel	;63 Load direct Program Counter offset by N address into XW
001EEE  1                 CodeE @mLDX,@RelInd	;64 Load indirect Program Counter offset by N address into XW
001EEE  1                 CodeE @mLDX,@WX	;65 Load indexed mode register into XW
001EEE  1                 CodeE @mIll,@Inh	;66 ??
001EEE  1                 CodeE @mIll,@Inh	;67 ??
001EEE  1                 CodeE @mSTX,@LitW	;68 Store XW into literal address (Not possible?)
001EEE  1                 CoddE @mSTX,@Direct	;69 Store XW into direct address
001EEE  1                 CodeE @mSTX,@Indirect	;6a Store XW into indirect address
001EEE  1                 CodeE @mSTX,@Rel	;6b Store XW into direct Program Counter offset by N address
001EEE  1                 CodeE @mSTX,@RelInd	;6c Store XW into indirect Program Counter offset by N address
001EEE  1                 CodeE @mSTX,@WX	;6d Store XW into indexed register
001EEE  1                 CodeE @mIll,@Inh	;6E ??
001EEE  1                 CodeE @mIll,@Inh	;6F ??
001EEE  1                 CodeE @mIll,@Inh	;70 ??
001EEE  1                 CodeE @mJMP,@Direct	;71 Jump to direct address
001EEE  1                 CodeE @mJMP,@Indirect	;72 Jump to indirect address
001EEE  1                 CodeE @mJMP,@Rel	;73 Jump to direct Program Counter offset by N address
001EEE  1                 CodeE @mJMP,@RelInd	;74 Jump to indirect Program Counter offset by N address
001EEE  1                 CodeE @mJMP,@WX	;75 WReg,Mod,Offset ;Jump to indexed mode register
001EEE  1                 CodeE @mSYSCALL,@Inh	;76 Call interrupt level 15
001EEE  1                 CodeE @mMUL,@Inh	;77	multiply
001EEE  1                 CodeE @mDIV,@Inh	;78	divide
001EEE  1                 CodeE @mJSR,@Direct	,79
001EEE  1                 CodeE @mJSR,@Indirect	;7a
001EEE  1                 CodeE @mJSR,@Rel	;7b
001EEE  1                 CodeE @mJSR,@RelInd	;7c
001EEE  1                 CodeE @mJSR,@WX	;7d	WReg,Mod,Offset ; Jump to subroutine at indexed mode register
001EEE  1                 CodeE @mPUSH,@Inh	;7e	RegCountM1
001EEE  1                 CodeE @mPOP,@Inh	;7f	RegCountM1
001EEE  1                 CodeE @mLDAB,@LitB	;80	Load literal address into AL register
001EEE  1                 CodeE @mLDAB,@Direct	;81	Load direct address into AL register
001EEE  1                 CodeE @mLDAB,@Indirect ;82	Load indirect address into AL register
001EEE  1                 CodeE @mLDAB,@Rel	;83	Load direct Program Counter offset by N address into AL register
001EEE  1                 CodeE @mLDAB,@RelInd	;84	Load indirect Program Counter offset by N address into byte of AL register
001EEE  1                 CodeE @mLDAB,@BX	;85	WReg,Mod,Offset ; Load indexed register into byte of AL register
001EEE  1                 CodeE @mIll,@Inh	;86	??
001EEE  1                 CodeE @mIll,@Inh	;87	??
001EEE  1                 CodeE @mLDAB,@A	;88	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDAB,@A	;89	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDAB,@A	;8a	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDAB,@A	;8b	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDAB,@A	;8c	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDAB,@A	;8d	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDAB,@A	;8e	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDAB,@A	;8f	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDA,@LitW	;90	Load literal address into full word of AW register
001EEE  1                 CodeE @mLDA,@Direct	;91	Load direct address into full word of AW register
001EEE  1                 CodeE @mLDA,@Indirect	;92	Load indirect address into full word of AW register
001EEE  1                 CodeE @mLDA,@Rel	;93	Load direct Program Counter offset by N address into full word of AW register
001EEE  1                 CodeE @mLDA,@RelInd	;94	Load indirect Program Counter offset by N address into full word of AW register
001EEE  1                 CodeE @mLDA,@WX	;95	WReg,Mod,Offset ; Load indexed register into full word of AW register
001EEE  1                 CodeE @mIll,@Inh	;96	??
001EEE  1                 CodeE @mIll,@Inh	;97	??
001EEE  1                 CodeE @mLDA,@A	;98	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDA,@A	;99	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDA,@A	;9a	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDA,@A	;9b	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDA,@A	;9c	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDA,@A	;9d	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDA,@A	;9e	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mLDA,@A	;9f	WReg ; Load byte from memory address stored in WReg into AL register
001EEE  1                 CodeE @mSTAB,@LitB	;a0	Store byte of AL register into literal address (Not possible?)
001EEE  1                 CodeE @mSTAB,@Direct	;a1	Store byte of AL register into direct address
001EEE  1                 CodeE @mSTAB,@Indirect ;a2	Store byte of AL register into indirect address
001EEE  1                 CodeE @mSTAB,@Rel	;a3	Store byte of AL register into direct Program Counter offset by N address
001EEE  1                 CodeE @mSTAB,@RelInd	;a4	Store byte of AL register into indirect Program Counter offset by N address
001EEE  1                 CodeE @mSTAB,@BX	;a5	WReg,Mod,Offset ; Store byte of AL register into indexed register
001EEE  1                 CodeE @mIll,@Inh	;A6	??
001EEE  1                 CodeE @mIll,@Inh	;A7	??
001EEE  1                 CodeE @mSTAB,@A	;a8	Store AL register to memory address stored in WReg
001EEE  1                 CodeE @mSTAB,@A	;a9	Store AL register to memory address stored in WReg
001EEE  1                 CodeE @mSTAB,@A	;aa	Store AL register to memory address stored in WReg
001EEE  1                 CodeE @mSTAB,@A	;ab	Store AL register to memory address stored in WReg
001EEE  1                 CodeE @mSTAB,@A	;ac	Store AL register to memory address stored in WReg
001EEE  1                 CodeE @mSTAB,@A	;ad	Store AL register to memory address stored in WReg
001EEE  1                 CodeE @mSTAB,@A	;ae	Store AL register to memory address stored in WReg
001EEE  1                 CodeE @mSTAB,@A	;af	Store AL register to memory address stored in WReg
001EEE  1                 CodeE @mSTA,@LitW	;b0	Store word of AW register into literal address (Not possible?)
001EEE  1                 CodeE @mSTA,@Direct	;b1	Store word of AW register into direct address
001EEE  1                 CodeE @mSTA,@Indirect	;b2	Store word of AW register into indirect address
001EEE  1                 CodeE @mSTA,@Rel	;b3	Store word of AW register into direct Program Counter offset by N address
001EEE  1                 CodeE @mSTA,@RelInd	;b4	Store word of AW register into indirect Program Counter offset by N address
001EEE  1                 CodeE @mSTA,@WX	;b5	WReg,Mod,Offset ; Store word of AW register into indexed register
001EEE  1                 CodeE @mIll,@Inh	;b6	??
001EEE  1                 CodeE @mIll,@Inh	;b7	??
001EEE  1                 CodeE @mSTA,@A	;b8	WReg ; Store AW register to memory address stored in WReg
001EEE  1                 CodeE @mSTA,@A	;b9	WReg ; Store AW register to memory address stored in WReg
001EEE  1                 CodeE @mSTA,@A	;ba	WReg ; Store AW register to memory address stored in WReg
001EEE  1                 CodeE @mSTA,@A	;bb	WReg ; Store AW register to memory address stored in WReg
001EEE  1                 CodeE @mSTA,@A	;bc	WReg ; Store AW register to memory address stored in WReg
001EEE  1                 CodeE @mSTA,@A	;bd	WReg ; Store AW register to memory address stored in WReg
001EEE  1                 CodeE @mSTA,@A	;be	WReg ; Store AW register to memory address stored in WReg
001EEE  1                 CodeE @mSTA,@A	;bf	WReg ; Store AW register to memory address stored in WReg
001EEE  1                 CodeE @mLDBB,@LitB	;c0	Load literal address into BL register
001EEE  1                 CodeE @mLDBB,@Direct	;c1	Load direct address into BL register
001EEE  1                 CodeE @mLDBB,@Indirect ;c2	Load indirect address into BL register
001EEE  1                 CodeE @mLDBB,@Rel	;c3	Load direct Program Counter offset by N address into BL register
001EEE  1                 CodeE @mLDBB,@RelInd	;c4	Load indirect Program Counter offset by N address into BL register
001EEE  1                 CodeE @mLDBB,@BX	;c5	WReg,Mod,Offset ; Load indexed register into BL register
001EEE  1                 CodeE @mIll,@Inh	;C6	??
001EEE  1                 CodeE @mIll,@Inh	;C7	??
001EEE  1                 CodeE @mLDBB,@A	;c8	Load byte from memory address stored in WReg into BL register
001EEE  1                 CodeE @mLDBB,@A	;c9	Load byte from memory address stored in WReg into BL register
001EEE  1                 CodeE @mLDBB,@A	;ca	Load byte from memory address stored in WReg into BL register
001EEE  1                 CodeE @mLDBB,@A	;cb	Load byte from memory address stored in WReg into BL register
001EEE  1                 CodeE @mLDBB,@A	;cc	Load byte from memory address stored in WReg into BL register
001EEE  1                 CodeE @mLDBB,@A	;cd	Load byte from memory address stored in WReg into BL register
001EEE  1                 CodeE @mLDBB,@A	;ce	Load byte from memory address stored in WReg into BL register
001EEE  1                 CodeE @mLDBB,@A	;cf	Load byte from memory address stored in WReg into BL register
001EEE  1                 CodeE @mLDB,@LitW	;d0	Load literal address into BW register
001EEE  1                 CodeE @mLDB,@Direct	;d1	Load direct address into BW register
001EEE  1                 CodeE @mLDB,@Indirect	;d2	Load indirect address into BW register
001EEE  1                 CodeE @mLDB,@Rel	;d3	Load direct Program Counter offset by N address into BW register
001EEE  1                 CodeE @mLDB,@RelInd	;d4	Load indirect Program Counter offset by N address into BW register
001EEE  1                 CodeE @mLDB,@WX	;d5	WReg,Mod,Offset ; Load indexed register into BW register
001EEE  1                 CodeE @mIll,@Inh	;D6	??
001EEE  1                 CodeE @mIll,@Inh	;D7	??
001EEE  1                 CodeE @mLDB,@A	;d8	Load word from memory address stored in WReg into BW register
001EEE  1                 CodeE @mLDB,@A	;d9	Load word from memory address stored in WReg into BW register
001EEE  1                 CodeE @mLDB,@A	;da	Load word from memory address stored in WReg into BW register
001EEE  1                 CodeE @mLDB,@A	;db	Load word from memory address stored in WReg into BW register
001EEE  1                 CodeE @mLDB,@A	;dc	Load word from memory address stored in WReg into BW register
001EEE  1                 CodeE @mLDB,@A	;dd	Load word from memory address stored in WReg into BW register
001EEE  1                 CodeE @mLDB,@A	;de	Load word from memory address stored in WReg into BW register
001EEE  1                 CodeE @mLDB,@A	;df	Load word from memory address stored in WReg into BW register
001EEE  1                 CodeE @mSTBB,@LitB	;e0	Store byte of BL register into literal address (Not possible?)
001EEE  1                 CodeE @mSTBB,@Direct	;e1	Store BL into direct address
001EEE  1                 CodeE @mSTBB,@Indirect ;e2	Store BL into indirect address
001EEE  1                 CodeE @mSTBB,@Rel	;e3	Store BL into direct Program Counter offset by N address
001EEE  1                 CodeE @mSTBB,@RelInd	;e4	Store BL into indirect Program Counter offset by N address
001EEE  1                 CodeE @mSTBB,@BX	;e5	WReg,Mod,Offset ; Store BL into indexed register
001EEE  1                 CodeE @mIll,@Inh	;E6	??
001EEE  1                 CodeE @mIll,@Inh	;E7	??
001EEE  1                 CodeE @mSTBB,@A	;e8	Store byte from BL register to memory address stored in WReg
001EEE  1                 CodeE @mSTBB,@A	;e9	Store byte from BL register to memory address stored in WReg
001EEE  1                 CodeE @mSTBB,@A	;ea	Store byte from BL register to memory address stored in WReg
001EEE  1                 CodeE @mSTBB,@A	;eb	Store byte from BL register to memory address stored in WReg
001EEE  1                 CodeE @mSTBB,@A	;ec	Store byte from BL register to memory address stored in WReg
001EEE  1                 CodeE @mSTBB,@A	;ed	Store byte from BL register to memory address stored in WReg
001EEE  1                 CodeE @mSTBB,@A	;ee	Store byte from BL register to memory address stored in WReg
001EEE  1                 CodeE @mSTBB,@A	;ef	Store byte from BL register to memory address stored in WReg
001EEE  1                 CodeE @mSTB,@LitW	;f0	Store BW into literal address (Not possible?)
001EEE  1                 CodeE @mSTB,@Direct	;f1	Store BW into direct address
001EEE  1                 CodeE @mSTB,@Indirect	;f2	Store BW into indirect address
001EEE  1                 CodeE @mSTB,@Rel	;f3	Store BW into direct Program Counter offset by N address
001EEE  1                 CodeE @mSTB,@RelInd	;f4	Store BW into indirect Program Counter offset by N address
001EEE  1                 CodeE @mSTB,@WX	;f5	WReg,Mod,Offset ; Store BW into indexed register
001EEE  1                 CodeE @mIll,@Inh	;f6	??
001EEE  1                 CodeE @mIll,@Inh	;f7	??
001EEE  1                 CodeE @mSTB,@A	;f8	Store BW to memory address stored in WReg
001EEE  1                 CodeE @mSTB,@A	;f9	Store BW to memory address stored in WReg
001EEE  1                 CodeE @mSTB,@A	;fa	Store BW to memory address stored in WReg
001EEE  1                 CodeE @mSTB,@A	;fb	Store BW to memory address stored in WReg
001EEE  1                 CodeE @mSTB,@A	;fc	Store BW to memory address stored in WReg
001EEE  1                 CodeE @mSTB,@A	;fd	Store BW to memory address stored in WReg
001EEE  1                 CodeE @mSTB,@A	;fe	Store BW to memory address stored in WReg
001EEE  1                 CodeE @mSTB,@A	;ff	Store BW to memory address stored in WReg
001EEE  1               
001EEE  1               
001EEE  1               
001EEE  1               ;---------------------------------------
001EEE  1               
001EEE  1               ;????????????????????????????????????????????????????????????
001EEE  1               
001EEE  1                 .macro AWordR name,rtn,opcode
001EEE  1               	FHdr name,0
001EEE  1               	JSRR rtn
001EEE  1               	.byte opcode
001EEE  1               	.endmacro
001EEE  1                 .macro AWordD name,rtn,opcode
001EEE  1               	FHdr name,0
001EEE  1               	JSRD rtn
001EEE  1               	.byte opcode
001EEE  1               	.endmacro
001EEE  1               
001EEE  1                FHdr 'IfL,',0 ; ( -- )  if Link (Carry) Set
001EEE  1               	LDABL $11
001EEE  1               If3:	JSRD CCommaA
001EEE  1               	CLA
001EEE  1               	JSRD CommaA
001EEE  1               	JMPD Here
001EEE  1               
001EEE  1                FHdr 'IfNL,',0 ; ( -- )  if Link (Carry) clear
001EEE  1               	LDABL $10
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfF,',0 ; ( -- )  if Fault Set
001EEE  1               	LDABL $13
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfNF,',0 ; ( -- )  if Fault not Set
001EEE  1               	LDABL $12
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfZ,',0 ; ( -- )  if V (Z) flag clear
001EEE  1               	LDABL $15
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfNZ,',0 ; ( -- )  if V (Z) flag set
001EEE  1               	LDABL $14
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfM,',0 ; ( -- )  if Minus flag set
001EEE  1               	LDABL $17
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfP,',0 ; ( --- )  if Minus flag clear
001EEE  1               	LDABL $16
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfLE,',0 ; ( -- )  if <=0
001EEE  1               	LDABL $18
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfGT,',0 ; ( -- ) if >0
001EEE  1               	LDABL $19
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfNS1,',0 ; ( -- )  if Sense Switch 1 clear
001EEE  1               	LDABL $1a
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfNS2,',0 ; ( -- )  if Sense Switch 2 clear
001EEE  1               	LDABL $1b
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfNS3,',0 ; ( -- )  if Sense Switch 3 clear
001EEE  1               	LDABL $1c
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'IfNS4,',0 ; ( -- )  if Sense Switch 4 clear
001EEE  1               	LDABL $1d
001EEE  1               	JMPR If3
001EEE  1               
001EEE  1                FHdr 'Then,',0
001EEE  1               ThenC:	LDAX ZW,ModBRPB,0	; pop addr
001EEE  1               	XAY
001EEE  1               	LDBD VDP
001EEE  1               	SUB AW,BW
001EEE  1               	LDBL $80
001EEE  1               	BNL @Err
001EEE  1               	STABX YW,ModNBRB,$ff
001EEE  1               	RSR
001EEE  1               @Err:	JSRD PDotQuote
001EEE  1               	.byte 12,"out of range"
001EEE  1               	JMPD Abort
001EEE  1               
001EEE  1                FHdr 'Else,',0
001EEE  1               	JSRR ThenC
001EEE  1               	LDABL $73	; JMPR n
001EEE  1               	JSRD CCommaA
001EEE  1               	CLA
001EEE  1               	JSRD CommaA
001EEE  1               	JMPD Here
001EEE  1               
001EEE  1               
001EEE  1                FHdr 'Begin,',0
001EEE  1               	JMPD Here
001EEE  1               ;UntilC: ???
001EEE  1               ; AWordR 'UntilL,'  ,UntilC,$11 ; Link (Carry) Set
001EEE  1               ; AWordR 'UntilNL,' ,UntilC,$10 ; Link (Carry) clear
001EEE  1               ; AWordR 'UntilF,'  ,UntilC,$13 ; Fault Set
001EEE  1               : AWordR 'UntilNF,' ,UntilC,$12 ; Fault not Set
001EEE  1               : AWodRR 'UntilZ,'  ,UntilC,$15 ; V (Z) flag clear
001EEE  1               : AWordR 'UntilNZ,' ,UntilC,$14 ; V (Z) flag set
001EEE  1               : AWordR 'UntilM,'  ,UntilC,$15 ; Minus flag set
001EEE  1               : AWordR 'UntilP,'  ,UntilC,$16 ; Minus flag clear
001EEE  1               : AWordR 'UntilLE,' ,UntilC,$18 ; <=0
001EEE  1               : AWordR 'UntilGT,' ,UntilC,$19 ; >0
001EEE  1               : AWordR 'UntilNS1,',UntilC,$1a ; Sense Switch 1 clear
001EEE  1               : AWordR 'UntilNS2,',UntilC,$1b ; if Sense Switch 2 clear
001EEE  1               : AWordR 'UntilNS3,',UntilC,$1c ; if Sense Switch 3 clear
001EEE  1               : AWordR 'UntilNS4,',UntilC,$1d ; if Sense Switch 4 clear
001EEE  1               ; While??,
001EEE  1               
001EEE  1               
001EEE  1               AIsClear:
001EEE  1               	LDABR AMode
001EEE  1               	BP @EMode
001EEE  1               	LDABR AReg1
001EEE  1               	BP @EReg
001EEE  1               	JMPD QStack
001EEE  1               @EMode:	JSRD PDotQuote
001EEE  1               	.byte 10,"extra mode"
001EEE  1               	JMPD Abort
001EEE  1               @EReg:	JSRD PDotQuote
001EEE  1               	.byte 10,"extra regs"
001EEE  1               	JMPD Abort
001EEE  1               
001EEE  1               AClear:
001EEE  1               	LDABL $ff
001EEE  1               	STABR AMode
001EEE  1               	STABR AReg1
001EEE  1               	STABR AReg2
001EEE  1               	RSR
001EEE  1               
001EEE  1               AMode:	.byte $ff	; indexed addressing mode
001EEE  1               
001EEE  1               AModeSet: ; remember indexed addr mode for next instruction
001EEE  1               	LDABR AMode	;empty?
001EEE  1               	BP @20
001EEE  1               	LDABA XW
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	STABR AMode
001EEE  1               	RSR
001EEE  1               
001EEE  1               @20:	JSRD PDotQuote
001EEE  1               	.byte 10,"extra mode"
001EEE  1               	JMPD Abort
001EEE  1               
001EEE  1                AWordR '(r)'   ,AModeSet,$0
001EEE  1                AWordR '(r+)'  ,AModeSet,$1
001EEE  1                AWordR '(-r)'  ,AModeSet,$2
001EEE  1                AWordR '@(r)'  ,AModeSet,$4
001EEE  1                AWordR '@(r+)' ,AModeSet,$5
001EEE  1                AWordR '@(-r)' ,AModeSet,$6
001EEE  1                AWordR 'n(r)'  ,AModeSet,$8
001EEE  1                AWordR 'n(r+)' ,AModeSet,$9
001EEE  1                AWordR 'n(-r)' ,AModeSet,$A
001EEE  1                AWordR '@n(r)' ,AModeSet,$C
001EEE  1                AWordR '@n(r+)',AModeSet,$D
001EEE  1                AWordR '@n(-r)',AModeSet,$E
001EEE  1               
001EEE  1               AReg1:	.byte $ff	; latest reg
001EEE  1               AReg2:	.byte $ff	; 2nd reg
001EEE  1               
001EEE  1               ARegPop:
001EEE  1               	LDABR AReg1
001EEE  1               	BM @Err
001EEE  1               	LDBBR AReg2
001EEE  1               	STBBR AReg1
001EEE  1               	LDBBL $ff
001EEE  1               	STBBR AReg2
001EEE  1               	RSR
001EEE  1               @Err:	JSRD PDotQuote
001EEE  1               	.byte $11,"missing reg"
001EEE  1               	JMPD Abort
001EEE  1               ARegSet:
001EEE  1               	LDBBR AReg2
001EEE  1               	BP @Err
001EEE  1               	LDBBR AReg1
001EEE  1               	STBBR AReg2
001EEE  1               	LDABA XW
001EEE  1               	STABR AReg1
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	RSR
001EEE  1               @Err:	JSRD PDotQuote
001EEE  1               	.byte 13,"too many regs"
001EEE  1               	JMPD Abort
001EEE  1               
001EEE  1               ; Register names
001EEE  1                AWordR 'AW',ARegSet,$30
001EEE  1                AWordR 'AH',ARegSet,$20
001EEE  1                AWordR 'AL',ARegSet,$21
001EEE  1                AWordR 'BW',ARegSet,$32
001EEE  1                AWordR 'BH',ARegSet,$22
001EEE  1                AWordR 'BL',ARegSet,$23
001EEE  1                AWordR 'XW',ARegSet,$34
001EEE  1                AWordR 'XH',ARegSet,$24
001EEE  1                AWordR 'XL',ARegSet,$25
001EEE  1                AWordR 'YW',ARegSet,$36
001EEE  1                AWordR 'YH',ARegSet,$26
001EEE  1                AWordR 'YL',ARegSet,$27
001EEE  1                AWordR 'ZW',ARegSet,$38
001EEE  1                AWordR 'ZH',ARegSet,$28
001EEE  1                AWordR 'ZL',ARegSet,$29
001EEE  1                AWordR 'SW',ARegSet,$3a
001EEE  1                AWordR 'CW',ARegSet,$3c
001EEE  1                AWordR 'PW',ARegSet,$3e
001EEE  1               
001EEE  1               
001EEE  1               A_Inherent: ; do instruction with no operands
001EEE  1               ;	LDAL 0		; disassembly routine
001EEE  1               	LDABA XW	; compile opcode
001EEE  1               	JSRD CCommaA
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	JMPD AIsClear
001EEE  1               
001EEE  1                AWordR 'HLT,',A_Inherent,$00
001EEE  1                AWordR 'NOP,',A_Inherent,$01
001EEE  1                AWordR 'SF,',A_Inherent,$02
001EEE  1                AWordR 'RF,',A_Inherent,$03
001EEE  1                AWordR 'EI,',A_Inherent,$04
001EEE  1                AWordR 'DI,',A_Inherent,$05
001EEE  1                AWordR 'SL,',A_Inherent,$06
001EEE  1                AWordR 'RL,',A_Inherent,$07
001EEE  1                AWordR 'CL,',A_Inherent,$08
001EEE  1                AWordR 'RSR,',A_Inherent,$09
001EEE  1                AWordR 'RI,',A_Inherent,$0A
001EEE  1                AWordR 'RIM,',A_Inherent,$0B
001EEE  1               ; AWordR 'ELO,',A_Inherent,$0C
001EEE  1                AWordR 'PCX,',A_Inherent,$0D
001EEE  1                AWordR 'DLY,',A_Inherent,$0E
001EEE  1                AWordR 'RSYS,',A_Inherent,$0F
001EEE  1               
001EEE  1                AWordR 'INAB,',A_Inherent,$28
001EEE  1                AWordR 'DCAB,',A_Inherent,$29
001EEE  1                AWordR 'CLAB,',A_Inherent,$2a
001EEE  1                AWordR 'IVAB,',A_Inherent,$2b
001EEE  1                AWordR 'SRAB,',A_Inherent,$2c
001EEE  1                AWordR 'SLAB,',A_Inherent,$2d
001EEE  1                AWordR 'INA,',A_Inherent,$38
001EEE  1                AWordR 'DCA,',A_Inherent,$39
001EEE  1                AWordR 'CLA,',A_Inherent,$3a
001EEE  1                AWordR 'IVA,',A_Inherent,$3b
001EEE  1                AWordR 'SRA,',A_Inherent,$3c
001EEE  1                AWordR 'SLA,',A_Inherent,$3d
001EEE  1                AWordR 'INX,',A_Inherent,$3e
001EEE  1                AWordR 'DCX,',A_Inherent,$3f
001EEE  1               
001EEE  1                AWordR 'AABB,',A_Inherent,$48
001EEE  1                AWordR 'SABB,',A_Inherent,$49
001EEE  1                AWordR 'NABB,',A_Inherent,$4a
001EEE  1                AWordR 'XAXB,',A_Inherent,$4b
001EEE  1                AWordR 'XAYB,',A_Inherent,$4c
001EEE  1                AWordR 'XABB,',A_Inherent,$4d
001EEE  1                AWordR 'XAZB,',A_Inherent,$4e
001EEE  1                AWordR 'XASB,',A_Inherent,$4f
001EEE  1               
001EEE  1                AWordR 'AAB,',A_Inherent,$58
001EEE  1                AWordR 'SAB,',A_Inherent,$59
001EEE  1                AWordR 'NAB,',A_Inherent,$5a
001EEE  1                AWordR 'XAX,',A_Inherent,$5b
001EEE  1                AWordR 'XAY,',A_Inherent,$5c
001EEE  1                AWordR 'XAB,',A_Inherent,$5d
001EEE  1                AWordR 'XAZ,',A_Inherent,$5e
001EEE  1                AWordR 'XAS,',A_Inherent,$5f
001EEE  1               
001EEE  1                AWordD 'SYSCALL,',A_Inherent,$76
001EEE  1               
001EEE  1               A_Rel: ; ( adr -- ) \ do instruction with relative addressing
001EEE  1                 ;	LDAL 0		; disassembly routine
001EEE  1               	LDAA XW		;compile opcode
001EEE  1               	JSRD CCommaA
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	LDAX ZW,ModBRPB,0	; pop addr
001EEE  1               	LDBD VDP		; calc displacement
001EEE  1               	INR BW,1
001EEE  1               	SAB
001EEE  1               	XFR AW,BW		; check range
001EEE  1               	SLA BW,8
001EEE  1               	SRA BW,8
001EEE  1               	SAB
001EEE  1               	BNZ @Err
001EEE  1               	JSRD CCommaA		; compile displacement
001EEE  1               	JMPD AIsClear
001EEE  1               
001EEE  1               @Err:	JSRD AClear
001EEE  1               	LDBL ERR_OutOfRange
001EEE  1               	JMPD ErrorY
001EEE  1               
001EEE  1                AWordR 'BL,' ,A_Rel,$10	; Branch if Link (Carry) Set
001EEE  1                AWordR 'BNL,',A_Rel,$11	; Branch if Link (Carry) not Set
001EEE  1                AWordR 'BF,' ,A_Rel,$12	; Branch if Fault Set
001EEE  1                AWordR 'BNF,',A_Rel,$13	; Branch if Fault not Set
001EEE  1                AWordR 'BZ ,',A_Rel,$14	; Branch if V (Z) flag set
001EEE  1                AWordR 'BNZ,',A_Rel,$15	; Branch if V (Z) flag clear
001EEE  1                AWordR 'BM,' ,A_Rel,$16	; Branch if Minus flag set
001EEE  1                AWordR 'BP,' ,A_Rel,$17	; Branch on Positive (Minus flag clear)
001EEE  1                AWordR 'BGZ,',A_Rel,$18	; Branch if > 0 (!V && !Minus)
001EEE  1                AWordR 'BLE,',A_Rel,$19	; Branch if <= to 0 (V | Minus)
001EEE  1                AWordR 'BS1,',A_Rel,$1a	; Branch if Sense Switch 1 Set
001EEE  1                AWordR 'BS2,',A_Rel,$1b	; Branch if Sense Switch 2 Set
001EEE  1                AWordR 'BS3,',A_Rel,$1c	; Branch if Sense Switch 3 Set
001EEE  1                AWordR 'BS4,',A_Rel,$1d	; Branch if Sense Switch 4 Set
001EEE  1               ; : BTM,  ( adr -- ) A_Rel [ $1e c, ] ;  \ Branch on TTY Mark (CPU6?)
001EEE  1                AWordR 'RSYS,',A_Rel,$1f
001EEE  1                AWodR 'LDABR,',A_Rel,$83
001EEE  1                AWodR 'LDAR,',A_Rel,$93
001EEE  1                AWordR 'STABR,',A_Rel,$a3
001EEE  1                AWordR 'STAR,',A_Rel,$b3
001EEE  1                AWordR 'LDBBR,',  A_Rel,$c3
001EEE  1                AWordR 'LDBR,',   A_Rel,$d3
001EEE  1                AWordR 'STBBR,',A_Rel,$e3
001EEE  1                AWordR 'STBR,',A_Rel,$f3
001EEE  1                AWordR 'LDXR,',A_Rel,$63
001EEE  1                AWordR 'STXR,',A_Rel,$6b
001EEE  1                AWordD 'JMPR,',A_Rel,$73
001EEE  1                AWordD 'JSRR,',A_Rel,$7b
001EEE  1               
001EEE  1               
001EEE  1               A_RelInd: ; ( adr -- )
001EEE  1                 ;	LDAL 0		; disassembly routine
001EEE  1               	JMPR A_Rel	; compiles like A_Rel
001EEE  1               
001EEE  1                AWordR 'LDABRI,',A_RelInd,$84
001EEE  1                AWordR 'LDARI,' ,A_RelInd,$94
001EEE  1                AWordR 'STABRI,',A_RelInd,$a4
001EEE  1                AWordR 'STARI,' ,A_RelInd,$b4
001EEE  1                AWordR 'LDBBRI,',A_RelInd,$c4
001EEE  1                AWordR 'LDBRI,', A_RelInd,$d4
001EEE  1                AWordR 'STBBRI,',A_RelInd,$e4
001EEE  1                AWordR 'STBRI,' ,A_RelInd,$f4
001EEE  1                AWordR 'LDXRI,' ,A_RelInd,$64
001EEE  1                AWordR 'STXRI,' ,A_RelInd,$6c
001EEE  1                AWordD 'JMPRI,' ,A_RelInd,$74
001EEE  1                AWordD 'JSRRI,' ,A_RelInd,$7c
001EEE  1               
001EEE  1               
001EEE  1               A_RegB: ; ( -- n ) \ convert BReg to n
001EEE  1               	JSRD ARegPop
001EEE  1               	LDBL $e0
001EEE  1               	ADDB AL,BL
001EEE  1               	LDBL $10
001EEE  1               	SABB
001EEE  1               	BL @Err
001EEE  1               	RSR
001EEE  1               
001EEE  1               @Err:	JSRD PDotQuote
001EEE  1               	.byte 8,"Bad BReg"
001EEE  1               	JMPD Abort
001EEE  1               
001EEE  1               A_RegW: ; ( -- n ) \ convert WReg to n
001EEE  1               	JSRD ARegPop
001EEE  1               	LDBL $d0
001EEE  1               	ADDB AL,BL
001EEE  1               	LDBL $10
001EEE  1               	SABB
001EEE  1               	BL @Err
001EEE  1               	JMPD AIsClear
001EEE  1               
001EEE  1               @Err:	JSRD PDotQuote
001EEE  1               	.byte 8,"Bad WReg"
001EEE  1               	JMPD Abort
001EEE  1               
001EEE  1               A_RegV: ; ( n  -- )
001EEE  1               	SLAB			; shift reg to hi nibble
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	STABX SW,ModBMRB,0	; save reg
001EEE  1               	LDAA XW			; compile opcode
001EEE  1               	JSRD CCommaA
001EEE  1               	LDAA ZW
001EEE  1               	LDBL $fff0		; check range
001EEE  1               	NAB
001EEE  1               	BNZ @Err
001EEE  1               	LDBBX SW,ModBRPB,0
001EEE  1               	ORIB AL,BL
001EEE  1               	JSRD CCommaA
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	JMPD AIsClear
001EEE  1               
001EEE  1               A_RegBV: ;  ( n -- )
001EEE  1                  ;	LDAL 0
001EEE  1               	JSRR A_RegB
001EEE  1               	JMPR A_RegV
001EEE  1               A_RegBVp1: ; ( n -- )
001EEE  1                  ;	LDAL 0
001EEE  1               	LDAA ZW
001EEE  1               	DCA
001EEE  1               	STAA ZW
001EEE  1               	JSRR A_RegB
001EEE  1               	JMPR A_RegV
001EEE  1               A_RegWV: ;   ( n -- )
001EEE  1                 ;	LDAL 0
001EEE  1               	JSRR A_RegW
001EEE  1               	JMPR A_RegV
001EEE  1               A_RegWVp1L ; ( n -- )
001EEE  1                 ;	LDAL 0
001EEE  1               	LDAA ZW
001EEE  1               	DCA
001EEE  1               	STAA ZW
001EEE  1               	JSRR A_RegW
001EEE  1               	JMPR A_RegV
001EEE  1               
001EEE  1                AWordR 'INRB,',A_RegBV,$20
001EEE  1                AWordR 'DCRB,',A_RegBV,$21
001EEE  1                AWordR 'CLRB,',A_RegBV,$22
001EEE  1                AWordR 'IVRB,',A_RegBV,$23
001EEE  1                AWordR 'SRRB,',A_RegBVp1,$24
001EEE  1                AWordR 'SLRB,',A_RegBVp1,$25
001EEE  1                AWordR 'RRRB,',A_RegBVp1,$26
001EEE  1                AWordR 'RLRB,',A_RegBVp1,$27
001EEE  1                AWordR 'INR,',A_RegWV,$30
001EEE  1                AWordR 'DCR,',A_RegWV,$31
001EEE  1                AWordR 'CLR,',A_RegWV,$32
001EEE  1                AWordR 'IVR,',A_RegWV,$33
001EEE  1                AWordR 'SRR,',A_RegWVp1,$34
001EEE  1                AWordR 'SLR,',A_RegWVp1,$35
001EEE  1                AWordR 'RRR,',A_RegWVp1,$36
001EEE  1                AWordR 'RLR,',A_RegWVp1,$37
001EEE  1               
001EEE  1                AWordD 'PUSH,',A_RegBVp1,$7e
001EEE  1                AWordD 'POP,',A_RegBVp1,$7f
001EEE  1               
001EEE  1               
001EEE  1               A_BRegReg: ; ( DestReg SrcReg -- ) \ 2 registers
001EEE  1               	LDAA XW		; compile opcode
001EEE  1               	JSRR CCommaA
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	JSRD A_RegB
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	STABX SW,ModBMRB,0
001EEE  1               	JSRD A_RegB
001EEE  1               	LDBBX SW,ModBRPB,0
001EEE  1               	ORIB AL,BL
001EEE  1               	JSRD CCommaA
001EEE  1               	JMPD AIsClear
001EEE  1               
001EEE  1                AWordR 'ADDB,',A_BRegReg,$40
001EEE  1                AWordR 'SUBB,',A_BRegReg,$41
001EEE  1                AWordR 'ANDB,',A_BRegReg,$42
001EEE  1                AWordR 'ORIB,',A_BRegReg,$43
001EEE  1                AWordR 'OREB,',A_BRegReg,$44
001EEE  1                AWordR 'XFRB,',A_BRegReg,$45
001EEE  1               
001EEE  1               
001EEE  1               A_WRegReg: ;  ( DestReg SrcReg -- ) \ 2 registers
001EEE  1                 ;	LDAL 0
001EEE  1               	LDAA XW		; copmile opcode
001EEE  1               	JSRD CCommaA
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	JSRD A_RegW
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	STABX SW,ModBMRB,0
001EEE  1               	JSRD A_RegW
001EEE  1               	LDBBX SW,ModBRPB,0
001EEE  1               	ORI AL,BL
001EEE  1               	JSRD CCommaA
001EEE  1               	JMPD AIsClear
001EEE  1               
001EEE  1                AWordR 'ADD,',A_WRegReg,$50
001EEE  1                AWordR 'SUB,',A_WRegReg,$51
001EEE  1                AWordR 'AND,',A_WRegReg,$52
001EEE  1                AWordR 'ORI,',A_WRegReg,$53
001EEE  1                AWordR 'ORE,',A_WRegReg,$54
001EEE  1                AWordR 'XFR,',A_WRegReg,$55
001EEE  1               
001EEE  1               
001EEE  1               A_LitB: ; ( n -- ) \ byte literal
001EEE  1                 ;	LDAL 0
001EEE  1               	LDABA XW		; compile opcode
001EEE  1               	JSRD CCommaA
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	LDABA ZW		; check operand
001EEE  1               	BNZ @Err
001EEE  1               	JSRD CComma		; compile operand
001EEE  1               	JMPD AIsClear
001EEE  1               @Err:	JSRD PDotQuote
001EEE  1               	.byte 25,"Byte literal out of range"
001EEE  1               	JMPD Abort
001EEE  1               
001EEE  1                AWordR 'LDABL,',A_LitB,$80
001EEE  1                AWordR 'STABL,',A_LitB,$a0
001EEE  1                AWordR 'LDBBL,',  A_LitB,$c0
001EEE  1                AWordR 'STBBL,',A_LitB,$E0
001EEE  1               
001EEE  1               A_LitW: ; ( n -- )  \ word literal
001EEE  1                 ;	LDAL 0
001EEE  1               	LDABA XW		; compile opcode
001EEE  1               	JSRD CCommaA
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	JSRD Comma		; compile operand
001EEE  1               	JMPD AIsClear
001EEE  1                AWordR 'LDAL,',A_LitW,$90
001EEE  1                AWordR 'STAL,',A_LitW,$b0
001EEE  1                AWordR 'LDBL,',A_LitW,$d0
001EEE  1                AWordR 'STBL,',A_LitW,$F0
001EEE  1                AWordR 'LDXL,',A_LitW,$60
001EEE  1                AWordR 'STXL,',A_LitW,$68
001EEE  1               
001EEE  1               A_Dir: ; ( n -- )  \ direct adr
001EEE  1                 ;	LDAL 0
001EEE  1               	JMPR A_LitW
001EEE  1                AWordR 'LDABD,',A_Dir,$81
001EEE  1                AWordR 'LDAD,',A_Dir,$91
001EEE  1                AWordR 'STABD,',A_Dir,$a1
001EEE  1                AWordR 'STAD,',A_Dir,$b1
001EEE  1                AWordR 'LDBBD,',  A_Dir,$c1
001EEE  1                AWordR 'LDBD,',   A_Dir,$d1
001EEE  1                AWordR 'STBBD,',A_Dir,$e1
001EEE  1                AWordR 'STBD,', A_Dir,$f1
001EEE  1                AWordR 'LDXD,',A_Dir,$61
001EEE  1                AWordR 'STXD,',A_Dir,$69
001EEE  1                AWordD 'JMPD,',A_Dir,$71
001EEE  1                AWordD 'JSRD,',A_Dir,$79
001EEE  1               
001EEE  1               A_DirInd: ; ( n -- ) \ direct indirect
001EEE  1                 ;	LDAL 0
001EEE  1               	JMPR A_Dir
001EEE  1                AWordR 'LDABI,',A_DirInd,$82
001EEE  1                AWordR 'LDAI,',A_DirInd,$92
001EEE  1                AWordR 'STABI,',A_DirInd,$a2
001EEE  1                AWordR 'STAI,',A_DirInd,$b2
001EEE  1                AWordR 'LDBBI,',  A_DirInd,$c2
001EEE  1                AWordR 'LDBI,',   A_DirInd,$d2
001EEE  1                AWordR 'STBBI,',A_DirInd,$e2
001EEE  1                AWordR 'STBI,', A_DirInd,$f2
001EEE  1                AWordR 'LDXI,',A_DirInd,$62
001EEE  1                AWordR 'STXI,',A_DirInd,$6a
001EEE  1                AWordD 'JMPI,',A_DirInd,$72
001EEE  1                AWordD 'JSRI,',A_DirInd,$7a
001EEE  1               
001EEE  1               A_Index: ; ( ?? -- )
001EEE  1                 ;	LDAL 0
001EEE  1               	LDABA XW		; compile opcode
001EEE  1               	JSRD CCommaA
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	JSRD A_RegW		; get reg
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	SLAB
001EEE  1               	LDBBD AMode
001EEE  1               	BM @Err
001EEE  1               	ORI AL,BL
001EEE  1               	LDBBL $ff
001EEE  1               	STBBD AMode
001EEE  1               	STABX SW,ModBMRB,0
001EEE  1               	JSRD CCommaA		; compile reg & mode
001EEE  1               	LDABX SW,ModBRPB,0
001EEE  1               	LDBBL 8			; offset byte?
001EEE  1               	NABB
001EEE  1               	BZ @18
001EEE  1               	JSRD CComma		;   compile offset byte
001EEE  1               @18:	JMPD AIsClear
001EEE  1               
001EEE  1               @Err:	JSRD PDotQuote
001EEE  1               	.byte "no mode"
001EEE  1               	JMPD Abort
001EEE  1               
001EEE  1                AWordR 'LDABX,',A_Index,$85
001EEE  1                AWordR 'LDAX,',A_Index,$95
001EEE  1                AWordR 'STABX,',A_Index,$a5
001EEE  1                AWordR 'STAX,',A_Index,$b5
001EEE  1                AWordR 'LDBBX,',A_Index,$c5
001EEE  1                AWordR 'LDBX,', A_Index,$d5
001EEE  1                AWordR 'STBBX,',A_Index,$e5
001EEE  1                AWordR 'STBX,',A_Index,$f5
001EEE  1                AWordR 'LDXX,',A_Index,$65
001EEE  1                AWordR 'STXX,',A_Index,$6d
001EEE  1                AWordD 'JMPX,',A_Index,$75
001EEE  1                AWordD 'JSRX,',A_Index,$7d
001EEE  1               
001EEE  1               A_RegInd: ; ( WReg -- ) \ register indirect
001EEE  1                 ;	LDAL 0
001EEE  1               	JSRD A_RegW
001EEE  1               	SRAB
001EEE  1               	LDBBA XW
001EEE  1               	LDXX SW,ModBRPB,0
001EEE  1               	ORIB AL,BL
001EEE  1               	JSRD CComma		; compile opcode
001EEE  1               	JMPD AIsClear
001EEE  1               
001EEE  1                AWordR 'LDABA,',A_RegInd,$88
001EEE  1                AWordR 'LDAA,',A_RegInd,$98
001EEE  1                AWordR 'STABA,',A_RegInd,$a8
001EEE  1                AWordR 'STAA,',A_RegInd,$b8
001EEE  1                AWordR 'LDBBA,',A_RegInd,$c8
001EEE  1                AWordR 'LDBA,',A_RegInd,$d8
001EEE  1                AWordR 'STBBA,',A_RegInd,$e8
001EEE  1                AWordR 'STBA,',A_RegInd,$f8
001EEE  1               
001EEE  1               
001EEE  1               ;  $2E ; Memory mapping?
001EEE  1               ;  $2F ; DMA?
001EEE  1               
001EEE  1               ;  .macro 66
001EEE  1               ;  .macro 67
001EEE  1               
001EEE  1               ; .byte $46	; memory block ops
001EEE  1               ; .byte $47 ; string ops
001EEE  1               
001EEE  1               ;  .macro 56
001EEE  1               ;  .macro 57
001EEE  1               
001EEE  1               ;  .macro 77
001EEE  1               ;  .macro $70
001EEE  1               ;  .macro 78?
001EEE  1               
001EEE  1               ;  .macro 86
001EEE  1               ;  .macro 87
001EEE  1               ;  .macro 96
001EEE  1               ;  .macro 97
001EEE  1               ;  .macro A6
001EEE  1               ;  .macro A7
001EEE  1               ; .macro B6
001EEE  1               ; .macro  B7
001EEE  1               ;  .macro C6
001EEE  1               ;  .macro C7
001EEE  1               ;  .macro E6
001EEE  1               ;  .macro E7
001EEE  1               
001EEE  1               ;  .macro F6
001EEE  1               ;  .macro F7
001EEE  1               
001EEE  1               ;  .macro D6
001EEE  1               ;  .macro D7
001EEE  1               ;  .macro 6E
001EEE  1               ;  .macro 6F
001EEE  1               
001EEE  1               
001EEE  1                .endif ; assembler & disassembler
001EEE  1               
001EEE  1               	.if 0
001EEE  1               ;-------------------------------------------------------------------------
001EEE  1               ; 12. The optional Floating-Point word set
001EEE  1               ; https://forth-standard.org/standard/float
001EEE  1               
001EEE  1               
001EEE  1               
001EEE  1               
001EEE  1               	.endif  ; floating point
001EEE  1               
001EEE  1               NTOP	= DictLink
001EEE  1               TOP:
001EEE  1               
001EEE  1               
001EEE  1               ;	.org $fc00 ; bootstrap ROM for simulator ------------------------------------
001EEE  1               ;
001EEE  1               ;	LDAL ReEnter	; set restart vector
001EEE  1               ;	STAD $1a
001EEE  1               ;	JMPD Enter	; just jmp to FORTH
001EEE  1               
001EEE  1               	.end
