; Subroutine threaded version of FIG FORTH for Centurion CPU6.
;	CPU6 is a follow-on from "Eldorado ee200"
; https://github.com/Nakazoto/CenturionComputer/
; See also: "Starting FORTH" https://www.forth.com/starting-forth/
; See also: https://forth-standard.org
; See also: http://uefi.org

; by Lee Pivonka

; Based on FIG FORTH 6502 from http://6502.org/source/ .

;			 Through the courtesy of
;
;			  FORTH INTEREST GROUP
;			     P.O. BOX  2154
;			  OAKLAND, CALIFORNIA
;				 94621
;
;
;			      Release 1.1
;
;			 with compiler security
;				   and
;			 variable length names
;
;    Further distribution must include the above notice.
;    The FIG installation Manual is required as it contains
;    the model of FORTH and glossary of the system.
;    Available from FIG at the above address for **.** postpaid.
;
;    Translated from the FIG model by W.F. Ragsdale with input-
;    output given for the Rockwell System-65. Transportation to
;    other systems requires only the alteration of :
;		  EmitA KeyA QTerminalA RSlashW Mon

; This version has 2 major modifications from the FIG version:
; * Subroutine threaded code.  There is no DoCol or other colon routines - it's all CPU6 code.
;	There is no PFA or CFA - words start with CPU6 code.
;	Words that use the CFA PFA model start with a JSR to the code, followed by the parameters.
; * Word headers are remodeled.  There are no NFA PFA CFA versions - there is a single pointer to the
;	CPU6 code, & header fields are at negative offsets from that.

; This file includes machine code definitions of all of the core words.
; When this code is running, additional definitions can be typed in or compiled from disk.

; Standard CPU6 register usage:
; A	scratch
; B	scratch
; X	CPU6, scratch
; Y	scratch
; Z	FORTH parameter stack pointer
; S	CPU6, FORTH return stack pointer
; C	CPU6
; P	CPU6

; Compile with ca65 from cc65 - https://cc65.github.io/

	.list on
	.listbytes unlimited ;include all object bytes in listing (since we load the listing file)
	.feature loose_string_term ; used to put quotes in strings

	.include "0instructions.txt"  ; define Centurion CPU6 instructions


; handy constants

; Sector size is a bit of a mess on Centurion.  Many devices use 400 byte sectors.
;   How to map that to FORTH 1024 byte screens is unfinished.
SectorSize =256		; sector size in bytes
NBUF =1024/SectorSize	; number of buffers desired in RAM
			;     (SectorSize*NBUF >= 1024 bytes)
Sectors	=800		; sectors per drive
			;    forcing high drive to zero
SECTL	=2*Sectors	; sector limit for two drives


; Error, Warning, and other messages - external text starting on on screens 4
Err_0			=  0 ; abort with no message
Err_StackUnderflow	=  1 ; EMPTY STACK
Err_DictionaryFull	=  2 ; DICTIONARY FULL
; Err_3			=  3 ; HAS INCORRECT ADDRESS MODE
Err_IsntUnique		=  4 ; ISN'T UNIQUE
;  5
; Err_06 		=  6 ; DISC RANGE
Err_StackOverflow	=  7 ; stack overflow
Err_8			=  8 ; disk i/o error
;  9
; 10
; 11
; 12
; 13
; 14
Err_TriadFooter		  = 15  ; TRIAD footer message
; 16
Err_CompileOnly		  = $11 ; COMPILATION ONLY, USE IN DEFINITION
Err_ExecuteOnly		  = $12 ; EXECUTION ONLY
Err_ConditionalsNotPaired = $13 ; CONDITIONALS NOT PAIRED
Err_DefinitionNotFinished = $14 ; DEFINITION NOT FINISHED
Err_InProtectedDictionary = $15 ; IN PROTECTED DICTIONARY
Err_UseOnlyWhenLoading    = $16 ; USE ONLY WHEN LOADING
; $17
; $18 DECLARE VOCABULARY


	.org $7000 ; more uninitialized RAM

DictTop:	; From here downward to the top of the dictionary is free
		; space where the user's applications are compiled.

VUse:	.res 2		; the address of the block buffer to use next, as the least recently written.
VPrev:	.res 2		; the address of the disc buffer most recently referenced.
			;   The UPDATE command marks this buffer to be later written to disc.

TIBX:	.res 86		; terminal input buffer

RamDiskStart: .res 2	; RAM disk: start of memory buffer
RamDiskCount: .res 2	; RAM disk: count of 256 byte blocks

UArea:
VUser: ; user area variables, partially initialized from ORIG
	.res 2	;+00:	ptr latest ROM word
VBS:	.res 2	;+02:	backspace char
VUA:	.res 2	;+04:	ptr user area (direct page IS the user area)
VS0:	.res 2	;+06:	initial value for the parameter stack index
VR0:	.res 2	;+08:	initial value of the return stack ptr
VTIB:	.res 2	;+0a:	Address of the terminal input buffer.
VWidth:	.res 2	;+0c:	Maximum number of letters saved in the compilation of a definitions' name.
		;	It must be 1 thru 31, with a default of 31.
		;	The name char cound and its natural chars are saved, up to the value in WIDTH.
		;	The value may be changed at any time within the above limits.
VWarning: .res 2 ;+0e:	Value controlling messages.  If =1 disc is present,
		;	and screen 4 of drive 0 is the base location for messages.
		;	If =0, no disc is present and messages will be presented by number.
		;	if =-1, execute (ABORT) for a user specified procedure.
		;	See MESSAGE ERROR
VFence:	.res 2	;+10:	Address below which FORGETting is trapped.
		;	To forget below this point the user must alter the contents of FENCE .
VDP:	.res 2	;+12:	ptr next available dictionary memory location
		;	The value may be read by HERE and altered by ALLOT.

VVoc_Link: .res 2 ;+14:	Containing the address of a field in the definition of the most
		;	recently created vocabulary.  All vocabulary names are linked by these fields
		;	to allow control for FORGETting thru multiple vocabularys.

VBlk:	.res 2	;+16:	Block (not screen) number being interpreted.
		;	If 0, input is being taken from the terminal input buffer.
		;	https://forth-standard.org/standard/block/BLK
VIn:	.res 2	;+18:	Byte offset within the current input text buffer (terminal or disc)
		;	from which the next text will be accepted.
		;	WORD uses and moves the value of IN .
VOut:	.res 2	;+1A:	A value incremented by EMIT .
		;	The user may alter and examine OUT to control display formatting.
VScr:	.res 2	;+1C:	the screen number most recently referenced by LIST .
		;	https://forth-standard.org/standard/block/SCR
VOffset: .res 2	;+1E:	disc block offset in 1024 byte blocks
		;	The contents of OFFSET is added to the block number in BLOCK
		;	to allow for this selection.
		;	May contain a block offset to disc drives.  The contents
		;	of OFFSET is added to the stack number by BLOCK .
		;	Messages by MESSAGE are independent of OFFSET .
		;	See BLOCK DR0 DR1 MESSAGE

VContext: .res 2 ;+20:	pointer to the vocabulary within which dictionary searching will first begin.
		;	ptr to dictionary head in vocabulary word
VCurrent: .res 2 ;+22:	ptr to dictionary head in vocabulary word
VState:	.res 2	;+24:	compilation state.  A non-zero value indicates compilation.
		;	The value itself may be implementation dependent.
		;	Contains the compilation-state flag.
		;	STATE is true when in compilation state, false otherwise.
		;	The true value in STATE is non-zero, but is otherwise implementation-defined.
		;	Only the following standard words alter the value in STATE:
		;		: (colon), ; (semicolon), ABORT, QUIT, :NONAME, [ (left-bracket), ] (right-bracket).
		;	Note: A program shall not directly alter the contents of STATE.
VBase:	.res 2	;+26:	the current number base used for input and output conversion; 2..36
VDPL:	.res 2	;+28:	number of digits to the rights of the decimal on double integer input.
		;	It may also be used to hold output column location of a decimal point,
		;	in user generated formatting.
		;	The default value on signel number input is -1 (none).
VFld:	.res 2	;+2A:	for control of number output field width. Presently unused in fig-FORTH.
VCSP:	.res 2	;+2C:	temporarily store the stack pointer position, for compilation error checking.
VRNum:	.res 2	;+2E:	may contain the location of an editing cursor, or other file related function.
VHld:	.res 2	;+30:	holds the address of the latest char of text during numeric output conversion.
VLineComment: .res 1	; ignore remainder of line

VFPtr:	.res 2	;	Floating-point stack ptr
VFpLo:	.res 2	;	"                " lo limit
VFpHi:	.res 2	;	"                " hi limit

BOS:	.res $7e	; parameter (data) stack
TOS:	.res 8		; top of parameter stack, with extra padding

;N:	.res 8		; scratch workspace.

RStack:	.res 128	; return stack
RStackE:

UserSize: ; end of user ara variables
;	.assert <*<$100, error, "user area overflowed"



RndState: .res 4	; random # state

DArea:	.res (SectorSize+4)*NBUF ; disk buffer space.
DAreaEnd:



INL_End = $0909	; RSR, & ha_inline code end marker

; Bit masks in "flags & length" byte of word header:
ha_inline    = $80 ; can be compiled by copying inline
ha_immediate = $40 ; aka precedence bit
ha_smudge    = $20 ; do not find this word by name
ha_length    = $1f ; # of chars in name (including ones > vWidth)

  .macro FHdr name,flags ; compile a FORTH word header
	.local L1,L2
L1:	.byte name	;name of word as a string (no leading count byte)
L2:	.byte L2-L1+flags ;flags & length of name (see ha_*)
	.dbyt DictLink	;LFA: link to previous word's CFA in vocabulary chain
DictLink .set *
;		The fields above are at negative offsets from label.
;label:	;NFA: same as CFA.  We access header fields using negative offsets from CFA.
;	;CFA: CPU6 code starts here.  This is the address that "find" returns.
;		Words that want PFA (eg CREATEd words) will have a JSR to the handler code,
;		  followed by the PFA area.  The JSR return address (+1) points to the PFA.
	.endmacro

DictLink .set 0 ; used to build the FHdr link chain.
		; 0 indicates end of vocabulary list

; The FHdr line of each entry shows a symbolic description of the action of the procedure
; on the parameter stack.  The symbols indicate the order in which input parameters have
; been placed on the stack.  "---" indicate the execution point; any parameters left on the
; stack are listed after.  In this notation, the top of the stack is to the right.
;
; The symbols include:
;
; addr	memory address
; b	8 bit byte (i.e. hi 8  bits zero)
; c	ASCII character (hi 9 bits zero)
; d	32 bit signed double integer, most significant portion with sign on top of stack.
; f	boolean flag. 0=false, non-zero=true
; ff	boolean false flag=0
; n	16 bit signed integer number
; u	16 bit unsigned integer
; tf	boolean true flag (non-zero)
;
; The capital letters on the right show definition characteristics:
;   (not used)
; C	May only be used within a colon definition. A digit indicates number of memory
;	addresses used, if other than one.
; E	intended for execution only.
; L0	Level Zero definition of FORTH-78
; L1	Level One definition of FORTH-78
; P	Has precedence bit (immediate) set. Will execute even when compliling.
; U	A user variable.
;
; Unless otherwise noted, all references to numbers are for 16 bit signed integers.
; 16 bit numbers are big-endian, like the hardware.
; For 32 bit signed double numbers, the most significant part (with the sign) is on top.
;
; All arithmetic is implicitly 16 bit signed integer math, with error and underflow
; indication unspecified.


	.org $200 ; start of program RAM ==========================================================
ORIG:	; Start of boot up parameters.  34 bytes.

Enter:	NOPC		; +00 User cold entry point
	JMPD Cold
ReEnter: NOPC		; +04 User warm entry point
	JMPD Warm
	.dbyt 0,0	; +08 CPU6 in radix-36

; Initial values copied to VUser.
; These values are altered as you make permanent extensions to your installation.
	.dbyt NTOP	; +0C Last word
	.dbyt $08	; +0E Backspace Character
	.dbyt UArea	; +10 Initial User Area
	.dbyt TOS	; +12 S0 - Initial Top of Stack (in user area)
	.dbyt RStackE	; +14 R0 - Initial Top of Return Stack
	.dbyt TIBX	; +16 Initial terminal input buffer
	.dbyt 31	; +18 Initial name field width (not used)
	.dbyt 0		; +1A Initial warning
	.dbyt TOP	; +1C Initial fence address
	.dbyt TOP	; +1E Initial top of dictionary
	.dbyt Forth+3+2	; +20 Initial Vocabulary link ptr.


 FHdr 'Empty-RStack',0 ; ( -- ) ( R: ... -- )  empty the return stack (load from user variable R0 ) .
EmptyRStack:
	LDAD VR0	; load S
	XAS
	JMPX XW,ModBRB,0 ; return (without adjusting S)


	.if 0
 FHdr 'RP!',0 ; ( -- )  FIG alias
	JMPR EmptyRStack
	.endif


	.if 0
 FHdr 'RDepth',0 ; ( -- n )  return # of cells on return stack (not including this routine)
	LDAD VR0
	SUB AW,SW
	INR AW,2
	JMPR Depth3
	.endif


 FHdr 'Empty-Stack',0 ; ( ... -- )  empty the param stack.
EmptyStack:
	LDAD VS0		; load the parameter stack pointer from S0 
	XAZ
	LDBD VFpHi		; also empty FP stack
	STBD VFPtr
	RSR


	.if 0
 FHdr 'SP!',0 ; ( -- )  FIG alias
	JMPR EmptyStack
	.endif


 FHdr 'Depth',0 ; ( -- n )  https://forth-standard.org/standard/core/DEPTH
; Return the address of the stack position to the top of the stack, as it was before Depth was executed.
; (e.g. 1 2 Depth  . . .  would type 2 2 1 )
Depth:	LDAD VS0
	SUB AW,ZW
Depth3:	IVR AW,1		; A = VS0-param_stack_ptr
	SRA			; /2
	STAX ZW,ModBMRB,0	; push it
	RSR			; return


	.if 0
 FHdr 'SP@',0 ; ( -- n )  FIG alias
	JMPR Depth
	.endif


 FHdr 'Drop',ha_inline ; ( n -- )  Drop a number from the stack.
   ; https://forth-standard.org/standard/core/DROP
Drop:	INR ZW,2		; bump the param stack index up 1 cell
	.dbyt INL_End		; return


 FHdr '2Drop',ha_inline ; ( n n -- )
   ; https://forth-standard.org/standard/core/TwoDROP
TwoDrop:
	INR ZW,4		; bump the param stack index up 2 cells
	.dbyt INL_End		; return


 FHdr 'Rot',0 ; ( n1 n2 n3 -- n2 n3 n1 )  https://forth-standard.org/standard/core/ROT
   ; Rotate the top 3 values on the stack, bringing the 3rd to the top.
   ; https://forth-standard.org/standard/core/ROT
Rot:	LDAX ZW,ModNBRB,4	; Y=n1
	LDBX ZW,ModNBRB,2	; A=n2
	STBX ZW,ModNBRB,4	; store 3rd-on-stack
	LDBA ZW			; A=n1
	STBX ZW,ModNBRB,2	; store next-on-stack
	STAA ZW			; store top-on-stack
	RSR			; return


	.if 0
 FHdr '-Rot',0 ; ( n1 n2 n3 -- n3 n1 n2 )  rotate the other way
MRot:	; small but slow
	JSRR Rot
	JMPR Rot
	.endif


	.if 0
 FHdr '2Rot',0 ; ( d1 d2 d3 -- d2 d3 d1 )  Rotate the top 3 values on the stack
   ; https://forth-standard.org/standard/double/TwoROT
TwoRot:	DCR ZW,2		; do hi word
	JSRR @10
	INR ZW,2		; do lo word
@10:	LDAX ZW,ModNBRB,8+2	; Y=n1
	LDBX ZW,ModNBRB,4+2	; A=n2
	STBX ZW,ModNBRB,8+2	; store 3rd-on-stack
	LDBX ZW,ModNBRB,0+2	; A=n1
	STBX ZW,ModNBRB,4+2	; store next-on-stack
	STAX ZW,ModNBRB,0+2	; store top-on-stack
	RSR			; return
	.endif


	.if 0
 FHdr 'Roll',0 ; ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
   ; Remove u. Rotate u+1 items on the top of the stack.
   ; An ambiguous condition exists if there are less than u+2 items on the stack before ROLL is executed.
   ; https://forth-standard.org/standard/core/ROLL
Roll:	JSRD ABort ;???
	.endif


 FHdr 'Swap',0 ; ( n1 n2 -- n2 n1 )  Exchange the top 2 values on the stack.
   ; https://forth-standard.org/standard/core/SWAP
Swap:	LDBX ZW,ModBRPB,0	; B=n2
	LDAA ZW			; A=n1
	STBA ZW			; store next-on-stack
	STAX ZW,ModBMRB,0	; store top-on-stack
	RSR			; return


 FHdr '2Swap',0 ; ( d1 d2 -- d2 d1 )  Exchange top 2 double values on the stack.
   ; https://forth-standard.org/standard/core/TwoSWAP
TwoSwap:
	LDBX ZW,ModNBRB,6	; swap lo words
	LDAX ZW,ModNBRB,2
	STBX ZW,ModNBRB,2
	STAX ZW,ModNBRB,6
	LDBX ZW,ModNBRB,4	; swap hi words
	LDAA ZW
	STBA ZW
	STAX ZW,ModNBRB,4
	RSR			; return


 FHdr 'Over',ha_inline ; ( n1 n2 -- n1 n2 n1 )  Copy the second stack value, placing it as the new top.
   ; https://forth-standard.org/standard/core/OVER
Over:	LDAX ZW,ModNBRB,2	; get next-on-stack
	STAX ZW,ModBMRB,0	; push it
	.dbyt INL_End		; return


 FHdr '2Over',0 ; ( d1 d2 -- d1 d2 d1 )  Copy the 2nd double value
   ; https://forth-standard.org/standard/core/TwoOVER
TwoOver:
	LDBX ZW,ModNBRB,4	; get d1.hi word
	LDAX ZW,ModNBRB,6	; get d1.lo word
	JMPR PushBA


 FHdr 'Dup',ha_inline ; ( n1 -- n1 n1 )  Duplicate the value on the stack.
   ; https://forth-standard.org/standard/core/DUP
Dup:	LDAA ZW
PushA:	STAX ZW,ModBMRB,0 ; pushes AW register to the param stack.
	.dbyt INL_End


 FHdr '2Dup',0 ; ( d1 -- d1 d1 )  Duplicate double value o the stack.
   ; https://forth-standard.org/standard/core/TwoDUP
TwoDup:	LDBA ZW			; get hi word
	LDAX ZW,ModNBRB,2	; get lo word
PushBA:	STAX ZW,ModBMRB,0	; push lo word
	STBX ZW,ModBMRB,0	; push hi word
	RSR


 FHdr '?Dup',0	; ( n1 -- n1    ) (if zero)
		; ( n1 -- n1 n1 ) (non-zero)
   ; Reproduce n1 only if it is non-zero.  This is usually used to copy a
   ; value just before IF, to eliminate the need for an ELSE part to drop it.
   ; https://forth-standard.org/standard/core/qDUP
QDup:	LDAA ZW			; n1<>0?
	BNZ PushA		;   push it & return
	RSR			; return


	.if 0
 FHdr '-Dup',0	; FIG alias
	JMPR QDup
	.endif


	.if 0
 FHdr 'Pick',0 ; ( xu...x1 x0 u -- xu...x1 x0 xu )  Remove u. Copy the xu to the top of the stack.
   ; An ambiguous condition exists if there are less than u+2 items on the stack before PICK is executed.
   ; https://forth-standard.org/standard/core/PICK
	.endif


 FHdr 'Nip',ha_inline ; ( n1 n2 -- n2 )   Drop the first item below the top of stack.
   ; https://forth-standard.org/standard/core/NIP
Nip:	LDAX ZW,ModBRPB,0	; pop n2
Nip3:	STAA ZW			; store as top-of-stack
	.dbyt INL_End		; return


 FHdr '2Nip',0 ; ( d1 d2 -- d2 )
TwoNip:	LDBX ZW,ModBRPB,0	; pop d2.hi
	LDAX ZW,ModBRPB,0	; pop d2.lo
	STBA ZW			; store d.hi
	STAX ZW,ModNBRB,2	; store d.lo
	RSR


	.if 0
 FHdr 'Tuck',0 ; ( x1 x2 -- x2 x1 x2 )
   ; Copy the first (top) stack item below the second stack item.
   ; https://forth-standard.org/standard/core/TUCK
Tuck:	LDAX ZW,ModBRPB,0	; pop x2
	LDBA ZW			; get x1
	STAA ZW
	STBX ZW,ModBMRB,0
	STAX ZW,ModBMRB,0
	RSR
	.endif


 FHdr 'Min',0 ; ( n1 n2 -- n3 )	Leave the smaller of two numbers.
   ; https://forth-standard.org/standard/core/MIN
Min:	LDAX ZW,ModBRPB,0	; pop n2
	LDBA ZW			; get n1
	SAB			; B=A-B
	BF Max3			; overflow?
Min3:	BM Nip3			; keep n2, return
	RSR			; return


 FHdr 'Max',0 ; ( n1 n2 -- n3 )	Leave the greater of two numbers.
   ; https://forth-standard.org/standard/core/MAX
Max:	LDAX ZW,ModBRPB,0	; pop n2
	LDBA ZW			; get n1
	SAB			; B=A-B
	BF Min3			; overflow?
Max3:	BP Nip3			; keep n2, return
	RSR			; return


 FHdr 'DMax',0 ; ( d1 d2 -- d )
   ; https://forth-standard.org/standard/double/DMAX
DMax:	LDAX ZW,ModBRPB,0	; pop d2.hi
	XAY
	LDAX ZW,ModBRPB,0	; pop d2.lo
	LDBA ZW			; get d1.hi
	SUB BW,YW		; compare hi words
	BNZ @3
	LDBX ZW,ModNBRB,2	; get d1.lo
	SAB
	BL DMax7
	RSR

@3:	BF DMin3
DMax3:	BM DMax9
DMax7:	XFR BW,YW		; store d.hi
	STBA ZW		
	STAX ZW,ModNBRB,2	; store d.lo
DMax9:	RSR


 FHdr 'DMin',0 ; ( d1 d2 -- d )
   ; https://forth-standard.org/standard/double/DMIN
DMin:	LDAX ZW,ModBRPB,0	; pop d2.hi
	XAY
	LDAX ZW,ModBRPB,0	; pop d2.lo
	LDBA ZW			; get d1.hi
	SUB BW,YW		; compare hi words
	BNZ @3
	LDBX ZW,ModNBRB,2	; get d1.lo
	SAB
	BNL DMax7
	RSR

@3:	BF DMax3
DMin3:	BM DMax7
	RSR


	.if 0
 FHdr 'Within',0 ; ( n1 | u1 n2 | u2 n3 | u3 -- flag )
   ; Perform a comparison of a test value n1 | u1 with a lower limit n2 | u2 and an upper limit n3 | u3,
   ; returning true if either (n2 | u2 < n3 | u3 and (n2 | u2 <= n1 | u1 and n1 | u1 < n3 | u3)) or
   ; (n2 | u2 > n3 | u3 and (n2 | u2 <= n1 | u1 or n1 | u1 < n3 | u3)) is true, returning false otherwise.
   ; An ambiguous condition exists n1 | u1, n2 | u2, and n3 | u3 are not all the same type.
   ; https://forth-standard.org/standard/core/WITHIN
Within:	JSRD Abort ;???
	.endif


; Note that top-of-return-stack lives in X in the calling routine,
; so inline code is not R@="LDAA SW", >R="STAX SW,ModBMRB,0", R>="LDAX SW,ModBRPB,0"
 
 FHdr 'R@',0 ; ( R: n -- n ) ( -- n )  Copy the top of the return stack to the param stack.
   ; https://forth-standard.org/standard/core/RFetch
RAt:	LDAA SW			; get top of return stack of my caller
	STAX ZW,ModBMRB,0	; push it
	RSR			; return

	.if 0
 FHdr 'R',0 ; ( -- n )  FIG alias
	JMPR RAt
	.endif


 FHdr 'R>',0 ; ( R: n -- ) ( -- n )  https://forth-standard.org/standard/core/Rfrom
   ; Remove the top value from the return stack and leave it on the param stack.
   ; See >R and R@
RFrom:	LDAX SW,ModBRPB,0	; pop return stack, skipping my return addr in X
	STAX ZW,ModBMRB,0	; push n
	RSR


 FHdr '>R',0 ; ( n -- ) ( R: -- n )   https://forth-standard.org/standard/core/toR
   ; Remove a numbef from the computation stack and place as the most accessable
   ; on the return stack.  Use should be balanced with R> in the same definition.
   ; https://forth-standard.org/standard/core/toR
ToR:	LDAX ZW,ModBRPB,0	; pop n
	STAX SW,ModBMRB,0	; push n on return stack
	RSR


 FHdr '2>R',0 ; ( d -- ) ( R: -- d )
   ; https://forth-standard.org/standard/core/TwotoR
TwoToR:	LDAX ZW,ModBRPB,0	; pop d.hi
	LDBX ZW,ModBRPB,0	; pop d.lo
	PUSH AH,4		; push d.lo & d.hi
	RSR


 FHdr '2R@',0 ; ( -- d ) ( R: d -- d )
   ; https://forth-standard.org/standard/core/TwoRFetch
TwoRAt:	LDBA SW			; get d.hi
	LDAX SW,ModNBRB,2	; get d.lo
	JMPD PushBA


 FHdr '2R>',0 ; ( R: d -- ) ( -- d )
   ; https://forth-standard.org/standard/core/TwoRfrom
TwoRFrom:
	LDBX SW,ModBRPB,0	; pop d.hi
	LDAX SW,ModBRPB,0	; pop d.lo
	JMPD PushBA


	.if 0

 FHdr 'NR>',0
   ; Interpretation:
   ;   Interpretation semantics for this word are undefined.
   ; Execution:
   ;   ( -- i * x +n ) ( R: j * x +n -- )
   ;   Retrieve the items previously stored by an invocation of N>R. n is the number of items placed on the data stack.
   ;   It is an ambiguous condition if NR> is used with data not stored by N>R.
   ; https://forth-standard.org/standard/tools/NRfrom
NRFrom:
	JSRD Abort ;???


 FHdr 'N>R',0
   ; Interpretation:
   ;   Interpretation semantics for this word are undefined.
   ; Execution:
   ;   ( i * n +n -- ) ( R: -- j * x +n )
   ;   Remove n+1 items from the data stack and store them for later retrieval by NR>.
   ;   The return stack may be used to store the data. Until this data has been retrieved by NR>:
   ;   * this data will not be overwritten by a subsequent invocation of N>R and
   ;   * a program may not access data placed on the return stack before the invocation of N>R.
   ; https://forth-standard.org/standard/tools/NtoR
NToR:
	JSRD Abort ;???

	.endif


 FHdr 'Invert',ha_inline ; ( n1 -- n2 ) Invert bits
   ; see 0= for logical negate
   ; https://forth-standard.org/standard/core/INVERT
Invert:	LDAA ZW
	IVR AW,0
	STAA ZW
	.dbyt INL_End


 FHdr 'And',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical and of n1 and n2 as n3.
   ; https://forth-standard.org/standard/core/AND
AndD:	LDAX ZW,ModBRPB,0	; pop n2
	LDBA ZW			; get n1
	NAB			; and
	STBA ZW			; store result
	.dbyt INL_End		; return


 FHdr 'Or',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical or of two 16 bit values.
   ; https://forth-standard.org/standard/core/OR
Or:	LDAX ZW,ModBRPB,0	; pop n2
	LDBA ZW			; get n1
	ORI BW,AW
	STBA ZW			; store result
	.dbyt INL_End		; return


 FHdr 'Xor',ha_inline ; ( n1 n2 -- n3 )  Leave the bitwise logical exclusive-or of two values.
   ; https://forth-standard.org/standard/core/XOR
Xor:	LDAX ZW,ModBRPB,0	; pop n2
XorA:	LDBA ZW			; get n1
	ORE BW,AW
	STBA ZW			; store result
	.dbyt INL_End		; return


 FHdr '2*',ha_inline ; ( x1 -- x2 )  signed multiply by 2 (signed left shift)
   ; x2 is the result of shifting x1 one bit toward the most-significant bit, filling the vacated
   ; least-significant bit with zero.
   ; https://forth-standard.org/standard/core/TwoTimes
TwoStar:
	LDAA ZW
	SLA
	STAA ZW
	.dbyt INL_End


 FHdr 'D2*',0 ; ( xd1 -- xd2 )  signed double multiply by 2 (signed left shift)
   ; xd2 is the result of shifting xd1 one bit toward the most-significant bit, filling the vacated
   ; least-significant bit with zero.
   ; https://forth-standard.org/standard/double/DTwoTimes
DTwoStar:
	LDAX ZW,ModNBRB,2
	SLA
	STAX ZW,ModNBRB,2
	LDAA ZW
	RLR AW,1
	STAA ZW
	RSR


 FHdr '2/',ha_inline ; ( x1 -- x2 )  signed divide by  (signed right shift)
   ; x2 is the result of shifting x1 one bit toward the least-significant bit, leaving the most significant
   ; bit unchanged.
   ; https://forth-standard.org/standard/core/TwoDiv
TwoSlash:
	LDAA ZW
	SRA
	STAA ZW
	.dbyt INL_End


 FHdr 'D2/',0 ; ( xd1 -- xd2 )  signed double divide by 2 (signed right shift)
   ; xd2 is the result of shifting xd1 one bit toward the least-significant bit, leaving the most significant
   ; bit unchanged.
   ; https://forth-standard.org/standard/double/DTwoDiv
DDiv2:	LDAA ZW
	SRA
	STAA ZW
	LDAX ZW,ModNBRB,2
	RRR AW,1
	STAX ZW,ModNBRB,2
	RSR


 FHdr 'U2/',ha_inline ; ( u -- u/2 )   Unsigned divide by two (logical right shift)
   ; https://forth-standard.org/standard/core/TwoDiv "Shr"
UDiv2:	LDAA ZW
	RL
	RRR AW,1
	STAA ZW
	.dbyt INL_End


	.if 0
 FHdr 'UD2/',0 ; ( ud1 -- ud2 ) unsigned double divide by 2 (logical right shift)
	JSRR UDiv2
	LDAX ZW,ModNBRB,2
	RRR AW,1
	STAX ZW,ModNBRB,2
	RSR
	.endif


 FHdr 'ror',ha_inline ; ( x1 -- x2 )   Logical right-rotation of one bit-place
	LDAA ZW
	RRR AW,1
	STAA ZW
	.dbyt INL_End


 FHdr 'rol',ha_inline ; ( x1 -- x2 )   Logical left-rotation of one bit-place
	LDAA ZW
	RLR AW,1
	STAA ZW
	.dbyt INL_End


	.if 0

 FHdr 'LShift',0 ; ( x1 u -- x2 )  Perform a logical left shift of u bit-places on x1, giving x2.
   ; Put zeroes into the least significant bits vacated by the shift.
   ; An ambiguous condition exists if u is greater than or equal to the number of bits in a cell.
   ; https://forth-standard.org/standard/core/LSHIFT
LShift:	LDAX ZW,ModBRPB,0	; pop u
	BZ @9
	LDBA ZW			; get x1
@2:	SLR BW,1
	DCAB
	BNZ @2
	STBA ZW			; save x2
@9:	RSR


 FHdr 'RShift',0 ; ( x1 u -- x2 )  Perform a logical right shift of u bit-places on x1, giving x2.
   ; Put zeroes into the most significant bits vacated by the shift.
   ; An ambiguous condition exists if u is greater than or equal to the number of bits in a cell.
   ; https://forth-standard.org/standard/core/RSHIFT
RShift:	LDAX ZW,ModBRPB,0	; pop u
	BZ @9
	LDBA ZW			; get x1
@2:	RL
	RRR BW,1
	DCAB
	BNZ @2
	STBA ZW			; save x2
@9:	RSR

	.endif


 FHdr '1+',ha_inline ; ( n1 -- n2 )  Increment n1 by 1
   ; https://forth-standard.org/standard/core/OnePlus
OnePlus:
	LDAA ZW			; get n1
	INA
	STAA ZW			; store n2
	.dbyt INL_End		; return


 FHdr '2+',ha_inline ; ( n1 -- n2 )  Increment n1 by 2
TwoPlus:
	LDAA ZW			; get n1
	INR AW,2
	STAA ZW			; store n2
	.dbyt INL_End		; return


 FHdr '1-',ha_inline ; ( n1 -- n2 )  Decrement n1 by 1
   ; https://forth-standard.org/standard/core/OneMinus
OneMinus:
	LDAA ZW			; get n1
	DCA
	STAA ZW			; store n2
	.dbyt INL_End		; return


 FHdr '2-',ha_inline ; ( n1 -- n2 ) Decrement n1 by 2
TwoMinus:
	LDAA ZW			; get n1
	DCR AW,2		; subtract 2
	STAA ZW			; store n2
	.dbyt INL_End


 FHdr '+',ha_inline ; ( n1 n2 -- n_sum )  n_sum = n1 + n2
   ; https://forth-standard.org/standard/core/Plus
Plus:	LDAX ZW,ModBRPB,0	; pop n2
PlusA:	LDBA ZW			; get n1
	AAB
	STBA ZW			; store n_sum
	.dbyt INL_End		; return


 FHdr 'M+',0 ; ( d1 n -- d2 )  d2 = d1 + signed(n)
  ; https://forth-standard.org/standard/double/MPlus
MPlus:	LDAX ZW,ModBRPB,0	; pop n
MPlusA:	LDBX ZW,ModNBRB,2	; get d1.lo
	AAB
	STBX ZW,ModNBRB,2
	LDBA ZW			; get d1.hi
	BNL @4			; carry?
	INR BW,1
@4:	XAY			; test n sign
	BP @6
	DCR BW,1
@6:	STBA ZW
	RSR


 FHdr 'D+',0 ; ( d1 d2 -- d_sum )  d_sum = d1 + d2
DPlus:	LDAX ZW,ModBRPB,0 ; pop d2.hi
	XAY
	LDAX ZW,ModBRPB,0 ; pop d2.lo
	LDBX ZW,ModNBRB,2 ; get d1.lo
	AAB
	STBX ZW,ModNBRB,2 ; store d1.lo
	BNL @2		; carry?
	INR YW,1
@2:
	LDAA ZW		; get d1.hi
	ADD AW,YW
	STAA ZW		; store d1.hi
	RSR


 FHdr '-',ha_inline ; ( n1 n2 -- n_diff )  n_diff=n1-n2
   ; https://forth-standard.org/standard/core/Minus
Subtract:
	LDBX ZW,ModBRPB,0 ; pop n2
	LDAA ZW		; get n1
	SAB
	STBA ZW		; store n_diff
	.dbyt INL_End


 FHdr 'D-',0 ; ( d1 d2 -- d )  d=d1-d2
   ; https://forth-standard.org/standard/double/DMinus
DMinus:
    .if 1
	; short slower version
	JSRR DNegate
	JMPR DPlus
    .else
	; long faster version
	LDAX ZW,ModBRPB,0	; Y= d2.hi
	XAY
	LDBX ZW,ModBRPB,0	; B= dl.lo
	LDAX ZW,ModNBRB,2	; A= d1.lo
	SAB
	STBX ZW,ModNBRB,2
	LDAA ZW			; A= d1.hi
	XFR BW,YW
	SAB
	STAA ZW
	RSR
    .endif


 FHdr 'Negate',ha_inline ; ( n -- n )  Leave the two's complement of a number.
   ; https://forth-standard.org/standard/core/NEGATE
Negate:	LDBA ZW		; get n
Negat1:	IVR BW,1
	STBA ZW		; store n
	.dbyt INL_End


	.if 0
 FHdr "Minus",0 ; ( n -- n )  FIG alias
	JMPR Negate
	.endif


 FHdr 'Abs',0 ; ( n -- u )  Leave the absolute value of n as u.
Abs:	LDBA ZW		; n<0?
	BM Negat1	;   negate it & return
	RSR		; return


 FHdr '+-',0 ; ( n1 n2 -- n3 )  Apply the sign of n2 to n1, which is left as n3.
PM:	LDAX ZW,ModBRPB,0 ; pop n2
PMP:	BM Negate	;   negate n1 & return
	RSR		; return


 FHdr 'DNegate',0 ; ( d1 -- d2 )  Convert d1 to its double number two's complement.
   ; https://forth-standard.org/standard/double/DNEGATE
DNegate: LDBX ZW,ModNBRB,2 ; get d1.lo
	CLA
	SAB
	STBX ZW,ModNBRB,2 ; store d2.lo
	LDBA ZW		; get d1.hi
	BL @3		; borrow?
	DCA
@3:
	SAB
	STBA ZW		; store d2.hi
	RSR


	.if 0
 FHdr 'DMinus',0 ; ( d1 -- d2 )  FIG alias
	JMPR DNegate
	.endif


 FHdr 'DAbs',0 ; ( d -- ud )  Leave the absolute value ud of a double number.
   ; https://forth-standard.org/standard/double/DABS
DAbs:	LDABA ZW	; d<0?
	BM DNegate	;   negate d & return
	RSR		; return


 FHdr 'D+-',0 ; ( d1 n -- d2 )  Apply the sign of n to the doulbe number d1, leaving it as d2.
   ; https://forth-standard.org/standard/double/DPlus
DPM:	LDAX ZW,ModBRPB,0 ; pop n
DPMP:	BM DNegate	;   negate d1 & return
	RSR		; return


	.if 1

 FHdr 'False',ha_inline ; ( -- false )  Return a false flag.
   ; https://forth-standard.org/standard/core/FALSE
False:	CLA
	STAX ZW,ModBMRB,0
	.dbyt INL_End


 FHdr 'True',ha_inline ; ( -- true )  Return a true flag.
   ; https://forth-standard.org/standard/core/TRUE
True:	CLR AW,1
	STAX ZW,ModBMRB,0
	.dbyt INL_End

	.endif


 FHdr '0>',0 ; ( n -- f )  Leave a bool n>0
ZGt:	LDAA ZW			; test n
	BM False0
	BZ False0
	JMPR True0


 FHdr '0<',0 ; ( n -- f )  Leave a bool n<0
   ; https://forth-standard.org/standard/core/Zeroless
ZLessThan:
	LDABA ZW		; test n
	BM True0
	JMPR False0


 FHdr 'D0<',0 ; ( d -- f ) f=(d<0)
   ; https://forth-standard.org/standard/double/DZeroless
DZLessThan:
	LDAX ZW,ModBRPB,0	; pop d.hi
	BM True0
	JMPR False0


 FHdr '0=',0 ; ( n -- f )  Leave a bool n==0
   ; https://forth-standard.org/standard/core/ZeroEqual
ZEqual:	LDAA ZW			; test n
	BZ True0
	JMPR False0


 FHdr 'D0=',0 ; ( d -- f ) Leave a bool d==0
   ; https://forth-standard.org/standard/double/DZeroEqual
DZEqual:
	LDAX ZW,ModBRPB,0	; pop hi word
	BNZ False0
	LDBA ZW			; get lo word
	BZ True0
	JMPR False0


 FHdr 'D=',0 ; ( d1 d2 -- f )  f=(d1==d2)  double equal
   ; https://forth-standard.org/standard/double/DEqual
DEqual:	LDAX ZW,ModBRPB,0	; pop d2.hi
	XAY
	LDAX ZW,ModBRPB,0	; pop d2.lo
	LDBX ZW,ModBRPB,0	; pop d1.hi
	SUB BW,YW		; compare hi words
	BNZ False0
	LDBA ZW			; get d1.lo
	SAB			; compare lo words
	BNZ False0
	JMPR True0


 FHdr '<>',0 ; ( x1 x2 -- flag)  https://forth-standard.org/standard/core/ne
   ; https://forth-standard.org/standard/core/Zerone
NtoEqual:
	LDAX ZW,ModBRPB,0	; pop x2
	LDBA ZW			; get x1
	SAB			; x2<>x1?
	BNZ True0
	STBA ZW			; flag=false
	RSR


 FHdr '=',0 ; ( x1 x2 -- flag )  Leave a true flag if x1=x2; otherwise leave a false flag.
   ; https://forth-standard.org/standard/core/Equal
Equal:	LDAX ZW,ModBRPB,0	; pop x2
	LDBA ZW			; get x1
	SAB			; x2==x1?
	BNZ False0
True0:	CLR AW,1		; flag=true
	STAA ZW
	RSR


 FHdr 'U<',0 ; ( u1 u2 -- f )  f=u1<u2 (unsigned compare)
   ; https://forth-standard.org/standard/core/Uless
ULessThan:
	LDBX ZW,ModBRPB,0	; pop u2
	LDAA ZW			; get u1
ULt3:	SAB			; n1<n2?
	BNL True0
False0:	CLA			; f=false
	STAA ZW
	RSR


 FHdr 'U>',0 ; ( u1 u2 -- f )  f=u1>u2 (unsigned compare)
   ; https://forth-standard.org/standard/core/Umore
UGreaterThan:
	LDAX ZW,ModBRPB,0	; pop u2
	LDBA ZW			; get u1
	JMPR ULt3


 FHdr '<',0 ; ( n1 n2 -- f )  f=n1<n2 (signed compare)
   ; https://forth-standard.org/standard/core/less
LessThan:
	LDBX ZW,ModBRPB,0	; pop n2
	LDAA ZW			; get n1
LT2:	SAB			; n1<n2?
LT3:	BF @3			; overflow?
	BM True0
	JMPR False0

@3:	BM False0
	JMPR True0


 FHdr '<=',0 ; ( n1 n2 -- flag ) flag=n1<=n2 (signed compare)
LessEqual:
	LDBX ZW,ModBRPB,0	; pop n2
	LDAA ZW			; get n1
LE3:	SAB			; n1<n2?
	BNZ LT3
	JMPR True0


 FHdr '>',0 ; ( n1 n2 -- f )  f=n1>n2 (signed compare)
   ; https://forth-standard.org/standard/core/less
GreaterThan:
	LDAX ZW,ModBRPB,0	; pop n2
	LDBA ZW			; get n1
	JMPR LT2


 FHdr '>=',0 ; ( n1 n2 -- f )  f=n1>=n2 (signed compare)
GreaterEqual:
	LDAX ZW,ModBRPB,0	; pop n2
	LDBA ZW			; get n1
	JMPR LE3


 FHdr 'DU<',0 ; ( d1 d2 -- f )  f=d1<d2 (unsigned compare)
   ; https://forth-standard.org/standard/double/DUless
DULessThan:
	LDBX ZW,ModBRPB,0	; pop d2.hi
	LDAX ZW,ModBRPB,0	; pop d2.lo
	XAY
	LDAX ZW,ModBRPB,0	; pop d1.hi
	SAB
	BNZ @7
	LDAA ZW			; get d1.lo
	SUB YW,AW
@7:	BNL True0
	JMPR False0


 FHdr 'D<',0 ; ( d1 d2 -- f )  f=d1<d2 (signed compare)
   ; https://forth-standard.org/standard/double/Dless
DLessThan:
	LDBX ZW,ModBRPB,0	; pop d2.hi
	LDAX ZW,ModBRPB,0	; pop d2.lo
	XAY
	LDAX ZW,ModBRPB,0	; pop d1.hi
	SAB
	BNZ @10
	LDAA ZW			; get d1.lo
	SUB YW,AW
	BNL True0
	JMPR False0

@10:	BNF @14
	BM False0
	JMPD True0

@14:	BP False0
	JMPD True0


 FHdr 'D>S',ha_inline ; ( d -- n )  Convert double to single
   ; https://forth-standard.org/standard/double/DtoS
DToS:	INR ZW,2
	.dbyt INL_End


 FHdr 'S>D',0 ; ( n -- d )  Sign extend a single number to form a double number.
   ; https://forth-standard.org/standard/core/StoD
SToD:	CLA			; assume hi word is 0
	LDBA ZW			; n<0?
	BP @2
	DCA			;   change to -1
@2:	STAX ZW,ModBMRB,0	; push hi word
	RSR


	.if 0
 FHdr 'S->D',0 ; ( n -- d )  FIG alias
	JMPR SToD
	.endif


 FHdr 'UM*',0 ; ( u1 u2 -- ud )  ud = unsigned double number product of 2 unsigned numbers.
   ; https://forth-standard.org/standard/core/UMTimes
UMStar:	STXX SW,ModBMRB,0	; save X
	LDAX ZW,ModNBRB,2	; Y=u1
	XAY
	LDAA ZW			; A=u2
	CLR BW,0		; product.hi=0
	LDXL 16			; for 16 bits
	RL			; pre-shift u2
	RRR AW,1
@3:	BNL @4			;   set?
	ADD BW,YW		;     add u1 to product.hi
@4:	RRR BW,1		;   rotate product right 1 bit
	RRR AW,1
	DCX			;  next bit
	BNZ @3
	STBA ZW			; store product.hi
	STAX ZW,ModNBRB,2	; store product.lo
	LDXX SW,ModBRPB,0	; restore X
	RSR			; return


	.if 0
 FHdr 'U*',0 ; ( u1 u2 -- ud )  FIG alias
	JMPR UMStar
	.endif

  .if 0
UMStarTest1:
	LDAL 1
	STAX ZW,ModBMRB,0
	LDAL 1
	STAX ZW,ModBMRB,0
	JSRD UMStar
	LDAX ZW,ModBRPB,0
	LDBL 0
	SAB
	BZ @13
	HLT
@13:
	LDAX ZW,ModBRPB,0
	LDBL 1
	SAB
	BZ @14
	HLT
@14:

	LDAL $9876
	STAX ZW,ModBMRB,0
	LDAL $a987
	STAX ZW,ModBMRB,0
	JSRD UMStar
	LDAX ZW,ModBRPB,0
	LDBL $64f6
	SAB
	BZ @23
	HLT
@23:
	LDAX ZW,ModBRPB,0
	LDBL $4c3a
	SAB
	BZ @24
	HLT
@24:

	RSR
  .endif


 FHdr 'UM/Mod',0 ; ( ud_dividend u_divisor -- u_rem u_quot )
   ; Leave the unsigned remainder and unsigned quotient from the unsigned
   ; double dividend and unsigned divisor.
   ; https://forth-standard.org/standard/core/UMDivMOD
UMSlashMod:
	LDAX ZW,ModBRPB,0	; pop divisor into A
	IVR AW,1		; negate
	STXX SW,ModBMRB,0	; save X
	XFR BW,ZW		; save Z
	STBX SW,ModBMRB,0
	LDBX ZW,ModNBRB,2	; Y=dividend.lo
	XFR YW,BW
	LDXX ZW,ModBRB,0	; X=dividend.hi
 
	LDBBL 16		; for 16 bits
	XFRB ZL,BL
	SLR YW,1		; shift dividend.lo left
@2:	RLR XW,1		;   rotate dividend.hi left
	BL @7			;   dividend overflowed?
	XFR BW,XW
	AAB			;   dividend.hi>=divisor?
	BZ @3
	BNL @4
@3:	XFR XW,BW		;     dividend.hi-=divisor
@4:	RLR YW,1		;   shift into quotient, start dividend shift
	DCRB ZL			;  next bit
	BNZ @2
	LDAX SW,ModBRPB,0	; restore Z
	XAZ
	STXX ZW,ModNBRB,2	; save remainder
	XFR AW,YW
	STAA ZW			; save quotient
	LDXX SW,ModBRPB,0	; restore X
	RSR			; return

@7:				; dividend overflowed, so it's always bigger than the divisor
	XFR BW,XW
	AAB			; dividend.hi-=divisor
	SL			; it always fits, because the shifted out bit was set
	JMPR @3


	.if 0
 FHdr 'U/',0 ; FIG alias
	JMPR UMSlashMod
	.endif


	.if 0
UMSlashModTest1:
	LDAL $5678		; dividend = $12345678
	STAX ZW,ModBMRB,0
	LDAL $1234
	STAX ZW,ModBMRB,0
	LDAL $6789		; divisor = $6789
	STAX ZW,ModBMRB,0
	JSRD UMSlashMod
	LDAX ZW,ModBRPB,0	; quotient
	LDBL $2d03
	SAB
	BZ @3
	HLT
@3:
	LDAX ZW,ModBRPB,0	; remainder
	LDBL $add
	SAB
	BZ @4
	HLT
@4:
	RSR
	.endif


 FHdr 'M*',0 ; ( n1 n2 -- d )
   ; A mixed magnitude math operations which leaves the double number signed
   ; product of two signed integers.
   ; https://forth-standard.org/standard/core/MTimes
MStar:	LDAA ZW			; save result sign
	LDBX ZW,ModNBRB,2
	ORE BW,AW
	STBX SW,ModBMRB,0
	JSRD Abs		; n2=abs(n2)
	LDBX ZW,ModNBRB,2	; n1<0?
	BP @4
	CLA			;   n1=-n1
	SAB
	STBX ZW,ModNBRB,2
@4:
	JSRD UMStar		; unsigned multiply giving double product 
	LDAX SW,ModBRPB,0	; should be negative?
	JMPD DPMP		; fix sign & return


 FHdr 'M/Mod',0 ; ( ud1 u2 -- u3 ud4 )
   ; An unsigned mixed magnitude math operation which leaves a double quotient ud4 and
   ; remainder u3, from a double dividend ud1 and single divisor u2.
MSlashMod:
	LDBA ZW			; >R 0
	STBX SW,ModBMRB,0
	CLA
	STAA ZW
	STBX ZW,ModBMRB,0	; R
	JSRD UMSlashMod		; U/
	LDBA SW			; R> Swap >R
	LDAA ZW
	STBA ZW
	STAA SW
	JSRD UMSlashMod		; U/
	LDAX SW,ModBRPB,0	; R>
	STAX ZW,ModBMRB,0
	RSR


	.if 0
MSlashModTest1:
	LDAL .loword(123456789)
	STAX ZW,ModBMRB,0
	LDAL .hiword(123456789)
	STAX ZW,ModBMRB,0
	LDAL 10
	STAX ZW,ModBMRB,0
	JSRR MSlashMod
	LDAX ZW,ModBRPB,0
	LDBL .hiword(12345678)
	SAB
	BZ @11
	HLT
@11:
	LDAX ZW,ModBRPB,0
	LDBL .loword(12345678)
	SAB
	BZ @12
	HLT
@12:
	LDAX ZW,ModBRPB,0
	LDBL 9
	SAB
	BZ @13
	HLT
@13:
	RSR
	.endif


 FHdr 'SM/Rem',0 ; ( d_dividend n_divisor -- n_remainder n_quotient )
   ; A mixed magnitude math operation which leaves the signed remainder and signed
   ; quotient, from a double number dividend and divisor.
   ; The remainder takes its sign from the dividend.

   ; Divide d1 by n1, giving the symmetric quotient n3 and the remainder n2.
   ;  Input and output stack arguments are signed.
   ;  An ambiguous condition exists if n1 is zero or if the quotient lies outside the range of a single-cell signed integer.
   ; https://forth-standard.org/standard/core/SMDivREM
SMSlashRem:
	LDAX ZW,ModBRPB,0	; pop divisor
	LDBA ZW			; push dividend sign to return stack
	STBX SW,ModBMRB,0
	STAX SW,ModBMRB,0	; push divisor to return stack
	JSRD DAbs		; d=abs(d)
	LDAA SW			; get a copy of divisor from return stack
	STAX ZW,ModBMRB,0
	JSRD Abs		; abs
	JSRD UMSlashMod		; unsigned divide
	LDAX SW,ModBRPB,0	; pop divisor from return stack
;	STAX ZW,ModBMRB,0
	LDBA SW			; should quotient be negative?
	ORE BW,AW
	JSRD PMP
	LDAX SW,ModBRPB,0	; pop dividend sign
	BP @18			; should remander be negative?
	CLA			;   negate remainder
	LDBX ZW,ModNBRB,2
	SAB
	STBX ZW,ModNBRB,2
@18:
	RSR			; return


	.if 0
 FHdr 'M/',0 ; ( d_dividend n_divisor -- n_remainder n_quotient )  FIG alias
	JMPR SMSlashRem
	.endif


	.if 0
 FHdr 'FM/Mod',0 ; ( d n1 â€” n2 n3 )
   ;Divide d1 by n1, giving the floored quotient n3 and the remainder n2.
   ; Input and output stack arguments are signed.
   ; An ambiguous condition exists if n1 is zero or if the quotient lies outside the range of a single-cell signed integer.
   ; https://forth-standard.org/standard/core/FMDivMOD
	.endif


 FHdr '*',0 ; ( n1 n2 -- n_prod )  Leave the signed product of two signed numbers.
   ; https://forth-standard.org/standard/core/Times
Star:	JSRD UMStar		; do unsigned multiply
	INR ZW,2		; drop hi word of result
	RSR			; return


 FHdr '/Mod',0 ; ( n_dividend n_divisor -- n_rem n_quot )  Divide
   ; https://forth-standard.org/standard/core/DivMOD
SlashMod:
	LDAX ZW,ModBRPB,0	; save divisor
	STAX SW,ModBMRB,0
	JSRD SToD		; convert dividend to double
	LDAX SW,ModBRPB,0	; get divisor
	STAX ZW,ModBMRB,0
	JMPR SMSlashRem		; divide & return


 FHdr '/',0 ; ( n_dividend n_divisor -- n_quot )  Divide
   ; https://forth-standard.org/standard/core/Div
Slash:	JSRR SlashMod		; do the divide
	JMPD Nip		; discard the remainder, & return


 FHdr 'Mod',0 ; ( n_dividend n_divisor -- n_mod )
   ; Leave the remainder of n1/n2, with the same sign as n1.
   ; https://forth-standard.org/standard/core/MOD
Mod:	JSRR SlashMod		; do the divide
	INR ZW,2		; drop the quotient
	RSR			; return


 FHdr '*/Mod',0 ; ( n1 n_multipier n_divisor -- n_remainder n_quotient )
   ; Leave the quotient and remainder of the operation (n1*n_multiplier)/n_divisor .
   ; A 31 bit intermediate product is used as for */ .
   ; https://forth-standard.org/standard/core/TimesDivMOD
StarSlashMod:
	LDAX ZW,ModBRPB,0	; save divisor on return stack
	STAX SW,ModBMRB,0
	JSRD MStar		; do multiply
	LDAX SW,ModBRPB,0	; get divisor from return stack
	STAX ZW,ModBMRB,0
	JMPR SMSlashRem		; do divide & return


 FHdr '*/',0 ; ( n1 n_multiplier n_divisor -- n_quotient )
   ; Leave the ratio n_quotient = (n1*n_multiplier)/n_divisor where all are signed numbers.
   ; Retention of an intermediate 31 bit product permits greater accuracy
   ; than would be available with the sequence:
   ;	n1 n_multiplier * n_divisor /
   ; https://forth-standard.org/standard/core/TimesDiv
StarSlash:
	JSRR StarSlashMod ; do it
	JMPD Nip		; discard the remainder & return


	.if 0
 FHdr 'M*/',0 ; ( d1 n1 +n2 -- d2 )
   ; https://forth-standard.org/standard/double/MTimesDiv
	JSRD Abort ;???
	.endif


 FHdr '+!',0 ; ( n adr -- )  Add n to the value at the address.
   ; https://forth-standard.org/standard/core/PlusStore
PlusStore:
	LDAX ZW,ModBRPB,0	; pop adr
	XAY
	LDAX ZW,ModBRPB,0	; pop n
	LDBA YW
	AAB
	STBA YW
	RSR


 FHdr '1+!',ha_inline ; ( adr -- )  increment a variable
	LDBX ZW,ModBRPB,0	; pop addr
	LDAA BW			; increment the word
	INA
	STAA BW
	.dbyt INL_End		; return


 FHdr '0!',ha_inline ; ( adr -- )  store 0 in a variable
	CLA
	STAX ZW,ModABRPB,0
	.dbyt INL_End		; return


	.if 0
 FHdr 'Toggle',0 ; ( adr n -- )  Complement the contents of addr by the bit pattern n .
Toggle:	LDBX ZW,ModBRPB,0	; pop n
	LDAX ZW,ModBRPB,0	; pop adr
	XAY
	LDAA YW			; do a word
	ORE AW,BW
	STAA YW
	RSR
	.endif


 FHdr '@',ha_inline ; ( adr -- n )  Leave the 16 bit contents of address.
   ; https://forth-standard.org/standard/core/Fetch
At:	LDAX ZW,ModABRB,0	; get @adr
	STAA ZW			; store n
	.dbyt INL_End


 FHdr '2@',0 ; ( adr -- d )  Leave the 32 bit contents of address.
   ; https://forth-standard.org/standard/core/TwoFetch
TwoAt:	LDBA ZW			; get addr
	LDAX BW,ModBRPB,0	; get d.hi
	LDBA BW			; get d.lo
	STBA ZW			; store d.lo
	STAX ZW,ModBMRB,0	; store d.hi
	RSR


 FHdr 'C@',ha_inline ; ( adr -- n )  Leave the 8 bit contents of memory address.
; https://forth-standard.org/standard/core/CFetch
CAt:	CLA			; set the hi byte to 0
	LDABX ZW,ModABRB,0	; fetch byte addressed by bottom of stack
	STAA ZW			; store as n
	.dbyt INL_End		; return


 FHdr '!',ha_inline ; ( n adr -- )  Store 16 bits of n at address.
   ; https://forth-standard.org/standard/core/Store
Store:	LDBX ZW,ModBRPB,0	; pop adr
	LDAX ZW,ModBRPB,0	; pop n
	STAA BW			; store at (adr)
	.dbyt INL_End		; return


 FHdr '2!',0 ; ( d adr -- )  Store 32 bits at adr.
   ; https://forth-standard.org/standard/core/TwoStore
TwoStore:
	LDBX ZW,ModBRPB,0	; pop adr
	LDAX ZW,ModBRPB,0	; pop d.hi
	STAX BW,ModBRPB,0	; store at adr+0
	LDAX ZW,ModBRPB,0	; pop d.lo
	STAA BW			; store at adr+2
	RSR			; return


 FHdr 'C!',ha_inline ; ( n adr -- )  Store 8 bits at address.
   ; https://forth-standard.org/standard/core/CStore
CStore:	LDBX ZW,ModBRPB,0	; pop adr
	LDAX ZW,ModBRPB,0	; pop n
	STABA BW		; store at adr
	.dbyt INL_End		; return


 FHdr 'Execute',0 ; ( xt -- )
   ; Execute the definition whose address is on the stack.
   ; The code address is also called the compilation address.
   ; https://forth-standard.org/standard/core/EXECUTE
Execute: JMPX ZW,ModABRPB,0	; pop xt & jmp to it


 FHdr 'Count',0 ; ( addr1 -- addr2 len )
; Leave the byte address addr2 and byte count len of a counted string beginning at
; address addr1.  It is presumed that the first byte at addr1 contains the text
; byte count and the actual text starts with the second byte.
; Typically COUNT is followed by TYPE .
; https://forth-standard.org/standard/core/COUNT
Count:	LDBA ZW			; get addr1
	CLA			; get length byte
	LDABX BW,ModBRPB,0
	STBA ZW			; store addr2
	STAX ZW,ModBMRB,0	; push length
	RSR			; return


	.if 0

 FHdr 'Chars',ha_inline ; ( n1 -- n2 )
   ; n2 is the size in address units of n1 characters.
   ; https://forth-standard.org/standard/core/CHARS
Chars:	.dbyt INL_End


 FHdr 'Char+',0 ; ( c-addr1 -- c-addr2 )
   ; Add the size in address units of a character to c-addr1, giving c-addr2.
   ; https://forth-standard.org/standard/core/CHARPlus
CharPlus: JMPR OnePlus

	.endif


 FHdr 'Cell',0 ; ( -- n )  size of a cell in bytes
Cell:	JMPD Two


 FHdr 'Cells',0 ; ( n1 -- n2 ) convert # of cells to bytes
   ; https://forth-standard.org/standard/core/CELLS
Cells:	JMPD TwoStar


 FHdr 'Cell+',0 ; ( n1 -- n2 ) add size of cell
   ; https://forth-standard.org/standard/core/CELLPlus
CellPlus:
	JMPD TwoPlus


	.if 0
 FHdr '/String',0 ; ( c-addr1 u1 n -- c-addr2 u2 )
   ; Adjust the character string at c-addr1 by n characters. The resulting character string, specified by c-addr2 u2,
   ; begins at c-addr1 plus n characters and is u1 minus n characters long.
   ; https://forth-standard.org/standard/string/DivSTRING
SlashString:
	LDAX ZW,ModBRPB,0	; pop n
	LDBX ZW,ModNBRB,2	; fix c-addr1
	AAB
	STBX ZW,ModNBRB,2
	LDBA ZW			; fix u1
	SUB AW,BW
	STAA ZW
	RSR
	.endif


 FHdr '-Trailing',0 ; ( addr n1 -- addr n2 )  Remove trailing blanks
   ; Adjust the char count n1 of a text string beginning at addr to suppress
   ; the output of trailing blanks.  i.e. the chars at addr+n1 to addr+n2
   ; are blanks.
   ; https://forth-standard.org/standard/string/MinusTRAILING
DTrailing:
	STXX SW,ModBMRB,0	; save X

	LDXX ZW,ModBRB,0	; X= len
	LDAX ZW,ModNBRB,2	; Y= addr+len
	XAY
	ADD YW,XW
@8:	DCX			; step to previous char
	BM @9
	LDBBX YW,ModBMRB,0	; get char
	LDABL ' '		; is char blank?
	SABB
	BZ @8			;   if so, do another char
@9:	INXC			; done
	STXX ZW,ModBRB,0	; store new len

	LDXX SW,ModBRPB,0	; restore X
	RSR			; return


 FHdr 'Upper',0 ; ( adr len -- ) uppercase a string
Upper:	STXX SW,ModBMRB,0	; push X
	LDXX ZW,ModBRPB,0	; pop len
	LDAX ZW,ModBRPB,0	; pop adr
	XAY
	BZ @Done

@2:	LDABX YW,ModBRPB,0	; get char
	LDBBL 'a'		; <'a'?
	SABB
	BNL @7
	LDBBL 'z'+1		; >'z'?
	SABB
	BL @7
	LDBBL $DF		; change to ASCII uppercase
	NABB
	STBBX YW,ModNBRB,$ff	; store it back
@7:	DCX			; len--
	BP @2			; <0?

@Done:	LDXX SW,ModBRPB,0	; pop X
	RSR


	.if 0
 FHdr 'Replaces',0 ; ( c-addr1 u1 c-addr2 u2 -- )
   ; Set the string c-addr1 u1 as the text to substitute for the substitution named by c-addr2 u2.
   ; If the substitution does not exist it is created. The program may then reuse the buffer c-addr1 u1
   ; without affecting the definition of the substitution.
   ;
   ; Ambiguous conditions occur as follows:
   ;	The substitution cannot be created;
   ;	The name of a substitution contains the `%' delimiter character.
   ; 	REPLACES may allot data space and create a definition. This breaks the contiguity of the current region and
   ;	  is not allowed during compilation of a colon definition
   ; https://forth-standard.org/standard/string/REPLACES
Replaces:
	JSRD Abort ;???
	.endif


	.if 0
 FHdr 'Search',0 ; ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
   ; Search the string specified by c-addr1 u1 for the string specified by c-addr2 u2.
   ; If flag is true, a match was found at c-addr3 with u3 characters remaining.
   ; If flag is false there was no match and c-addr3 is c-addr1 and u3 is u1.
   ; https://forth-standard.org/standard/string/SEARCH
Search:
	STXX SW,ModBMRB,0	; save X
	LDAX ZW,ModBRPB,0	; pop u2
	INA
	STAX SW,ModBMRB,0	;   push u2
	LDAA ZW			; get c-addr2
	LDBL $7f00		;   YH=$7f, YL=1st char		
	LDBBX AW,ModBRPB,0
	STBX SW,ModBMRB,0	;     push
	STAX SW,ModBMRB,0	;   push c-addr2 + 1
	LDAX ZW,ModNBRB,2	; get u1
	INA			;   + 1
	LDBX SW,ModNBRB,4	;   - u2
	SAB
	STBX SW,ModBMRB,0	;   push
	LDAX ZW,ModNBRB,4	; get c-addr1
	STAX SW,ModBMRB,0	;   push
	XFR AW,ZW		; save Z
	STAX SW,ModBMRB,0
@c2	= 10
@chr2	=  8
@A2	=  6
@A1	=  4
@c1	=  2
@Z	=  0

@10:				; load regs for 1st char search
	LDAX SW,ModNBRB,@c1	; Z = @c1
	XAZ
	LDAX SW,ModNBRB,@chr2	; Yh = $7f; YL = 1st pattern char
	XAY
	LDXX SW,ModNBRB,@A1	; X = @A1
@12:	DCR ZW			;   get next byte
	BZ @NotFound
	LDABX XW,ModBRPB,0
	SUBB BL,YL		;   compare
	ANR BL,YH		;   is this helpful?
	BNZ @12
	STXX SW,ModNBRB,@A1	; save loc of 2nd char
	XFR AW,ZW
	STAX SW,ModNBRB,@c1	; save count

	LDAX SW,ModNBRB,@A2	; load regs for additional chars search
	XAY
	LDAX SW,ModNBRB,@c2
	XAZ
	JMPR @28
@22:	LDABX XW,ModBRPB,0	; compare char
	LDBBX YW,ModBRPB,0
	SABB
	BNZ @10
@28:	DCR ZW			; adjust count
	BNZ @22

@Found:	LDAA SW ;@Z		; restore Z
	XAZ
	LDAX SW,ModNBRB,@A1	; c-addr3 = @A1 - 1
	DCA
	STAX ZW,ModNBRB,4
	LDAX SW,ModNBRB,@c1	; u3 = @c1 + @c2
	LDBX SW,ModNBRB,@c2
	AAB
	STBX ZW,ModNBRB,2
	LDAL 1			; flag = true
	JMPR @99

@NotFound:
	LDAA SW ; @Z		; restore Z
	XAZ
	CLA			; flag = false

@99:	INR SW,@c2+2
	LDXX SW,MonBRPB,0	; restore X
	STAA ZW			; save flag
	RSR
	.endif


	.if 0
 FHdr 'Substitute',0 ; ( c-addr1 u1 c-addr2 u2 -- c-addr2 u3 n )
   ; Perform substitution on the string c-addr1 u1 placing the result at string c-addr2 u3,
   ; where u3 is the length of the resulting string.
   ; An error occurs if the resulting string will not fit into c-addr2 u2 or if c-addr2 is the same as c-addr1.
   ; The return value n is positive or 0 on success and indicates the number of substitutions made. A negative value for n indicates that an error occurred, leaving c-addr2 u3 undefined. Negative values of n are implementation defined except for values in table 9.1 THROW code assignments.
   ;
   ; Substitution occurs left to right from the start of c-addr1 in one pass and is non-recursive.
   ;
   ; When text of a potential substitution name, surrounded by `%' (ASCII $25) delimiters is encountered by SUBSTITUTE, the following occurs:
   ;
   ; If the name is null, a single delimiter character is passed to the output, i.e., %% is replaced by %. The current number of substitutions is not changed.
   ; If the text is a valid substitution name acceptable to 17.6.2.2141 REPLACES, the leading and trailing delimiter characters and the enclosed substitution name are replaced by the substitution text. The current number of substitutions is incremented.
   ; If the text is not a valid substitution name, the name with leading and trailing delimiters is passed unchanged to the output. The current number of substitutions is not changed.
   ; Parsing of the input string resumes after the trailing delimiter.
   ; If after processing any pairs of delimiters, the residue of the input string contains a single delimiter, the residue is passed unchanged to the output.
   ; https://forth-standard.org/standard/string/SUBSTITUTE
Substutute:
	JSRD Abort ;???
	.endif


	.if 0
 FHdr 'Unescape',0 ; ( c-addr1 u1 c-addr2 -- c-addr2 u2 )
   ; Replace each `%' character in the input string c-addr1 u1 by two `%' characters.
   ; The output is represented by c-addr2 u2. The buffer at c-addr2 shall be big enough to hold the unescaped string.
   ; An ambiguous condition occurs if the resulting string will not fit into the destination buffer (c-addr2).
   ; https://forth-standard.org/standard/string/UNESCAPE
Unescape:
	JSRD Abort ;???
	.endif


 FHdr 'Enclose',0 ; ( addr delimiter - addr1 n1 n2 n3 )
   ; The text scanning primitive used by WORD.  From the text address addr1 and an ASCII
   ; delimiting char, is determined the byte offset to the first non-delimiter
   ; char n1, the offset to the first delimiter after the text n2, and the offset to the
   ; first char not included.
   ; This procedure will not process past an ASCII 'null', treating it as an unconditional delimiter.
Enclose:
	STXX SW,ModBMRB,0	; push X
	LDXX ZW,ModNBRB,2	; X=addr
	LDAA ZW			; AL=delimiter
	DCR ZW,4		; alloc space for n2 & n3

	; skip initial delimiters
	DCX
@313:	INXC			; get next char
	LDBBA XW
	SABB
	BZ @313
	LDBX ZW,ModNBRB,6	; n1=index of 1st non-delimiter char
	SUB BW,XW
	STBX ZW,ModNBRB,4

	DCX			; skip word
@318:	INXC			; get next char
	LDBBA XW
	BZ @70			;    null?
	SABB			;    !delimiter?
	BNZ @318
	LDBX ZW,ModNBRB,6	; n2=index of delimiter after word
	SUB BW,XW
	STBX ZW,ModNBRB,2
	INR BW,1		; n3=n2+1
	STBA ZW
	JMPR @Rtn

@70: ; we hit a null
	LDBX ZW,ModNBRB,6	; n2=index of null
	SUB BW,XW
	STBX ZW,ModNBRB,2
	STBA ZW			; n3=index of null

	LDAX ZW,ModNBRB,4	; n2==n1?
	SUB AW,BW
	BNZ @326
	INR BW,1		;   n2+=1
	STBX ZW,ModNBRB,2
@326:
@Rtn:	LDXX SW,ModBRPB,0	; pop X
	RSR			; return


; FHdr 'Word',0 ; ( c -- addr )  ANSI
   ;	Parses one word from the input stream, using the character (usually blank) as a delimiter.
   ;	Moves the string to the address HERE with the count in the first byte, leaving the address on the stack.
   ; https://forth-standard.org/standard/core/WORD


 FHdr 'Word',0 ; ( c -- )  FIG
   ; Read the next text chars from the input stream being interpreted, until a delimiter
   ; c is found, storing the packed char string beginning at the dictionary buffer HERE .
   ; WORD leaves the char count in the 1st byte, the chars, and ends with 2 or more blanks.
   ; Leading occurances of c are ignored.  If BLK is zero, text is taken from the
   ; terminal input buffer, otherwise from the disc block stored in BLK .
   ; See BLK IN
Word:	LDAD VBlk		; if not terminal
	BZ @1914

	STAX ZW,ModBMRB,0	;   get block ptr
	JSRD Block
	JMPR @1916		;  else

@1914:	LDAD VTIB		;   get terminal buffer ptr
	STAX ZW,ModBMRB,0
				;  then
@1916:				; ( c buf )

	LDAD VIn
	JSRD PlusA
	JSRD Swap
	JSRD Enclose		; ( buf n1 n2 n3 )

	LDAD VDP		; output ptr
	XAY

	LDAX ZW,ModNBRB,2	; store string length
	LDBX ZW,ModNBRB,4
	SAB
	STBBX YW,ModBRPB,0

	LDAX ZW,ModNBRB,6	; source addr
	LDBX ZW,ModNBRB,4
	AAB
	LDABX YW,ModNBRB,$ff
	XFRB AH,AL		; store chars
@31:	LDABX BW,ModBRPB,0
	STABX YW,ModBRPB,0
	DCRB AH
	BNZ @31

	LDAL $2020		; store blanks
	STAA YW

	JSRD In			; In+=n3
	JSRD PlusStore
	INR ZW,6		; drop n2 n1 buf
	RSR


	.if 0
 FHdr 'Digit',0	; ( c n1 -- n2 true ) (ok)
		; ( c n1 ---  false ) (bad)
   ; Converts the ASCII char c (using base n1) to its binary equivalent n2,
   ; accompanied by a true flag.  If the conversion is invalid, leaves
   ; only a false flag.
	JSRD Abort ;???
	.endif


 FHdr '(Number)',0 ; ( d1 addr1 -- d2 addr2 )
   ; Convert the ASCII text beginning at addr1+1 with regard to BASE.  The new value
   ; is accumulated into double number d1, being left as d2.  Addr2 is the address
   ; of the first unconvertable digit.  Used by NUMBER.
PNumber:
@1971:	LDAA ZW			; addr1+=1
	INA
	STAA ZW
	LDABA AW		; get char
	LDBBL $100-'0'		; 0..9?
	ADDB AL,BL
	BNL @bad
	LDBBL 10
	SABB
	BNL @base
	LDBBL $100-7
	ADDB AL,BL
	LDBBL 10		; A..Z?
	SABB
	BNL @bad
	LDBBD 1+VBase
	SABB
	BNL @ok
	LDBBL $100-$20		; a..z?
	ADDB AL,BL
	LDBBL 10
	SABB
	BNL @bad
@base:	LDBBD 1+VBase		; >=base?
	SABB
	BL @bad
@ok:
	LDBA ZW			; save addr1 on return stack
	STBX SW,ModBMRB,0
	CLRB AH
	STAA ZW			; ( ul uh digit )

	JSRD Swap		; ( ul digit uh )
	JSRR @mul		; ( u1 digit dh ) 
	INR ZW,2		; ( ul digit uh )
	JSRD Rot		; ( digit uh ul )  ( n1 n2 n3 -- n2 n3 n1 )
	JSRD @mul		; ( digit uh dl )
	JSRD DPlus		; ( d2 )
	LDAD VDPL		; decimal_places>=0?
	BM @1998
	INA
	STAD VDPL		;   increment decimal_places
@1998:
	LDAX SW,ModBRPB,0	; pop addr1 from return stack  ( d2 addr )
	STAX ZW,ModBMRB,0
	JMPR @1971		; back for more digits

@bad:	RSR			; we hit something not-a-number, return

@mul:	LDAD VBase
	STAX ZW,ModBMRB,0
	JMPD UMStar


 FHdr 'Number',0 ; ( addr -- d )
   ; Convert a character string left at addr with a preceeding count, to a signed
   ; double number, using the current numeric base.  If a decimal point is encountered
   ; in the text its position will be given in DPL, but no other effect occurs.
   ; If numeric conversion is not possible, an error message will be given.
Number:	STXX SW,ModBMRB,0	; save X
	LDXX ZW,ModBRB,0	; get addr
	CLA			; push 0.
	STAA ZW
	STAX ZW,ModBMRB,0
	DCR ZW,2		; ( d addr )

	LDAD VBase		; save default base
	STAX SW,ModBMRB,0
	LDAL $ffff		; init decimal places to "no . found"
	STAD VDPL

	INXC			; skip string count byte
	LDABA XW		; look at next char
	LDBBL '-'		; negative sign?
	SABB
	STBBX SW,ModBMRB,0	;   save this for finish
	BNZ @17
	INXC			;   skip sign char
	LDABA XW
@17:
	LDBBL '$'		;    hex?
	SABB
	BZ @Hex
	LDBBL "'"		;    char literal?
	SABB
	BZ @Char
@29:	DCX			; save addr of remaining string-1
	STXX ZW,ModBRB,0

@2023:	JSRD PNumber		; do some digits
	LDABX ZW,ModABRB,0	; look at next char
	LDBBL ' '		; blank?
	SABB
	BZ @2042
	LDBBL '.'		; '.'?
	SABB
	BNZ @err
	CLA			; remember the dot
	STAD VDPL
	JMPR @2023		; back for more chars

@Hex:	; temporary hex base
	JSRD Hex
	INXC
	JMPR @29

@Char: ; char literal
	LDABX XW,ModNBRB,2	; check ending delimiter
	LDBBL "'"
	SABB
	BNZ @29
	CLA			; get char
	LDABX XW,ModNBRB,1
	STAX ZW,ModNBRB,4
	JMPR @2042

@err:	CLR BW,Err_0		; unconvertable digit, signal error
	JSRD ErrorY

@2042:				; done
	INR ZW,2		; drop addr
	LDABX SW,ModBRPB,0	; was there a '-' sign?
	BNZ @2047
	JSRD DNegate		;   negate the result
@2047:
	LDAX SW,ModBRPB,0	; restore base
	STAD VBase
	LDXX SW,ModBRPB,0	; restore X
	RSR			; return


	.if 0
 FHdr '>Number',0 ; ( ud1 addr1 u1 â€” ud2 addr2 u2 )
   ;Return value ud2 is the unsigned result of converting the characters within the string specified
   ; by addr1 u1 into digits, using the number in BASE, and adding each into ud1 after multiplying
   ; ud1 by the number in BASE. Conversion continues left-to-right until a character that is not
   ; convertible, including any â€œ+â€ or â€œ-â€œ, is encountered or the string is entirely converted.
   ; Address addr2 is the location of the first unconverted character or the first character past
   ; the end of the string if the string was entirely converted.
   ; Length u2 is the number of unconverted characters in the string.
	JSRD Abort ;???
	.endif


; These small numbers are used so often that it is attractive to define them
; by name in the dictionary as constants.

 FHdr '0',ha_inline ; ( -- n )  constant: 0
Zero:	CLA
	STAX ZW,ModBMRB,0
	.dbyt INL_End


 FHdr '1',ha_inline ; ( -- n )  constant: 1
One:	CLR AW,1
	STAX ZW,ModBMRB,0
	.dbyt INL_End


 FHdr '2',ha_inline ; ( -- n )  constant: 2
Two:	CLR AW,2
	STAX ZW,ModBMRB,0
	.dbyt INL_End


 FHdr '3',ha_inline ; ( -- n )  constant: 3
Three:	CLR AW,3
	STAX ZW,ModBMRB,0
	.dbyt INL_End


 FHdr 'Bl',ha_inline ; ( -- n )	constant: the ASCII value for "blank".
; https://forth-standard.org/standard/core/BL
Bl:	LDAL ' '		; push a blank & return
	STAX ZW,ModBMRB,0
	.dbyt INL_End


 FHdr 'C/L',0 ; ( -- n )  constant: chars per screen line
CSlashL: LDAL 64
	STAX ZW,ModBMRB,0
	RSR


 FHdr 'B/Buf',0 ; ( -- n )  constant: number of bytes per disc buffer,
			; the byte count read from disc by BLOCK.
BBuf:	LDAL SectorSize
	STAX ZW,ModBMRB,0
	RSR


 FHdr 'B/Scr',0 ; ( -- n )  constant: number of blocks per editing screen.
		; By convention, an editing screen is 1024 bytes organized as 16 lines of 64 chars each.
BScr:	LDAL 1024/SectorSize
	STAX ZW,ModBMRB,0
	RSR


 FHdr '+Origin',0 ; ( n -- adr )  Memory address relative by n to the origin parameter area.
	; n is the minimum address unit, either byte or word.
	; This definition is used to access or modify the boot-up parameters at the origin area.
POrig:	LDAL ORIG
	JMPD PlusA


 FHdr 'User',0 ;
   ; A defining word used in the form:
   ;	n USER cccc
   ; which creates a user variable cccc.
   ; When cccc is later executed, it places the sum of its offset and the user area
   ; base address on the stack as the storage address of that particular variable.
User:	JSRD HeaderComma	; compile word header
	JSRD LdaComma		; compile "ldal n"
	LDAL DoUser		; compile "jmp DoUser" & return
	JMPD JmpCommaA


 FHdr 'BS',0 ; ( -- n )	User variable
BS:	LDAL VBS
	JMPR DoUser


 FHdr 'TIB',0 ; ( -- adr )  User variable
TIB:	LDAL VTIB
	JMPR DoUser


	.if 0
 FHdr '#TIB',0 ; ( â€” addr )  User variable
	HLT ; ??Contains the size of the contents of the terminal input buffer.
	.endif


 FHdr 'Width',0 ; ( -- adr )  User variable
Width:	LDAL VWidth
	JMPR DoUser


 FHdr 'Warning',0 ; ( -- adr )  User variable
Warning: LDAL VWarning
	JMPR DoUser


 FHdr 'Fence',0 ; ( -- adr )  User variable
Fence:	LDAL VFence
	JMPR DoUser


 FHdr 'DP',0 ; ( -- adr )  User variable
DP:	LDAL VDP
	JMPR DoUser


 FHdr 'Voc-Link',0 ; ( -- adr )  User variable
VocL:	LDAL VVoc_Link
	JMPR DoUser


 FHdr 'Blk',0 ; ( -- adr )  User variable
Blk:	LDAL VBlk
	JMPR DoUser


 FHdr 'In',0 ; ( -- adr )  User variable
In:	LDAL VIn
	JMPR DoUser


 FHdr '>IN',0 ; ( -- a-addr )
   ; a-addr is the address of a cell containing the offset in characters from the start of the input
   ; buffer to the start of the parse area.
   ; https://forth-standard.org/standard/core/toIN
ToIn:	JMPR In


 FHdr 'Out',0 ; ( -- adr )  User variable
Out:	LDAL VOut
	JMPR DoUser


 FHdr 'Scr',0 ; ( -- adr )  User variable
Scr:	LDAL VScr
;	JMPR DoUser


DoUser: ; runtime.  Push A + user area base
	STAX ZW,ModBMRB,0	; push A
;	LDBD VUA		; add user area base
;	AAB
;	STBX ZW,ModBMRB,0	; push B
	RSR			; return


 FHdr 'Offset',0 ; ( -- adr )  User variable
Offset:	LDAL VOffset
	JMPR DoUser


 FHdr 'Context',0 ; ( -- adr )  User variable
Context: LDAL VContext
	JMPR DoUser


 FHdr 'Current',0 ; ( -- adr )  User variable
Current: LDAL VCurrent
	JMPR DoUser


 FHdr 'State',0 ; ( -- adr )  User variable
State:	LDAL VState
	JMPR DoUser


 FHdr 'Base',0 ; ( -- adr )  User variable 
Base:	LDAL VBase
	JMPR DoUser


 FHdr 'DPL',0 ; ( -- adr )  User variable
DPL:	LDAL VDPL
	JMPR DoUser


 FHdr 'Fld',0 ; ( -- adr )  User variable
Fld:	LDAL VFld
	JMPR DoUser


 FHdr 'CSP',0 ; ( -- adr )  User variable
CSP:	LDAL VCSP
	JMPR DoUser


 FHdr 'R#',0 ; ( -- adr )  User variable
RNum:	LDAL VRNum
	JMPD DoUser


 FHdr 'Hld',0 ; ( -- adr )  User variable
Hld:	LDAL VHld
	JMPD DoUser


	.if 0
 FHdr 'N',0 ; ( -- adr )  User variable
N:	LDAL VN
	JMPD DoUser
	.endif


 FHdr 'FPtr',0 ; ( -- adr )  User variable
FPtr:	LDAL VFPtr
	JMPD DoUser


 FHdr 'FpLo',0 ; ( -- adr )  User variable
FpLo:	LDAL VFpLo
	JMPD DoUser


 FHdr 'FpHi',0 ; ( -- adr )  User variable
FpHi:	LDAL VFpHi
	JMPD DoUser


 FHdr 'Here',0 ; ( -- n )  Leave the address of the next available dictionary location.
   ; https://forth-standard.org/standard/core/HERE
Here:	LDAD VDP		; get next available dictionary location
	STAX ZW,ModBMRB,0	; push it
	RSR			; return


 FHdr 'Latest',0 ; ( -- addr )
   ; Leave the code field address of the topmost word in the CURRENT vocabulary.
Latest:	LDAI VCurrent
	STAX ZW,ModBMRB,0	; push A
	RSR


 FHdr 'CMove',0 ; ( src_addr dest_addr len -- )
   ; Move the specified quantity of bytes beginning at src_addr to dest_addr.
   ; The contents of src_addr is moved first proceeding toward high memory.
   ; Further specification is necessary on word addressing computers.
   ; This would probably run faster if it took advantage of word load & store.
   ; https://forth-standard.org/standard/string/CMOVE
   ; Also: CPU6 0xf7 memcpy instruction
CMove:	STXX SW,ModBMRB,0	; save X
	LDXX ZW,ModBRPB,0	; pop len
	LDAX ZW,ModBRPB,0	; pop dest
	XAY
	LDBX ZW,ModBRPB,0	; pop src
	XFR XW,XW		; len=0?
	BZ @Done
@4:	LDABX BW,ModBRPB,0	; copy a byte
	STABX YW,ModBRPB,0
	DCX
	BNZ @4
@Done:	LDXX SW,ModBRPB,0	; restore X
	RSR


 FHdr 'CMove>',0 ; ( src_addr dest_addr len -- )
   ; Move the specified quantity of bytes beginning at src_addr to dest_addr.
   ; Moves proceeding toward low memory.
   ; This would probably run faster if it took advantage of word load & store.
   ; https://forth-standard.org/standard/string/CMOVEtop
CMoveG:	STXX SW,ModBMRB,0	; save X
	LDXX ZW,ModBRPB,0	; pop len
	LDAX ZW,ModBRPB,0	; pop dest
	XAY
	LDBX ZW,ModBRPB,0	; pop src
	XFR XW,XW		; len=0?
	BZ @Done
	ADD BW,XW
	ADD YW,XW
@4:	LDABX BW,ModBMRB,0	; copy a byte
	STABX YW,ModBMRB,0
	DCX
	BNZ @4
@Done:	LDXX SW,ModBRPB,0	; restore X
	RSR


 FHdr 'Move',0 ; ( src_addr dest_addr len -- )
   ; After this move, the u bytes at addr2 contain exactly what the u bytes at addr1 contained before
   ; the move (no â€œclobberingâ€ occurs).
   ; https://forth-standard.org/standard/core/MOVE
Move:	LDAX ZW,ModNBRB,4
	LDBX ZW,ModNBRB,2
	SAB
	BL CMove	
	JMPR CMoveG


	.if 0
 FHdr 'Compare',0 ; ( addr1 u1 addr2 u2 â€” n )
   ;Compare the string specified by addr1 and u1 to the string specified by addr2 and u2.
   ; The strings are compared, beginning at the given addresses, character by character up
   ; to the length of the shorter string, or until a difference is found.
   ; If both strings are the same up to the length of the shorter string, then the longer
   ; string is greater than the shorter string.
   ; n is -1 if the string specified by addr1 and u1 is less than the string specified by addr2 and u2.
   ; n is zero if the strings are equal.
   ; n is 1 if the string specified by addr1 and u1 is greater than the string specified by addr2 and u2.
   ; https://forth-standard.org/standard/string/COMPARE
Compare:
	STXX SW,ModBMRB,0	; save X
	XFR AW,ZW		; save Z
	STAX SW,ModBMRB,0

	JSRD Abort ;???

	LDBX ZW,ModBRPB,0	; pop u2
	LDAZ ZW,ModBRPB,0	; pop addr2
	XAY
	LDAX ZW,ModBRPB,0	; pop u2
	SAB
	STBA ZW			; save u1-u2
	BL @17
	LDAA ZW
@17:	XAY			; save min(u1,u2)
	XFR AW,ZW		; push Z
	STAX SW,ModBMRB,0

	LDAX ZW,ModNBRB,2	; X = addr2
	XAX
	LDAX ZW,ModNBRB,6	; Z = addr1
	XAZ
@12:	DCR YW,1
	BZ @30
	LDABX XW,ModBRPB,0	; get chars
	LDBBX ZW,ModBRPB,0
	SABB
	BZ @12

@20:	CLR BW,0
	RLR BW,2
	INR SW,2		; rdrop u1-u2
@22:	LDAA SW			; restore Z
	XAZ
	INR ZW,6		; drop u2, addr2, u1
	STBA ZW			; save n
	LDXX SW,ModBRPB,0	; restore X
	RSR

@30: ; chars are equal, compare lengths
	
	.endif


 FHdr 'Fill',0 ; ( adr len value -- )  Fill memory at the address with the specified quantity of bytes value.
   ; https://forth-standard.org/standard/core/FILL
Fill:	LDBX ZW,ModBRPB,0	; pop value
Fill1:	XFR YW,XW		; save X
	LDAX ZW,ModBRPB,0	; pop len
	INA
	LDXX ZW,ModBRPB,0	; pop adr
	JMPR @8

@2:	STBBX XW,ModBRPB,0	; store a byte
@8:	DCA			; count it
	BNZ @2
	XFR XW,YW		; restore X
	RSR


 FHdr 'Erase',0 ; ( adr len -- )  Clear a region of memory to zero from addr over len addresses.
   ; https://forth-standard.org/standard/core/ERASE
Erase:	LDBBL 0			; fill value
	JMPR Fill1		; do Fill, & return


 FHdr 'Blanks',0 ; ( adr count -- )  Fill an area of memory beginning at addr with blanks.
   ; https://forth-standard.org/standard/string/BLANK
Blanks:	LDBBL ' '		; fill value
	JMPR Fill1		; do Fill, & return

;----------------------
; 1st Terminal muliplexer port

Term0CmdStat = $f200	; command (Write) & status (Read)
Term0Data = $f201	; data tx (Write) & rx (Read)

;TermInit:
;	LDABL $c5		; configure UART - 9600,n,8,1
;	STABD Term0CmdStat
;	RSR


 FHdr 'Key',0 ; ( -- n )
   ; Leave the ASCII value of the next terminal key struck.
   ; https://forth-standard.org/standard/core/KEY
Key:
	.if 1
	JMPD Tty_GetC

KeyA = Tty_GetC_A ; reads one terminal keystroke to A

	.else

	JSRR KeyA
	STAX ZW,ModBMRB,0	; push it on param stack
	RSR			; return

KeyA: ; reads one terminal keystroke to A
@1:	LDABD Term0CmdStat	; char ready?
	SRAB
	BNL @Empty
	CLA			; get char
	LDABD Term0Data
	LDBBL $7f		; strip hi bit
	ANDB AL,BL
	RSR

@Empty:	; queue empty
;	JSRD Pause		; wait awhile
	JMPR @1			; & try again

	.endif


 FHdr '?Terminal',0 ; ( -- f )
   ; Perform a test of the terminal keyboard for actuation of the break key.
   ; A true flags indicates actuation.
   ; This definition is installation dependent.
QTerminal:
	.if 1
	JMPD Tty_Next

QTerminalA:
	JSRR QTerminal
	LDAX ZW,ModBRPB,0	; set flags too
	RSR

	.else
	JSRR QTerminalA
	STAX ZW,ModBMRB,0	; push it
	RSR			; return

QTerminalA: ; leaves a boolean in A & V flag representing terminal break
	CLA
	LDABD Term0CmdStat
	LDBL 1
	ANDC AW,BW
	RSR
	.endif


 FHdr 'Emit',0 ; ( n -- )
   ; Transmit ASCII char n to the selected output device.
   ; OUT is incremented for each char output.
   ; https://forth-standard.org/standard/core/EMIT
Emit:	; writes one ASCII character to terminal
	LDAD VOut	; count the char
	INA
	STAD VOut
	.if 1
	JMPD Tty_PutC
	.else
@1:	LDABD Term0CmdStat ; ready?
	SRAB
	SRAB
	BNL @Full

	LDAX ZW,ModBRPB,0	; pop n
	STABD Term0Data		; transmit it
	RSR

@Full:	; queue full
;	JSRD Pause		; wait awhile
	JMPR @1			; & try again
	.endif


EmitA: ; writes one ASCII character in A to terminal
	STAX ZW,ModBMRB,0	; push char
	STBX SW,ModBMRB,0	; push B
	XFR BW,YW		; push Y
	STBX SW,ModBMRB,0
	JSRR Emit		; do it
	LDAX SW,ModBRPB,0	; pop Y
	XAY
	LDBX SW,ModBRPB,0	; pop B
	RSR


 FHdr 'CR',0 ; ( -- )  Transmit a carriage return and line feed to the selected output device.
   ; https://forth-standard.org/standard/core/CR
CR:	LDABL $0d		; send CR
	JSRR EmitA
	LDABL $0a		; send LF
	JSRR EmitA
	CLA			; clear output position
	STAD VOut
	RSR


 FHdr 'Space',0 ; ( -- )  InseRSR an ASCII blank to the output device.
   ; https://forth-standard.org/standard/core/SPACE
Space:	LDABL ' '
	JMPR EmitA


 FHdr 'Spaces',0 ; ( n -- )  Transmit n ASCII blanks to the output device.
   ; https://forth-standard.org/standard/core/SPACES
Spaces:	JMPR @8

@2:	STAA ZW			; save n
	JSRR Space		; type 1 space
@8:	LDAA ZW			; load n
	DCA			; decrement n
	BP @2			; >=0?
	INR ZW,2		; drop n
	RSR			; return


 FHdr 'Type',0 ; ( adr len -- )  Transmit len chars from addr to the selected output device.
   ; https://forth-standard.org/standard/core/TYPE
Type:	LDAA ZW			; test remaining length
	BZ @9
	DCA			; decrement length
	STAA ZW
	LDBX ZW,ModNBRB,2	; get addr
	LDABX BW,ModBRPB,0	; get char
	STBX ZW,ModNBRB,2	; save updated addr
	JSRR EmitA		; send to console
	JMPR Type

@9:	INR ZW,4		; pop len & adr
	RSR			; return


 FHdr 'Hex',0 ; ( -- )  Set the numeric conversion base to sixteen (hexadecimal).
   ; https://forth-standard.org/standard/core/HEX
Hex:	LDAL 16			; Base=16
	JMPR Decim3


 FHdr 'Decimal',0 ; ( -- )  set the numeric conversion base for decimal input-output.
   ; https://forth-standard.org/standard/core/DECIMAL
Decimal: CLR AW,10		; Base=10
Decim3:	STAD VBase
	RSR


	.if 0
 FHdr 'Octal',0 ; ( -- )  set the numeric conversion base for octa input-output.
Decimal: CLR AW,8		; Base=8
	JMPR Decim3
	.endif


PadSize = 68	; PAD is 68 ( C/L + a little) bytes above here.

 FHdr 'Pad',0 ; ( -- adr )  address of the text output buffer, which is a fixed offset above HERE .
   ; https://forth-standard.org/standard/core/PAD
Pad:	JSRR PadA		; get Pad in A
	STAX ZW,ModBMRB,0	; push it
	RSR			; return

PadA:	LDAD VDP		; get dictionary location
	LDBL PadSize
	ADD AW,BW
	RSR


 FHdr '<#',0 ; ( --- )
   ; Setup for pictured numeric output formatting using the words:
   ;	<# # #S SIGN #>
   ; The conversion is done on a double number producting text at PAD .
   ; https://forth-standard.org/standard/core/num-start
BDigs:	JSRR PadA		; Hld= PAD addr
	STAD VHld
	RSR			; return


 FHdr 'Hold',0 ; ( c -- )
   ; Used between <# and #> to insert an ASCII char into a pictured numeric
   ; output string.  e.g. 2E HOLD will place a decimal point.
   ; https://forth-standard.org/standard/core/HOLD
Hold:	LDAX ZW,ModBRPB,0	; pop c
HoldA:	LDBD VHld
	STABX BW,ModBMRB,0	; decr addr & store char
	STBD VHld
	RSR			; return


	.if 0
 FHdr 'HoldS',0 ; ( c-addr u -- )
   ; Adds the string represented by c-addr u to the pictured numeric output string.
   ; An ambiguous condition exists if HOLDS executes outside of a <# #> delimited number conversion.
   ; https://forth-standard.org/standard/core/HOLDS
HoldS:	LDAX ZW,ModNBRB,2	; get c-addr
	XAY
@11:	LDAA ZW			; get u
	BZ @19
	DCA
	STAA ZW
	LDABX YW,ModBRPB,0	; get char
	JSRD EmitA
	JMPR @11

@19:	INR ZW,4		; drop u & c-addr
	RSR
	.endif


 FHdr '#>',0 ; ( ud -- adr count )
   ; Terminates numeric output conversion by dropping ud, leaving the text
   ; addres and char count suitable for TYPE.
   ; https://forth-standard.org/standard/core/num-end
EDigs:	LDAD VHld
	STAX ZW,ModNBRB,2	; store adr
	JSRD PadA		; count=PAD-Hld
	LDBD VHld
	SAB
	STBA ZW			; store count
	RSR			; return


 FHdr 'Sign',0 ; ( n d -- d )
   ; Stores an ASCII '-' sign just before a converted numeric output string in the text
   ; buffer when n is negative.  n is discarded, but double number d is maintained.
   ; Must be used between <# and #> .
   ; https://forth-standard.org/standard/core/SIGN
Sign:	JSRD Rot		; bring n to top of param stack
	LDAX ZW,ModBRPB,0	; <0?
	BP @3496
	LDABL '-'		;   append '-'
	BNZ HoldA
@3496:	RSR			; return


 FHdr '#',0 ; ( ud1 -- ud2 )
   ; Generate from a double number ud1, the next ASCII char which is placed in
   ; an output string.  Result ud2 is the quotient after division by BASE, and
   ; is maintained for further processing.  Used between <# and #>.  See #S.
   ; https://forth-standard.org/standard/core/num
Hash:	LDAD VBase
	STAX ZW,ModBMRB,0	; ( ud1 u )
	JSRD MSlashMod		; ( rem ud2 )
	JSRD Rot		; ( ud2 remainder )
	LDAX ZW,ModBRPB,0	; pop remainder
	LDBBL 10		; >=10?
	SABB
	BNL @3517
	LDBBL 7			;   change from ASCII digit to letter
	ADDB AL,BL
@3517:	LDBBL '0'		; convert to ASCII
	ADDB AL,BL
	JMPR HoldA		; append to HOLD, & return


 FHdr '#S',0 ; ( ud1 -- ud2 )
   ; Generates ASCII text in the text output buffer, by the use of #, until
   ; a zero double number ud2 results.  Used between <# and #>.
   ; https://forth-standard.org/standard/core/numS
HashS:
@3529:	JSRR Hash		; do a digit
	LDAX ZW,ModNBRB,2	;  until ud1=0
	LDBA ZW
	ORI BW,AW
	BNZ @3529
	RSR			; return


 FHdr 'D.R',0 ; ( d numdigits -- )
   ; Print a signed double number d right aligned in a field n chars wide.
   ; https://forth-standard.org/standard/double/DDotR
DDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
	STAX SW,ModBMRB,0
DDotR3:	JSRD Swap		; push sign under d
	JSRD Over
	JSRD DAbs		; d=abs(d)
	JSRD BDigs		; begin collecting string
	JSRR HashS		; do all digits
	JSRR Sign		; do sign
DDotR7:	JSRD EDigs		; end collecting string
	LDAX SW,ModBRPB,0	; get numdigits from return stack
	LDBA ZW			; calc # of padding spaces
	SAB
	STBX ZW,ModBMRB,0	; type that many spaces
	JSRD Spaces
	JMPD Type		; type the string, & return


 FHdr 'UD.R',0 ; ( d numdigits -- )
   ; Print an unsigned double number d right aligned in a field n chars wide.
UDDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
	STAX SW,ModBMRB,0
	JSRD BDigs		; begin collecting string
	JSRR HashS		; do all digits
	JMPR DDotR7


 FHdr 'UD.',0 ; ( d -- )
UDDot:	JSRD BDigs		; begin collecting string
	JSRR HashS		; do all digits
	JSRD EDigs		; end collecting string
	JSRD Type
	JMPD Space


 FHdr 'D.',0 ; ( d -- )  Print a signed double number from a 32 bit two's complement value.
   ; The high-order 16 bits are most accessable on the stack.  Conversion is
   ; performed according to the current BASE .  A blank follows.
   ; https://forth-standard.org/standard/double/Dd
DDot:	JSRD Zero		; push min # of digits
	JSRR DDotR		; do D.R
	JMPD Space		; type a space, & return


 FHdr '.R',0 ; ( n numdigits -- )
   ; https://forth-standard.org/standard/core/DotR
DotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
	STAX SW,ModBMRB,0
	JSRD SToD		; convert n to double
	JMPR DDotR3		; do D.R, & return


 FHdr 'U.R',0 ; ( u numdigits -- )
   ; https://forth-standard.org/standard/core/UDotR
UDotR:	LDAX ZW,ModBRPB,0	; move numdigits to return stack
	STAX SW,ModBMRB,0
	CLA			; convert u to double
	STAX ZW,ModBMRB,0
	JMPR DDotR3		; do D.R, & return


 FHdr 'U.',0 ; ( u -- )
   ; https://forth-standard.org/standard/core/Ud
UDot:	JSRD Zero
	JSRR UDotR
	JMPD Space


 FHdr '.',0 ; ( n -- )  Print a number from a signed 16 bit two's complement value,
   ; converted according to the numeric BASE.  A traling blank follows.
   ; https://forth-standard.org/standard/core/d
Dot:	JSRD SToD		; convert n to double
	JMPR DDot		; do D. , & return


 FHdr '?',0 ; ( adr -- )  Print the value contained at the address
   ; in free format according to the current base.
   ; https://forth-standard.org/standard/tools/q
Ques:	JSRD At			; fetch the word at addr
	JMPR Dot		; type it, & return


	.if 0
 FHdr 'Accept',0 ; ( addr u1 -- u2 )  Receives u1 characters (or until carriage return) from the
   ; terminal keyboard and stores them, starting at the address.
   ; The count of received characters is returned.
	.endif


 FHdr 'Expect',0 ; ( addr count -- )
   ; Transfer chars from the terminal to address, until a "return" or the count of
   ; chars have been received.  One or more nulls area added at the end of the text.
Expect:	STXX SW,ModBMRB,0	; push X
	CLR XW,0		; index=0
@next:	JSRD KeyA
	LDBD VBS		; backspace?
	SABB
	BZ @bs
	LDBBL $0D		; return?
	SABB
	BZ @cr

	LDBX ZW,ModNBRB,2
	ADD BW,XW
	STABA BW		; store the char
	INXC			; advance index
	JSRD EmitA		; update the terminal
	LDBA ZW			; at end_of_line?
	SUB BW,XW
	BNL @next

@cr:	LDBX ZW,ModNBRB,2	; insert trailing NULLs
	ADD BW,XW
	CLA
	STAA BW
	LDXX SW,ModBRPB,0	; pop X
	INR ZW,4		; TwoDrop
	RSR

@bs:	XFR BW,XW		; at begin_of_line?
	BZ @next
	DCX			; back up ptr
	LDABL $08		; back up terminal
	JSRD EmitA
	JMPR @next		; next


 FHdr 'Query',0 ; ( -- )
   ; Input 80 chars of text (or until a "return") from the operators terminal.
   ; Text is positioned at the address contained in TIB with IN set to zero.
Query:	CLA			; IN=0
	STAD VIn
	LDAD VTIB		; buffer addr
	STAX ZW,ModBMRB,0
	LDAL 80			; 80 characters from terminal
	STAX ZW,ModBMRB,0
	JMPR Expect


 FHdr '(Abort)',0 ;
; Executes after an error when WARNING is -1.  This word normally executes ABORT,
; but may be altered (with care) to a user's alternative procedure.
PAbort:	JMPD Abort


 FHdr 'Error',0 ; ( error_number -- in blk )  Execute error notification and restart of the system.
   ; WARNING is first examined.  If 1, the text of line n, relative to screen 4 of drive 0 is
   ; printed.  This line number may be positive or negative, and beyond just screen 4.
   ; If WARNING=0, n is just printed as a message number (non disc installation).
   ; If WARNING is -1, the definition (ABORT) is executed, which executes the system ABORT.
   ; The user may cautionsly modify this execute by altering (ABORT) .
   ; fig-FORTH saves the contents of IN and BLK to assist in determinging the location of the error.
   ; Final action is execution of QUIT .
Error:	LDAD VWarning		; Warning<0?
	BM PAbort
	JSRD Space
	JSRD Here		; type the interpreted word
	JSRD Count
	JSRD Type
	JSRD PDotQuote		; type "  ? "
	.byte 5,'  ?',0,' '	; "?\0 " sequence triggers simulator to stop feeding text from file
	JSRD Message		; type the error
	JSRD EmptyStack		; empty the param stack
	JSRD PDotQuote		; show text position
	.byte 7," Block="
	LDAD VBlk
	STAX ZW,ModBMRB,0
	JSRD Dot
	JSRD PDotQuote
	.byte 7,"Offset="
	LDAD VIn
	STAX ZW,ModBMRB,0
	JSRD Dot
	JMPD Quit		; restart the interpreter


 FHdr '?Stack',0 ; ( -- )  Issue an error message if the stack is out of bounds.
QStack:	LDAL TOS+1		; param atack beyond empty?
	SUB AW,ZW
	BL @underflow
	LDAL BOS+6		; param stack beyond full?
	SUB AW,ZW
	BNL @overflow
	RSR

@underflow: CLR BW,Err_StackUnderflow
	JMPR ErrorY

@overflow: LDBL Err_StackOverflow
	JMPR ErrorY


 FHdr '?Error',0 ; ( f n -- )  Issue an error message number n, if f is true;
QErr:	LDBX ZW,ModBRPB,0	; pop n
QErrY:	LDAX ZW,ModBRPB,0	; f true?
	BNZ ErrorY2		;   signal error
	RSR			; return


 FHdr '?Comp',0 ; ( -- )  Issue error message if not compiling.
QComp:	LDBL Err_CompileOnly
	LDAD VState		; not compiling?
	BZ ErrorY		;   signal error
	RSR			; return

ErrorY:				; error code in B
	DCR ZW,2
ErrorY2: STBA ZW
	JMPD Error	


 FHdr '?Exec',0 ; ( -- )  Issue an error message if not executing.
QExec:	LDBL Err_ExecuteOnly
	LDAD VState		; compiling?
	BNZ ErrorY		;   signal error
	RSR			; return


 FHdr '?Pairs',0 ; ( n1 n2 -- )  Issue an error message if n1 != n2.
   ; The message indicates that compiled conditionals do not match.
QPairs:	LDAX ZW,ModBRPB,0	; pop n2
QPairsA: LDBX ZW,ModBRPB,0	; pop n1
	SAB			; n2<>n1?
	BZ QComp		; also verify we're compiling
	LDBL Err_ConditionalsNotPaired
	JMPR ErrorY2		;   signal error


 FHdr '!CSP',0 ; ( -- )  Save the param stack index in CSP. Used as part of the compiler security.
SCSP:	XFR AW,ZW
	STAD VCSP
	RSR


 FHdr '?CSP',0 ; ( -- )  Issue error message if stack index <> value saved in CSP.
QCSP:	LDBL Err_DefinitionNotFinished
	LDAD VCSP		; param stack index different than saved?
	SUB AW,ZW
	BNZ ErrorY		;   signal error
	RSR			; return


 FHdr '?Loading',0 ; ( -- )  Issue an error message if not loading.
QLoad:	LDBL Err_UseOnlyWhenLoading
	LDAD VBlk		; no block?
	BZ ErrorY		;   signal error
	RSR			; return


	.if 0
 FHdr 'Buffer:',0
   ; Compile: ( u "<spaces>name" -- )
   ;   Skip leading space delimiters. Parse name delimited by a space. Create a definition for name, with the execution
   ;   semantics defined below. Reserve u address units at an aligned address.
   ;   Contiguity of this region with any other region is undefined.
   ; name Execution:
   ;   ( -- a-addr )
   ;   a-addr is the address of the space reserved by BUFFER: when it defined name.
   ;   The program is responsible for initializing the contents.
   ; https://forth-standard.org/standard/core/BUFFERColon
BufferColon:
	JSRD Create
	JMPR Allot
	.endif


 FHdr 'Allot',0 ; ( n -- )  Add the signed number to the dictionary pointer DP.
   ; May be used to reserve dictionary space or re-origin memory.
   ; n is with regard to computer address type (byte or word).
   ; https://forth-standard.org/standard/core/ALLOT
Allot:	LDAX ZW,ModBRPB,0	; pop n
AllotA:	LDBD VDP		; add to DP
	AAB
AllotCheck:
	STBD VDP
	LDAL DictTop-PadSize	; out of space?
	SAB
	LDBL Err_DictionaryFull
	BNL ErrorY
	RSR			; return


 FHdr 'Unused',0 ; ( -- u )  Return the space remaining in the region addressed by HERE, in address units.
   ; https://forth-standard.org/standard/core/UNUSED
Unused:	LDAL DictTop-PadSize
	LDBD VDP
	SAB
	STBX ZW,ModBMRB,0
	RSR


;----------------------------------------------------------------------
; Random #s

 FHdr 'RndState',0  ; 2Variable
RndState1:
	LDAL RndState
	STAX ZW,ModBMRB,0
	RSR


	.if 0
 FHdr 'SRand',0 ; ( d -- ) set random # state
   ; Pause is also modifying RndState
SRand:	LDBX ZW,ModBRPB,0
	LDAX ZW,ModBRPB,0
	JMPR Rand8
	.endif


 FHdr 'Rand',0 ; ( -- n )  generate next random #
   ; https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Galois_LFSRs
   ; https://en.wikipedia.org/wiki/Xorshift
Rand: ; 32bit Galois LFSR
	LDAD 2+RndState		; BA=state
	LDBD 0+RndState
	BNZ @39			; fix state=0
	XAY
	BNZ @39
	INA
@39:
	RL			; BA>>=1
	RRR BW,1
	RRR AW,1
	BNL @49

	XFR YW,XW		; save X
	LDXL $d000		; BA^=$d0000001
	ORE BW,XW
	LDXL $0001
	ORE AW,XW
	XFR XW,YW		; restore X
@49:	STAX ZW,ModBMRB,0	; return value
Rand8:	STBD 0+RndState		; save state
	STAD 2+RndState
	RSR


	.if 0
 FHdr 'RndTest1',0 ; ( -- d )  test Rand period
	LDBD 0+RndState		; push original state
	LDAD 2+RndState
	STAX SW,ModBMRB,0
	STBX SW,ModBMRB,0
	CLA			; 0.
	STAX ZW,ModBMRB,0
	STAX ZW,ModBMRB,0
@3:
	LDAA ZW			; increment d
	INA
	STAA ZW
	BNZ @19
	LDAX ZW,ModNBRB,2
	INA
	STAX ZW,ModNBRB,2
	JSRD EX4A
	JSRD Space
@19:
	JSRR Rand		; gen next number
	INR ZW,2		;   drop result
	XAY
	LDAA SW			;  compare
	SAB
	BNZ @3
	LDAX SW,ModNBRB,2
	SUB AW,YW
	BNZ @3

	INR SW,4		; rdrop starting state
	JMPD Swap		; fix count
	.endif


 FHdr 'RandM',0 ; ( umod -- u ) random integer between 0 & umod-1
RandM:	LDAX ZW,ModBRPB,0	; save umod
	STAX SW,ModBMRB,0
	JSRR Rand		; get next random #
	STBX SW,ModBMRB,0	; save hi part
	LDBX SW,ModBRPB,0
	STBX ZW,ModBMRB,0
	JSRD UMSlashMod
	INR ZW,2		; drop quotient
	RSR


 FHdr 'Defer',0 ; ( "<spaces>name" -- )  https://forth-standard.org/standard/core/DEFER
   ;   Skip leading space delimiters. Parse name delimited by a space. Create a definition for name with the execution semantics defined below.
   ; name Execution:
   ;   ( i * x -- j * x )
   ;   Execute the xt that name is set to execute. An ambiguous condition exists if name has not been set to execute an xt.
Defer:	JSRD HeaderComma	; compile word header
	LDAL Abort
	JMPD JmpCommaA


 FHdr 'Defer@',0 ; ( xt1 -- xt2 )  https://forth-standard.org/standard/core/DEFERFetch
   ;  xt2 is the execution token xt1 is set to execute. An ambiguous condition exists if xt1 is not the execution token of a word defined by DEFER, or if xt1 has not been set to execute an xt.
DeferAt:
	LDAA ZW			; get xt1
	; check that the xt1 word is a Defer ?
	LDBX AW,ModNBRB,1	; get jMPD operand
	STBA ZW			; store xt2
	RSR


 FHdr 'Defer!',0 ; ( xt2 xt1 -- )  https://forth-standard.org/standard/core/DEFERStore
   ; Set the word xt1 to execute xt2. An ambiguous condition exists if xt1 is not for a word defined by DEFER.
DeferStore:
	LDAX ZW,ModBRPB,0	; pop xt1
	; check that the xt1 word is a Defer ?
	LDBX ZW,ModBRPB,0	; pop xt2
	STBX AW,ModNBRB,1	; store xt2 into JMPD operand
	RSR


	.if 0

 FHdr 'Is',ha_immedate ; 
   ; Interpretation:
   ;   ( xt "<spaces>name" -- )
   ;   Skip leading spaces and parse name delimited by a space. Set name to execute xt.
   ;   An ambiguous condition exists if name was not defined by DEFER.
   ; Compilation:
   ;   ( "<spaces>name" -- )
   ;   Skip leading spaces and parse name delimited by a space. Append the run-time semantics given below to the current definition.
   ;   An ambiguous condition exists if name was not defined by DEFER.
   ; Run-time:
   ;   ( xt -- )
   ;   Set name to execute xt.
   ; An ambiguous condition exists if POSTPONE, [COMPILE], ['] or ' is applied to IS.
   ; https://forth-standard.org/standard/core/IS
Is:	JSRD Tick		; look up the name
	LDBD VState		; compiling?
	BZ DeferStore

	JSRD Swap
	LDABL $90		; LDAL xt
	JSRD CCommaA
	JSRD Comma
	LDABL $b1		; STAD name 
	JSRD CCommaA
	JMPD Comma


 FHdr 'Action-Of',ha_immediate ; https://forth-standard.org/standard/core/ACTION-OF
   ; Interpretation:
   ;   ( "<spaces>name" -- xt )
   ;   Skip leading spaces and parse name delimited by a space. xt is the execution token that name is set to execute.
   ;   An ambiguous condition exists if name was not defined by DEFER, or if the name has not been set to execute an xt.
   ; Compilation:
   ;   ( "<spaces>name" -- )
   ;   Skip leading spaces and parse name delimited by a space. Append the run-time semantics given below to the current definition.
   ;   An ambiguous condition exists if name was not defined by DEFER.
   ; Run-time:
   ;   ( -- xt )
   ;   xt is the execution token that name is set to execute. An ambiguous condition exists if name has not been set to execute an xt.
   ;   An ambiguous condition exists if POSTPONE, [COMPILE], ['] or ' is applied to ACTION-OF.
	JSRD Tick		; look up the inline name
	LDAA ZW			; get name addr
	LDABA AW		; check word 1st opcode
	LDBBL $71		;    for JMPD
	SABB
	BNZ @Abort

	LDAD VState		; compiling?
	BZ DeferAt

	LDABL $91		; LDAD name+1
	JSRD CCommaA
	JSRD OnePlus
	JSRD Comma
	JMPD PushAComma		; STAX ZW,ModBMRB,0	; push it

	.endif


	.if 0

 FHdr 'Align',ha_inline ; ( -- )  https://forth-standard.org/standard/core/ALIGN
   ; If the data-space pointer is not aligned, reserve enough space to align it.
	; do nothing, CPU6 doesn't care
	.dbyt INL_End


 FHdr 'Aligned',ha_inline ; ( addr -- a-addr )  https://forth-standard.org/standard/core/ALIGNED
   ; a-addr is the first aligned address greater than or equal to addr.
		; do nothing, CPU6 doesn't care
	.dbyt INL_End

	.endif


	.if 0
 FHdr 'Postpone',0
   ; Interpretation:
   ;   Interpretation semantics for this word are undefined.
   ; Compilation:
   ;   ( "<spaces>name" -- )
   ;   Skip leading space delimiters. Parse name delimited by a space. Find name.
   ;   Append the compilation semantics of name to the current definition.
   ;   An ambiguous condition exists if name is not found.
   ; https://forth-standard.org/standard/core/POSTPONE
	JSRD Abort ;???
	.endif


	.if 0
 FHdr 'Recurse',ha_immediate
   ; Interpretation:
   ;   Interpretation semantics for this word are undefined.
   ; Compilation:
   ;   ( -- )
   ;   Append the execution semantics of the current definition to the current definition.
   ;   An ambiguous condition exists if RECURSE appears in a definition after DOES>.
   ; https://forth-standard.org/standard/core/RECURSE
	LDBI VCurrent		; start of last word
	JMPD JsrCommaA
	.endif


	.if 0
 FHdr '[Compile]',ha_immediate  ; https://forth-standard.org/standard/core/BracketCOMPILE
   ; Interpretation:
   ;   Interpretation semantics for this word are undefined.
   ; Compilation:
   ;   ( "<spaces>name" -- )
   ;   Skip leading space delimiters. Parse name delimited by a space. Find name. If name has other than default
   ; compilation semantics, append them to the current definition; otherwise append the execution semantics of name.
   ; An ambiguous condition exists if name is not found.
	JSRD Tick
	JMPR CompileComma
	.endif


 FHdr 'Compile,',0 ; ( addr -- ) compile a call to a word
   ; Not quite standard: it expects an nfa so it can look at the ha_inline flag bit
   ; https://forth-standard.org/standard/core/COMPILEComma
CompileComma:
	LDAX ZW,ModBRPB,0	; pop addr from param stack
CompileCommaA: ; nfa (name field addr, also code addr) in A
	LDBBX AW,ModNBRB,$fd	; get flag & length byte
	BP JsrCommaA		; not ha_inline, do JSR
	XAY			; copy inline bytes until marker
@11:	LDAA YW
	LDBL INL_End
	SAB
	BZ @19
	XFRB AL,AH
	PUSH YH,2
	JSRR CCommaA
	POP YH,2
	INR YW,1
	JMPR @11
@19:	RSR


 FHdr 'Jsr,',0 ; ( adr -- )  compile a "JSRD adr" to call a word
	LDAX ZW,ModBRPB,0	; pop adr
JsrCommaA:
	STAX SW,ModBMRB,0	; save addr
	LDABL $79		; compile "JSRD direct" opcode
Compile16:
	JSRR CCommaA		; compile opcode
	LDAX SW,ModBRPB,0	; compile 2byte operand, & return
	JMPR CommaA


 FHdr 'Jmp,',0 ; ( adr -- )  compile a "JMPD adr"
JmpComma:
	LDAX ZW,ModBRPB,0
JmpCommaA:
	STAX SW,ModBMRB,0	; save operand
	LDABL $71		; "JMPD abs" opcode
	JMPR Compile16



 FHdr ',',0 ; ( n -- )  Append n onto the dictionary.
   ; https://forth-standard.org/standard/core/Comma
Comma:	LDAX ZW,ModBRPB,0	; pop n
CommaA:	LDBD VDP		; store into dictionary
	STAX BW,ModBRPB,0
Comma2:	CLA			; store 0 (not required, helps in case of interrupted compile)
	STAA BW
	JMPD AllotCheck


 FHdr '2,',0 ; ( d -- )  Append d onto the dictionary
TwoComma:
	JSRR Comma	; do hi word
	JMPR Comma	; do lo word, & return


 FHdr 'C,',0 ; ( n -- )  Append byte n onto the dictionary.
   ; https://forth-standard.org/standard/core/CComma
CComma:	LDAX ZW,ModBRPB,0	; pop n
CCommaA: LDBD VDP		; store
	STABX BW,ModBRPB,0
	JMPR Comma2		; finish & return


LdbaComma: ; ( d -- )  compile ldb # & lda #
	LDABL $d0		; LDBL n	do hi word
	JSRR LdComma
	JMPR LdaComma		;		do lo word

LdaCommaA: ; compile lda #
	STAX ZW,ModBMRB,0
LdaComma: ; compile lda #
	LDABL $90		; LDAL n
LdComma: JSRR CCommaA
	JMPR Comma


  .if 0
 FHdr 'Compile',0 ; ( -- )
   ; see Compile,
   ; When the word containing COMPILE executes, the execution address of the word
   ; following COMPILE is copied (compiled) into the dictionary.  This allows
   ; specific compilation situations to be handled in addition to simply compiling
   ; an execution address (which the interpreter already does).
Compile:
	JSRD QComp	; verify we're compiling
	LDAX SW,ModBRPB,0 ; get the word following the call to me
	JMPR CompileCommaA ; compile the call, & return
  .endif


 FHdr 'Branch,',0 ; ( DestAddr branch_opcode -- ) compile a branch back
BranchComma:
	LDAX ZW,ModBRPB,0	; pop opcode
BranchCommaA:
	STAX SW,ModBMRB,0	; save branch_opcode
	LDBA ZW			; A=relative displacement of addr
	DCR BW,2
	LDAD VDP
	SUB AW,BW
	LDBL $80		; in range of an 8-bit displacement?
	SAB
	BNL @Short
	LDBL $ff80
	SAB
	BNL @Long

@Short:	STAA ZW			; drop addr, save displacement
	LDAX SW,ModBRPB,0	; compile branch_opcode
	JSRD CCommaA
	JMPD CComma		; compile branch displacement, & return

@Long:	LDAX SW,ModBRPB,0	; get branch_opcode
	LDBL $73		; unconditional branch opcode?
	SABB
	BZ JmpComma
	XFRB AH,AL		; complement the branch opcode sense
	LDABL 1	
	OREB AH,AL
	LDABL 3			; set displacement to 3
	JSRD CommaA		; compile the branch
	JMPD JmpComma


; FHdr '(0Branch',0 ; ( f A=addr -- )  The run-time procedure to conditionally branch.
;PZBranch: ; ( f A=addr -- )  0Branch runtime
;	LDBX ZW,ModBRPB,0	; if f is false
;	BNZ @9
;	XFR XW,BW
;@9:	RSR

PZBranchComma: ; ( adr -- ) compile (0Branch)
	LDAL $D581		; LDBX ZW,ModBRPB,0 to pop & test flag
	JSRD CommaA
	LDABL $14		; compile BZ
	JMPR BranchCommaA


	.if 0
 FHdr 'Ahead',0
   ; Interpretation:
   ;   Interpretation semantics for this word are undefined.
   ; Compilation:
   ;   ( C: -- orig )
   ;   Put the location of a new unresolved forward reference orig onto the control flow stack.
   ;   Append the run-time semantics given below to the current definition.
   ;   The semantics are incomplete until orig is resolved (e.g., by THEN).
   ;
   ; Run-time:
   ;   ( -- )
   ;   Continue execution at the location specified by the resolution of orig.
Ahead:
	JSRD Abort ;???
	.endif


 FHdr 'If',ha_immediate	; ( f -- ) (run-time)
			; ( -- addr n ) (compile)
   ; Occurs in a colon-definition in form:
   ;	IF (tp) ... ENDIF
   ;	IF (tp ... ELSE (fp) ... ENDIF
   ; At run-time, IF selects execution based on a bool flag.  If f is true
   ; (non-zero), execution continues ahead thru the true part.  If f is false
   ; (zero), execution skips till just after ELSE to execute the false part.
   ; After either part, execution resumes after ENDIF . ELSE and its false part
   ; are optional. If missing, false execution skips to just after ENDIF .
   ;
   ; At compile-time IF compiles 0BRANCH and reserves space for an offset at
   ; addr.  addr and n are used later for resolution of the offset and
   ; error testing.
   ; https://forth-standard.org/standard/core/IF
If:	JSRD QComp		; verify we're compiling - this is bad news for interpreting
	LDAL Abort		; push dest addr
	STAX ZW,ModBMRB,0
	JSRR PZBranchComma	; compile (0Branch)
	JSRD Here		; push addr for fixup later
If7:	JMPD Two		; push "IF" pairing code, & return


 FHdr 'Else',ha_immediate ; ( addr1 n1 -- addr2 ) (compiling)
   ; Occurs within a colon-definition in the form:
   ;	IF ... ELSE ... ENDIF
   ; At run-time, ELSE executes after the true part following IF . ELSE forces
   ; execution to skip over the following false part and resumes execution
   ; after the ENDIF . It has no stack effects.
   ;
   ; At compile-time ELSE replaces BRANCH reserving a branch offset, leaves
   ; the address addr2 and n2 for error testing.  ELSE also resolves the
   ; pending forward branch from IF by calculation the offset from addr1
   ; to HERE and storing at addr1.
   ; https://forth-standard.org/standard/core/Dotq
Else:	LDAL Abort		; compile "jmp abort", addr to be fixed up later
	JSRD JmpCommaA
	JSRR Then		; fixup the IF
	JSRD Here		; save addr for fixup later
	JMPR If7		; finish


 FHdr 'Then',ha_immediate ; ( addr n -- ) (compile)
   ; Occurs in a colon-definition in form:
   ;	IF ... ENDIF
   ;	IF ... ELSE ... THEN
   ; At run-time, ENDIF serves only as the destination of a forward branch from
   ; IF or ELSE . It marks the conclusion of the conditional structure.
   ; THEN is another name for ENDIF.  Both names are supported in fig-FORTH.
   ; See also IF and ELSE .
   ;
   ; At compile-time, ENDIF computes the forward branch offset from addr to
   ; HERE and stores it at addr. n is used for error tests.
   ; https://forth-standard.org/standard/core/THEN
Then:	LDAL 2		; verify we're paired with an IF , & compiling
	JSRD QPairsA
	LDBX ZW,ModBRPB,0	; fixup IF branch addr
	LDAD VDP
	STAX BW,ModNBRB,$fe
	RSR		; return


	.if 0
 FHdr 'EndIf',ha_immediate ;  FIG alias
	JMPR Then
	.endif


 FHdr 'Begin',ha_immediate ;  https://forth-standard.org/standard/core/BEGIN
   ; Compiling: ( -- addr n )
   ; Occurs in a colon-definition in the form:
   ;	BEGIN ... UNTIL
   ;	BEGIN ... AGAIN
   ;	BEGIN ... WHILE ... REPEAT
   ; At run-time, begin marks the start of a sequence that may be repetetively executed.
   ; It serves as a return point from the corresponding UNTIL , AGAIN or REPEAT .
   ; When executing UNTIL , a return to BEGIN will occur if the top of
   ; the stack is false; for AGAIN and REPEAT a return to BEGIN always occurs.
   ;
   ; At compile time BEGIN leaves its return address and n for compiler error checking.
Begin:	JSRD QComp	; verify we're compiling
	JSRD Here	; push dictionary addr
	JMPD One	; push "Begin" pairing code, & return


 FHdr 'Until',ha_immediate ;  (     f -- ) (run-time)
			  ;  ( adr n -- ) (compile)
   ; Occurs withing a colon-definition in the form:
   ;	BEGIN .. UNTIL
   ; At run-time, UNTIL controls the conditional branch back to the corresponding
   ; BEGIN .  If f is false, execution returns to just after BEGIN ;
   ; if true, execution continues ahead.
   ;
   ; At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to addr.
   ; n is used for error tests.
   ; https://forth-standard.org/standard/core/UNTIL
Until:	LDAL 1		; varify we're paired with a BEGIN, & compiling
	JSRD QPairsA
	JMPD PZBranchComma ; compile a 0Branch 


 FHdr 'End',ha_immediate ; FIG alias
	JMPR Until


 FHdr 'Again',ha_immediate ; ( addr n -- ) (compiling)
   ; Used in a colon-definition in the form:
   ;	BEGIN ... AGAIN
   ; At run-time, AGAIN forces execution to return to the corresponding BEGIN.
   ; Three is no effect on the stack.  Execution cannot leave this loop (unless
   ; R> DROP is executed one level below).
Again:	LDAL 1		; verify we're paired with a BEGIN, & compiling
	JSRD QPairsA
	LDABL $73	; compile "jmpr adr", & return
	JMPD BranchCommaA


 FHdr 'While',ha_immediate ; (    f -- ) (run-time)
				  ; ( ad1 n1 -- ad1 n1 ad2 n2 )
   ; Occurs in a colon-definition in the form:
   ;	BEGIN ... WHILE (tp) ... REPEAT
   ; At run-time, WHILE selects conditional executing based on bool flag f.
   ; If f is true (non-zero), WHILE continues execution of the true part thru to
   ; REPEAT , which then branches back to BEGIN .  If f is false (zero), execution
   ; skips to just after REPEAT , exiting the structure.
   ;
   ; At compile time, WHILE emplaces (0BRANCH) and leaves ad2 of the reserved
   ; offset.  The stack values will be resolved by REPEAT .
   ; https://forth-standard.org/standard/core/WHILE
While:	JMPD If


 FHdr 'Repeat',ha_immediate ; ( addr n -- ) (compiling)
   ; Used withing a colon-definition in the form:
   ;	BEGIN ... WHILE ... REPEAT
   ; At run-time, REPEAT forces an unconditional branch back to just after
   ; the corresponding BEGIN .
   ;
   ; At compile-time, REPEAT compiles BRANCH and the offset from HERE to addr.
   ; n is used for pairing testing.
   ; https://forth-standard.org/standard/core/REPEAT
Repeat:	JSRD ToR		; save While info
	JSRD ToR
	JSRR Again		; compile branch to Begin
	JSRD RFrom		; restore While info
	JSRD RFrom
	JMPR Then		; fixup While


	.if 0

;----------------------------------------------------------------------
; Case
;   9 Of ." JACK" EndOf
;  10 Of ." QUEEN" EndOf
;  11 Of ." KING" EndOf
;  12 Of ." ACE" EndOf
;       Dup 2 + .
;  EndCase


	.if 0
 FHdr 'Case',ha_Immediate ;  http://forth-standard.org/standard/core/CASE
   ; Interpretation: Interpretation semantics for this word are undefined.
   ; Compilation: ( C: -- case-sys )
   ;	Mark the start of the CASE. . .OF. . .ENDOF. . .ENDCASE structure. Append the run-time
   ;	semantics given below to the current definition.
   ; Run-time: ( -- )
   ;	continue execution.
Case:	LDAL Case
	STAX ZW,ModBMRB,0
	JMPD Zero
	.endif


	.if 0
 FHdr '?Of',ha_Immediate ; accept flag
QOf:	JSRD Abort ;???
	lda #@x
	jsr CompileInlineA
	bra Of3

@x:	PopAm
	tay
	bne @x4
	jmp Abort
@x4:	.word INL_End
	.endif


 FHdr 'Of',ha_Immediate ;  http://forth-standard.org/standard/core/OF
   ; Interpretation: Interpretation semantics for this word are undefined.
   ; Compilation: ( C: -- of-sys )
   ;	Put of-sys onto the control flow stack. Append the run-time semantics given below to the
   ;	current definition. The semantics are incomplete until resolved by a consumer of of-sys
   ;	such as ENDOF.
   ; Run-time: ( x1 x2 -- | x1 )
   ;	If the two values on the stack are not equal, discard the top value and continue execution
   ;	at the location specified by the consumer of of-sys, e.g., following the next ENDOF.
   ;	Otherwise, discard both values and continue execution in line.
Of:	JSRD Abort ;???
	lda #OfX
	jsr CompileInlineA
Of3:	lda #Of
	jsr Mark2
	lda #$e8e8	; inx inx
	jmp CommaA

OfX:	PopAm
	cmp 0,x
	bne *
	.word INL_End


	.if 0

 FHdr 'Of>',ha_Immediate
OfG:	lda #0 ;???	; (ble)
	JSRD Abort ;??? bra of2


 FHdr 'Of>=',ha_Immediate
OfGe:	lda #0 ;???	; (blt)
	JSRD Abort ;??? bra of2


 FHdr 'Of<',ha_Immediate
OfL:	lda #0 ;???	; (bge)
	JSRD Abort ;??? bra of2


 FHdr 'Of<=',ha_Immediate
OfLe:	lda #0 ;???	; (bgt)
	JSRD Abort ;??? bra of2

	.endif


 FHdr 'EndOf',ha_Immediate ;  http://forth-standard.org/standard/core/ENDOF
   ; Interpretation: Interpretation semantics for this word are undefined.
   ; Compilation: ( C: case-sys1 of-sys -- case-sys2 )
   ;	Mark the end of the OF. . .ENDOF part of the CASE structure. The next location for a
   ;	transfer of control resolves the reference given by of-sys. Append the run-time semantics
   ;	given below to the current definition. Replace case-sys1 with case-sys2 on the controlflow
   ;	stack, to be resolved by ENDCASE.
   ; Run-time: ( -- )
   ;	continue execution at the location specified by the consumer of case-sys2.
EndOf:	JSRD Abort ;???
	lda 2,x
	cmp #Of
	bne @90
	lda 6,x
	cmp #Case
	bne @90
	lda 4,x
	ldy MPtr
	sty 4,x
	jsr JmpCommaA

	lda MPtr	;fix the OF
	sec
	sbc 0,x		;  calc branch displacement
	cmp #$80	;  check range
	bcs @range
	dec 0,x
	sep #pm
	sta (0,x)
	rep #pm
	jmp DDrop

;	ldy 0,x		;fix the OF
;	dey		;  short version in-range?
;	dey
;	dey
;	sty @adr
;	lda mp
;	sec
;	sbc @adr
;	cmp #$80
;	bcs @75
;	dey		;  modify to short version
;	dey
;	sep #pm
;	sta a:1,y	;    store displacement
;	lda a:0,y	;    flip sense of branch
;	eor #$20
;	sta a:0,y
;	lda #$89	;    pad with bit #
;	sta a:2,y
;	rep #pm
;	lda #0
;	sta a:3,y
;	bra @79
;
;@75:	lda mp		; fix long version
;	sta a:1,y
;@79:	jmp DDrop

@range:	jsr DotQuoteR
	.byte 12," Too large! "
@90:	jsr Abort


 FHdr 'EndCase',ha_Immediate ;  http://forth-standard.org/standard/core/ENDCASE
   ; Interpretation: Interpretation semantics for this word are undefined.
   ; Compilation: ( C: case-sys -- )
   ;	Mark the end of the CASE. . .OF. . .ENDOF. . .ENDCASE structure. Use case-sys to resolve
   ;	the entire structure. Append the run-time semantics given below to the current definition.
   ; Run-time: ( x -- )
   ;	Discard the case selector x and continue execution.
EndCase:
	lda #$e8e8	; inx; inx  drop selector
	jsr CommaA
	lda 2,x
	cmp #Case
	bne @90
	ldy 0,x		;fix endof jmp list
	beq @19
@11:	lda a:1,y
	pha
	lda MPtr
	sta a:1,y
	ply
	bne @11
@19:	jmp DDrop

@90:	jsr Abort

	.endif


 FHdr 'Do',ha_immediate	; ( n1 n2 -- ) (execute)
			; ( addr n -- ) (compile)
   ; Occurs in a colon-definition in form:
   ;	DO ... LOOP
   ;	DO ... +LOOP
   ; At run time, DO begins a sequence with repetitive execution controlled by a
   ; loop limit n1 and an index with initial valie n2.  DO removes these from the
   ; stack.  Upon reaching LOOP the index is incremented by one.  Until the new
   ; index equals or exceeds the limit, execution loops back to just after DO ;
   ; otherwise the loop parameters are discarded and execution continues ahead.
   ; Both n1 and n2 are determined at run-time and may be the results of other
   ; operations.  Within a loop 'I' will copy the current value of the index to
   ; the stack.  See I Loop +LOOP LEAVE .
   ; When compiling within the colon-definitions, DO compiles (DO) , leaves the
   ; following addresss addr and n for later error checking.
   ; https://forth-standard.org/standard/core/DO
Do:	LDAL PDo		; compile "jsr PDo"
	JSRD JsrCommaA
	JSRD Here		; push addr
	JMPD Three		; push DO pairing code, & return

PDo: ; runtime
	JMPD TwoToR
;	LDAX ZW,ModBRPB,0	; pop index
;	LDBX ZW,ModBRPB,0	; pop limit
;	STBX SW,ModBMRB,0	; push limit
;	STAX SW,ModBMRB,0	; push index
;	RSR			; return


	.if 0
 FHdr '?DO',ha_immediate
   ; Interpretation:
   ;   Interpretation semantics for this word are undefined.
   ; Compilation:
   ;   ( C: -- do-sys )
   ;   Put do-sys onto the control-flow stack. Append the run-time semantics given below to the current definition.
   ;   The semantics are incomplete until resolved by a consumer of do-sys such as LOOP.
   ;
   ; Run-time:
   ;   ( n1 | u1 n2 | u2 -- ) ( R: -- loop-sys )
   ;   If n1 | u1 is equal to n2 | u2, continue execution at the location given by the consumer of do-sys.
   ;   Otherwise set up loop control parameters with index n2 | u2 and limit n1 | u1 and continue executing immediately following ?DO. Anything already on the return stack becomes unavailable until the loop control parameters are discarded. An ambiguous condition exists if n1 | u1 and n2 | u2 are not both of the same type.
   ; https://forth-standard.org/standard/core/qDO
	.endif


 FHdr 'Leave',0 ; ( -- )
   ; Force termination of a DO-LOOP at the next opportunity by setting the loop limit
   ; equal to the current value of the index.  The index itself remains unchanged, and
   ; execution proceeds normally until LOOP or +LOOP is encountered.
   ; https://forth-standard.org/standard/core/LEAVE
Leave:	LDAX SW,ModNBRB,2	; limit=index
	STAA SW
	RSR			; return


	.if 0
 FHdr 'Unloop',ha_immedate
   ; Interpretation:
   ;   Interpretation semantics for this word are undefined.
   ; Execution:
   ;   ( -- ) ( R: loop-sys -- )
   ;   Discard the loop-control parameters for the current nesting level.
   ;   An UNLOOP is required for each nesting level before the definition may be EXITed.
   ;   An ambiguous condition exists if the loop-control parameters are unavailable.
Unloop:	INR SW,4	; rdrop index & limit
	RSR
	.endif


 FHdr 'I',0 ; ( -- n )
   ; Used within a DO-LOOP to copy the loop index to the stack.
   ; Other use is implementation dependent.
   ; See R .
   ; https://forth-standard.org/standard/core/I
I:	LDAA SW			; get 1st DO index
	STAX ZW,ModBMRB,0	; push it
	RSR			; return


 FHdr 'J',0 ; ( -- n )
   ; Used within a DO-LOOP to copy the loop limit to the stack.
   ; Other use is implementation dependent.
   ; See I .
   ; https://forth-standard.org/standard/core/J
J:	LDAX SW,ModNBRB,4	; get 2nd DO index
	STAX ZW,ModBMRB,0	; push it
	RSR			; return


 FHdr 'Loop',ha_immediate; ( addr n -- ) (compiling)
   ; Occurs in a colon-definition in form:
   ;	DO ... LOOP
   ; At run-time, LOOP selectively controls branching back to the corresponding
   ; DO based on the loop index and limit.  The loop index is incremented by one
   ; and compared to the limit.  The branch back to DO occurs until the index >= limit;
   ; at than time, the parameters are discarded and execution continues ahead.
   ;
   ; At compile-time, uses addr to calculate an offset to DO .  n is used for error testing.
   ; https://forth-standard.org/standard/core/LOOP
Loop:	LDAL 3			; verify we're paired with a DO, & compiling
	JSRD QPairsA

	LDAL PLoop		; compile "jsr PLoop"
Loop7:	JSRD JsrCommaA
	LDABL $16		; compile "BM addr", & return
	JMPD BranchCommaA

;	FHdr '(Loop)',0 ; ( -- )  LOOP runtime
PLoop:
	LDAA SW			; increment index
	INA
	STAA SW
	LDBX SW,ModNBRB,2	; signed compare to limit
	SAB
	BNF @Run2		; if overflow
	IVA			;   correct sign
@Run2:
	BM @Run9		; if limit reached
	INR SW,4		;   rdrop index & limit
	CLA			;   clear neg flag to indicate fall thru
@Run9:	RSR			; returns negative flag: clear=fall thru, set=loop back


 FHdr '+Loop',ha_immediate ; (      n1 -- ) (run)
			   ; ( addr n2 -- ) (compile)
   ; Used in a colon-definition in the form:
   ;	DO  ...  n1 +LOOP
   ; At run-time, +LOOP selectively controls branching back to the corresponding
   ; DO based on n1, the loop index and the loop limit.  The signed increment
   ; n1 is added to the index and the total compared to the limit.  The branch
   ; back to DO occurs until the new index is >= the limit (n1>0), or until the
   ; new index is <= the limit (n1<0).  Upon exiting the loop, the parameters
   ; are discarded and execution continues ahead.
   ;
   ; At compile time, +LOOP compiles the run-time word (+LOOP) and the branch
   ; offset from HERE to the address left on the stack by DO.  n2 is used for
   ; compile time error checking.
   ; https://forth-standard.org/standard/core/PlusLOOP
PlusLoop:
	LDAL 3		; verify we're paired with a DO , & compiling
	JSRD QPairsA
	LDAL PPlusLoop	; compile "jsr PPlusLoop"
	JMPR Loop7	; & finish


; FHdr '(+Loop)',0 ; ( n -- )  The run-time procecdure compiled by +LOOP,
		; which increments the loop index by n and tests for loop completion.
PPlusLoop:
	LDAX ZW,ModBRPB,0	; pop n
	XAY
	LDBA SW			; add n to index
	AAB
	STBA SW
	BF @Quit		; if overflow, we're done for sure
	LDAX SW,ModNBRB,2	; compare index with limit
	SUB AW,BW
	BNF @3			; overflow?
	IVA			;   correct overflowed sign
@3:	ORE AW,YW		; take into account the sign of n
	BM @9			; if limit reached
@Quit:	INR SW,4		;   rdrop index & limit
	CLA			;   clear negative flag
@9:	RSR			; returns negative flag: clear=fall thru, set=loop back


 FHdr 'Create',0 ;
   ; A defining word used in the form:
   ;	CREATE cccc
   ; by such words as CODE and CONSTANT to create a dictionary header for a Forth
   ; definition.  The code field contains the address of the words parameter field.
   ; The new word is created in the CURRENT vocabulary.
   ; https://forth-standard.org/standard/core/CREATE
Create:	JSRD HeaderComma	; compile word header
	LDAL @Run		; compile "jsr @Run", & return
	JMPD JsrCommaA

@Run:	STXX ZW,ModBMRB,0	; push pfa
	LDXX SW,ModBRPB,0	; return to my caller's caller
	RSR


; FHdr 'Header,',0 ( "name" -- )  compile a word header
   ; name is next word in input buffer.
HeaderComma:
	JSRD DFind		; check for name redefinition
				; DFind also stores the name at HERE, including a preceding length
				; byte that we don't use, but haven't discarded here yet.
	LDAX ZW,ModBRPB,0	; found an existing word of the same name?
	BZ @2163
	INR ZW,2		;   drop flags
;	JSRD CFA		;   CFA & NFA are the same in this implementation
	JSRD IdDot		;   type name
	LDAL Err_IsntUnique	;   type message
	JSRD MessageA
	JSRD Space		;   type space
@2163:
	CLA			; get name length
	LDABI VDP
	LDBBL ha_length+1	; name too long?
	SABB
	BL @NameTooLong
	STAX SW,ModBMRB,0	; save name length on return stack

	INA			;   ???include the unused leading string char count byte
	JSRD AllotA		; skip over stored name

	LDAX SW,ModBRPB,0	; get original length
	JSRD CCommaA		; store flags & length

	LDAI VCurrent		; store dictionary link
	JSRD CommaA
	LDAD VDP		; link into current vocabulary
	STAI VCurrent

	RSR			; return

@NameTooLong:
	JSRD Abort


 FHdr 'Inline',0 ; ( -- )
   ; Mark the most recently made definition so that when encountered at compile time,
   ; it will be copied inline instead of JSRd to.
Inline:
	JSRD Exit		; compile 2nd RSR as an end-of-word marker
	LDABL ha_inline
	JMPR XorFlags


 FHdr 'Immediate',0 ; ( -- )
   ; Mark the most recently made definition so that when encountered at compile time,
   ; it will be executed rather than being compiled.  i.e. the precedence bit in its
   ; header is set.  This method allows definitions to handle unusual compiling
   ; situations, rather than build them into the fundamental compiler.  The user may
   ; force compilation of an immediate definition by preceding it with [COMPILE] .
   ; https://forth-standard.org/standard/core/IMMEDIATE
Immediate:
	LDABL ha_immediate
	JMPR XorFlags


 FHdr 'Smudge',0 ; ( -- )
   ; Used during word definition to toggle the "smudge bit" in a definitions' name
   ; field.  This prevents an uncompleted definition from being found during
   ; dictionary searches, until compiling is completed without error.
Smudge:	LDABL ha_smudge
XorFlags:
	XAY			; Y=bits
	LDBI VCurrent		; B=word ptr
	LDABX BW,ModNBRB,$fd	; xor flags
	OREB AL,YL
	STABX BW,ModNBRB,$fd
	RSR


	.if 0
 FHdr 'Postpone',0 ; ( "xxx" â€” ) ???
   ; Used in the definition of a compiling word. When the compiling word, in turn, is used in a
   ; source definition, the execution token of xxx will be compiled into the dictionary entry so
   ; that when the new definition is executed, xxx will be executed.
   ;Used in a colon definition, causes the immediate word xxx to be compiled as though it were
   ; not immediate; xxx will be executed when the definition is executed.
	JSRD Abort ;???
	.endif


 FHdr 'Variable',0 ; ( "name" n -- )
   ; A defining word used in the form:
   ;	n VARIABLE cccc
   ; When VARIABLE is executed, it creates the definition cccc with its parameter field
   ; initialized to n.  When cccc is later executed, the address of it's parameter field
   ; (containing n) is left on the stack, so that a fetch or store may access this location.
   ; https://forth-standard.org/standard/core/VARIABLE
Variable:
	JSRD Create	; create a word that pushes it's parameter address
Varia2:	CLA
	JMPD CommaA	; alloc data space & store initial value


 FHdr '2Variable',0 ; ( "name" n -- )
   ; A defining word used in the form:
   ;	d 2VARIABLE cccc
   ; When 2VARIABLE is executed, it creates the definition cccc with its parameter field
   ; initialized to d.  When cccc is later executed, the address of it's parameter field
   ; (containing d) is left on the stack, so that a fetch or store may access this location.
   ; https://forth-standard.org/standard/double/TwoVARIABLE
TwoVariable:
	JSRR Variable		; header & 1st 2 bytes
	JMPR Varia2		; 2nd 2 bytes


 FHdr 'Constant',0 ; ( n "name" -- )
   ; A definining word used in the form:
   ;	n CONSTANT cccc
   ; to create word cccc.
   ; When cccc is lated executed, it will push the value of n to the stack.
   ; https://forth-standard.org/standard/core/CONSTANT
Constant:
	JSRD HeaderComma	; compile a word header
	JSRD LitComma		; compile "lda #n", "sta (-z)"
	JMPD Exit		; compile "rsr", & return


 FHdr '2Constant',0 ; ( d "name" -- )
   ; A definining word used in the form:
   ;	d 2CONSTANT cccc
   ; to create word cccc.
   ; When cccc is lated executed, it will push the value of d to the stack.
   ; https://forth-standard.org/standard/double/TwoCONSTANT
TwoConstant:
	JSRD HeaderComma	; compile a word header
	JSRD LdbaComma		; compile "lda #d.lo; ldb #d.hi
	LDAL PushBA 		; compile "JMPD PushBA"
	JMPD JmpCommaA


	.if 0

 FHdr 'Value',0
   ; https://forth-standard.org/standard/core/VALUE
Value:	JMPR Constant


 FHdr '2Value',0
   ; https://forth-standard.org/standard/double/TwoVALUE
TwoValue:
	JMPR TwoConstant


 FHdr 'To',0
   ; Interpretation:
   ;   ( i * x "<spaces>name" -- )
   ;   Skip leading spaces and parse name delimited by a space. Perform the "TO name run-time" semantics given in the definition for the defining word of name. An ambiguous condition exists if name was not defined by a word with "TO name run-time" semantics.
   ;
   ; Compilation:
   ; ( "<spaces>name" -- )
   ;   Skip leading spaces and parse name delimited by a space. Append the "TO name run-time" semantics given
   ;   in the definition for the defining word of name to the current definition.
   ;   An ambiguous condition exists if name was not defined by a word with "TO name run-time" semantics.
   ; https://forth-standard.org/standard/core/TO
To:	JSRD Abort ;???

	.endif


 FHdr ':',ha_immediate ; ( "name" -- )  Start compiling a word
   ; Used in the form:
   ;	: ccc  ...  ;
   ; Creates a dictionary entry defining ccc as equivalent to the following
   ; sequence of Forth word definitions '...' until the next ';' or ';CODE'.
   ; The compiling process is done by the text interpreter as long as STATE is
   ; non-zero.  Other details are that the CONTEXT vocabulary is set to the CURRENT
   ; vocabulary and that WORDS with the precedence bit set (P) are executed
   ; rather that being compiled.
   ; https://forth-standard.org/standard/core/Colon
Colon:	JSRD HeaderComma	; compile word header
	JSRD Smudge		; smudge the word so we won't find it until done
Colon3:	JSRD QExec		; verify we're not already compiling
	JSRD SCSP		; save param stack index to compare later
	LDAD VCurrent		; Context vocabulary = current vocabulary
	STAD VContext
	JMPR RBracket		; set compile mode, & return


 FHdr ';',ha_immediate ; ( -- )  Terminates a colon-definition and stop further compilation.
   ; https://forth-standard.org/standard/core/Semi
Semi:	JSRD QCSP		; check that param stack index = when we started compiling
	JSRR Exit		; compile "rsr"
	JSRD Smudge		; Un-smudge the word header
	JMPR LBracket		; set interpret mode, & return


	.if 0
 FHdr ':Noname',0 ; ( C: -- colon-sys ) ( S: -- xt )
   ; Create an execution token xt, enter compilation state and start the current definition, producing colon-sys.
   ; Append the initiation semantics given below to the current definition.
   ;
   ; The execution semantics of xt will be determined by the words compiled into the body of the definition.
   ; This definition can be executed later by using xt EXECUTE.
   ;
   ; If the control-flow stack is implemented using the data stack, colon-sys shall be the topmost item on the data stack.
   ; See 3.2.3.2 Control-flow stack.
CNoname:
	LDABL ha_smudge
	JSRD CCommaA		; compile flags & length
	CLA
	JSRD CommaA		; compile fake dictionary link
	JSRD Here		; push xt
	JMPR Colon3
	.endif


 FHdr 'Exit',ha_immediate ; ( -- ) https://forth-standard.org/standard/core/EXIT
   ; Interpretation: Interpretation semantics for this word are undefined.
   ; Execution: ( -- ) ( R: nest-sys -- )
   ;	Return control to the calling definition specified by nest-sys. Before executing EXIT
   ;	within a do-loop, a program shall discard the loop-control parameters by executing UNLOOP.
Exit:	LDABL $09		; compile a RSR ( replaces ;S call )
	JMPD CCommaA


 FHdr '[',ha_immediate ; ( -- )  Suspend compilation.
   ; Used in a colon-definition in form:
   ;	: xxx  [ words ]  more ;
   ; The words after [ are executed, not compiled.  This allows
   ; calculation or compilation exceptions before resuming compilation with ] .
   ; See LITERAL ]
   ; https://forth-standard.org/standard/core/Bracket
LBracket:
	CLA
LBrac3:	STAD VState	; set state to interpreting
	RSR		; return


 FHdr ']',0 ; ( -- )  Resume compilation, to the completion of a colon-definition.
   ; See [
RBracket:
	CLR AW,1	; set state to compiling (store non-zero)
	JMPR LBrac3


	.if 0
 FHdr 'Synonym',0 ; ( "<spaces>newname" "<spaces>oldname" -- )
   ; For both strings skip leading space delimiters. Parse newname and oldname delimited by a space.
   ; Create a definition for newname with the semantics defined below.
   ; Newname may be the same as oldname; when looking up oldname, newname shall not be found.
   ;
   ; An ambiguous conditions exists if oldname can not be found or IMMEDIATE is applied to newname.
   ; https://forth-standard.org/standard/tools/SYNONYM
Synonym:
	JSRD Colon	; start a new word
	JSRD Tick	; look up old word
	LDABL $71	; build JMPD
	JSRD CCommaA
	JSRD Comma
	JMPD Semi	; end new word
	.endif


 FHdr ';Code',ha_immediate
   ; Used in the form:
   ;	: ccc  ....  ;CODE
   ;		assembly mnemonics
   ; Stop compilation and terminate a new defining word cccc by compiling (;CODE) .
   ; Set the CONTEXT vocabulary to ASSEMBLER, assembling to machine code the following
   ; menmonics.
   ;
   ; When cccc later executes in the form:
   ;	cccc nnnn
   ; the word nnnn will be created with its execution procedure given by the machine
   ; code following cccc.  That is, when nnnn is executed, it does so by jumping to the
   ; code after nnnn.  An existing defining word must exist in cccc prior to ;CODE .
   ; https://forth-standard.org/standard/tools/SemiCODE
SCode:	JSRD QCSP	; make sure param stack is the same depth as when compile started
	LDAL PSCode	; compile "jsr PSCode"
	JSRD JsrCommaA

	JSRR LBracket	; state=interpret
	JMPD Smudge	; un-smudge the word header


; FHdr '(;Code)',0 ;
   ; The run-time procedure compiled by ;CODE, that rewrites the code field of the
   ; most recently defined word to point to the following machine code sequence.
   ; See ;CODE.
PSCode: LDBI VCurrent		; B=ptr to current word
	STXX BW,ModNBRB,1	; store in jsr operand of current word
	LDXX SW,ModBRPB,0	; pop my caller's addr
	RSR


	.if 0
 FHdr '<Builds',0 ; 
   ; Used within a colon-definition:
   ;	: cccc <BUILDS ...
   ;		DOES> ... ;
   ; Each time cccc is executed, <BUILDS defines a new word with a high-level
   ; execution procedure.  Executing cccc in the form:
   ;	cccc nnnn
   ; uses <BUILDS to create a dictionary entry for nnnn with a call to the DOES>
   ; part for nnnn.  When nnnn is later executed, it has the address of its
   ; parameter area on the stack and executes the words after DOES> in cccc.
   ; <BUILDS and DOES> allow run-time procedures to be written in high-level
   ; rather than in assembler code (as required by ;CODE ).
Builds:	JMPD Create		; start a word with jsr, "jsr" address will be patched later
	.endif


 FHdr 'Does>',ha_immediate ;
   ; A word which defines the run-time action withing a high-level defining word.
   ; DOES> alters the code field and first parameter of the new word to execute
   ; the sequence of compiled word addresses following DOES> .
   ; Used in combination with <BUILDS . When the DOES> part executes it begins with the
   ; address of the first parameter of the new word on the stack.
   ; This allows interpretation using this area or its contents.
   ; Typical uses include the Forth assembler, multidimensional arrays, and compiler generation.
   ; https://forth-standard.org/standard/core/DOES
DoesG:	LDAL PSCode
	JSRD JsrCommaA

	LDAL $6D82	; compile "STXX ZW,ModBMRB,0" to push PFA
	JSRD CommaA
	LDAL $65A1	; compile "LDXX SW,ModBRPB,0" to fix return stack
	JMPD CommaA


 FHdr '.(',ha_immediate ;  https://forth-standard.org/standard/core/Dotp
   ; Compilation:
   ;   Perform the execution semantics given below.
   ; Execution:
   ;   ( "ccc<paren>" -- )
   ; Parse and display ccc delimited by ) (right parenthesis). .( is an immediate word.
DotP:	LDBL ')'		; push ')'
DotP3:	STBX ZW,ModBMRB,0
	JSRD Word		; get counted string
	JSRD Here		; push counted string addr
	JSRD Count		; convert to addr & len
	JMPD Type		; type it & return


 FHdr '."',ha_immediate ;
   ; Used in the form
   ;	." cccc"
   ; Compiles an in-line string cccc (delimited by the trailing ") with an
   ; execution procedure to transmit the text to the selected output device.
   ; If execute outside a definition, ." will immediately print the text until
   ; the final ".  The maximum number of chars may be an installation depended
   ; value.  See (.") .
   ; https://forth-standard.org/standard/core/Dotq
DotQ:	LDBL '"'
	LDAD VState		; interpreting?
	BZ DotP3

	LDAL PDotQuote		; compile "jsr PDotQuote"
	JSRD JsrCommaA
	JMPR CountedStringComma


CountedStringComma: ; compile a counted string
	LDAL '"'		; push '"'
	STAX ZW,ModBMRB,0
	JSRD Word		; get counted string
	LDBD VDP		; alloc the space the string is using, & return
	CLA
	LDABA BW
	INA
	JMPD AllotA


; FHdr '(.")',0 ; ( -- )
   ; The run-time procedure, compiled by ." which transmits the following
   ; in-line text to the selected output device.  See ."
PDotQuote:
	CLA		; get length
	LDABX XW,ModBRPB,0
	STXX ZW,ModBMRB,0 ; push adr for TYPE
	STAX ZW,ModBMRB,0 ; push length for TYPE
	ADD XW,AW	; fix my return addr
	JMPD Type	; Type & return


	.if 0
 FHdr 'SLiteral',0
   ; Interpretation:
   ;    Interpretation semantics for this word are undefined.
   ; Compilation:
   ;   ( c-addr1 u -- )
   ;   Append the run-time semantics given below to the current definition.
   ;
   ; Run-time:
   ;   ( -- c-addr2 u )
   ;   Return c-addr2 u describing a string consisting of the characters specified by c-addr1 u
   ;   during compilation. A program shall not alter the returned string.
   ; https://forth-standard.org/standard/string/SLITERAL
SLiteral:
	JSRD Abort ;???
	.endif


 FHdr 'S"',ha_immediate ; â€œs-quoteâ€ https://forth-standard.org/standard/core/Seq
   ; Modified to append a null to the string, so it's also zero-terminated.
   ; Interpretation: ( "string" -- addr len )
   ; Compilation: ( â€œccc(quote)â€ -- )
   ;	Parse ccc delimited by " (double-quote). Append the run-time semantics given below to
   ;	the current definition.
   ; Run-time: ( -- c-addr u )
   ;	Return c-addr and u describing a string consisting of the characters ccc. A program shall
   ;	not alter the returned string.
SQuote:	LDAD VState		; compiling?
	BZ @19
	LDAL SQuoteR		;   compile JSRD
	JSRD JsrCommaA
@19:

	LDAL '"'		; get the counted string to VDP
	STAX ZW,ModBMRB,0
	JSRD Word
	LDBD VDP
	CLA
	LDABX BW,ModBRPB,0
	STBX ZW,ModBMRB,0	; push addr
	STAX ZW,ModBMRB,0	; push length
	INA			; allocate the space, & return
	JSRD AllotA
	CLA			; append a null
	JSRD CCommaA

	LDAD VState		; compiling?
	BZ @39
	INR ZW,4		;   drop addr & length
@39:
	RSR


; FHdr '(S")',0 ; ( -- c-addr u )	run-time code for S"
SQuoteR: CLA			; get length byte
	LDABX XW,ModBRPB,0
	STXX ZW,ModBMRB,0	; push addr
	STAX ZW,ModBMRB,0	; push length
	ADD XW,AW		; advance over the string data
	INXC			; also skip the trailing null
	RSR


	.if 0
 FHdr 'S\"',0
   ; Interpretation:
   ;   Interpretation semantics for this word are undefined.
   ; Compilation:
   ;   ( "ccc<quote>" -- )
   ;   Parse ccc delimited by " (double-quote), using the translation rules below. Append the run-time semantics
   ;   given below to the current definition.
	JSRD Abort ;???
	.endif


	.if 0
 FHdr 'Environment?',0 ; ( c-addr u -- false | i * x true )
EnvironmentQ:
	JSRD Abort ;???
	.endif


 FHdr '(Find)',0 ; ( addr1 addr2 -- cfa b true ) (found)
		; ( addr1 addr2 --      false ) (notfound)
   ; Searches the dictionary starting at the code address addr2,
   ; matching to the counted string at addr1.
   ; Returns name address (= code address), length byte of name field and boolean true for a good match.
   ; If not match is found, only a boolean false is left.
PFind:
	STXX SW,ModBMRB,0	; push X
@addr2 = 0	; current word addr; must be offset 0
@charlen = 2
@nameadr = 4	; * last char of pattern name
@len	= 6
@zw	= 8
	XFR AW,ZW
	STAX SW,ModBMRB,0	; @zw
	LDXX ZW,ModNBRB,2	; get addr1
	CLA			; get length
	LDABX XW,ModBRPB,0
	STAX SW,ModBMRB,0	; @len
	XAB
	ADD BW,XW
	STBX SW,ModBMRB,0	; @nameadr
	LDBBX BW,ModNBRB,$ff	; get last char of name
	XFRB AH,BL
	STAX SW,ModBMRB,0	; @charlen
	XFR AW,ZW		; @addr2
	INR AW,2
	STAX SW,ModBMRB,0

@21:	LDXX SW,ModBRB,@addr2	; reload word ptr
	LDAX SW,ModNBRB,@charlen ; reload constant regs
	XAZ
	LDAL $df*$100+ha_length+ha_smudge
@23:	LDXX XW,ModNBRB,$fe	; follow dictionary link to next word
	BZ @notfound
	LDBX XW,ModNBRB,$fc	; check last char & length
	ORE BW,ZW		;   saved @charlen
	NAB			;   saved bitmask
	BNZ @23
	STXX SW,ModBRB,@addr2	; save word ptr

	DCR XW,3		; X=1 + end of name in word
	LDAX SW,ModNBRB,@nameadr ; Y=1 + end of name pattern
	XAY
	LDAX SW,ModNBRB,@len	; Z=# chars in name
	XAZ
	LDABL $df
	XFRB ZH,AL
@32:				; for each char
	DCRB ZL			;   decrement length
	BM @found
	LDABX XW,ModBMRB,0	;   get name char
	LDBBX YW,ModBMRB,0	;   get pattern char
	OREB BL,AL		;   compare for exact match
	BZ @32
	ANDB BL,ZH		;   just a case mismatch?
	BNZ @21
	ANDB AL,ZH		;   cvt char to uppercase
	LDBBL 'A'		;   >='A'
	SABB
	BNL @21
	LDBBL 'Z'+1		;   <='Z'
	SABB
	BNL @32
	JMPR @21

@found:
	LDXX SW,ModBRB,@addr2	; get addr2
	INR SW,@zw		; rdrop the work area
	LDAX SW,ModBRPB,0	; restore ZW
	XAZ
	STXX ZW,ModNBRB,2	; save cfa
	CLA			; save b
	LDABX XW,ModNBRB,$fd
	STAA ZW
	LDAL 1			; push flag
	STAX ZW,ModBMRB,0
	LDXX SW,ModBRPB,0	; pop X
	RSR

@notfound:
	INR SW,@zw		; rdrop the work area
	LDAX SW,ModBRPB,0	; restore ZW
	XAZ
	INR ZW,2		; drop addr2
	CLA			; set flag false
	STAA ZW
	LDXX SW,ModBRPB,0	; pop X
	RSR			; return


	.if 0
 FHdr 'Find',0 ; ( c-addr -- c-addr 0 | xt 1 | xt -1 )
   ; https://forth-standard.org/standard/core/FIND
	JSRD Abort ;???
	.endif
		

 FHdr '-Find',0	; ( "name" -- cfa b true  ) (found)
		; ( "name" --       false ) (not found)
   ; Accepts the next text word (delimited by blanks) in the input stream to HERE,
   ; and searches the CONTEXT and then CURRENT vocabularies for a matching entry.
   ; If found, the dictionary entry's name field address (= CFA), its length byte,
   ; and a bool true is left.  Otherwise, only a bool false is left.
DFind:	JSRD Bl			; get next word
	JSRD Word

	.if 0  ; debugging
	JSRD PDotQuote
	.byte 13," found word '"
	JSRD Here
	JSRD Count
	JSRD Type
	JSRD PDotQuote
	.byte 2,"' "
	.endif

	JSRD Here		; search Context
	LDAI VContext
	STAX ZW,ModBMRB,0
	JSRD PFind
	LDAA ZW			; if not found
	BNZ @2073
	INR ZW,2		;    drop the false
	JSRD Here		;    search Current
	LDAI VCurrent
	STAX ZW,ModBMRB,0
	JSRD PFind
@2073:	RSR


 FHdr "'",ha_immediate ; ( "name" -- nfa )
   ; Used in the form:
   ;	' nnnn
   ; Leaves the code address of dictionary word nnnn.  As a compiler
   ; directive, executes in a colon-definition to compile the address as a
   ; literal.  If the word is not found after a search of CONTEXT and CURRENT,
   ; an appropriate error message is given.  Pronounced "tick". 
   ; https://forth-standard.org/standard/core/Tick
Tick:	JSRD DFind		; get name string, search active dictionarys
	JSRD ZEqual		; throw exception if not found
	CLR BW,Err_0
	JSRD QErrY
	INR ZW,2		; drop word flags
	JMPD Literal		; handle addr as literal


 FHdr 'LFA',0 ; ( pfa -- lfa )
   ; Convert the Parameter Field Address of a word to its Link Field Address.
LFA:	LDAA ZW
	DCR AW,3+2
	STAA ZW
	RSR


 FHdr 'CFA',0 ; ( pfa -- cfa )
   ; Convert the Parameter Field Address of a word to its Code Field Address.
CFA:	LDAA ZW
	DCR AW,3
	STAA ZW
	RSR


 FHdr 'NFA',0; ( pfa -- nfa )
   ; Convert the Parameter Field Address of a word to its Name Field Address.
NFA:	JMPR CFA		; NFA=CFA in this inplementaion


 FHdr 'PFA',0 ; ( nfa -- pfa )
   ; Convert the Name Field Address of a word to its Parameter Field Address.
PFA:	LDAA ZW			; NFA=CFA in this implementation
	INR AW,3
	STAA ZW
	RSR


 FHdr '>Body',0 ; ( xt -- a-addr )
   ; a-addr is the data-field address corresponding to xt.
   ; An ambiguous condition exists if xt is not for a word defined via CREATE.
   ; https://forth-standard.org/standard/core/toBODY
ToBody:	JMPR PFA


	.if 0

 FHdr 'Name>Compile',0 ; ( nt -- x xt )
   ; x xt represents the compilation semantics of the word nt.
   ; The returned xt has the stack effect ( i * x x -- j * x ).
   ; Executing xt consumes x and performs the compilation semantics of the word represented by nt.
   ; https://forth-standard.org/standard/tools/NAMEtoCOMPILE
NameToCompile:
	JSRD Abort ;???


 FHdr 'Name>Interpret',0 ; ( nt -- xt | 0 )
   ; xt represents the interpretation semantics of the word nt.
   ; If nt has no interpretation semantics, NAME>INTERPRET returns 0.
   ; https://forth-standard.org/standard/tools/NAMEtoINTERPRET
NameToInterpret:
	JSRD Abort ;???

	.endif


 FHdr 'Name>String',0 ; ( nfa -- c_addr u )
   ; Get a word's name from its Name Field Address (aka CFA).
   ;   https://forth-standard.org/standard/tools/NAMEtoSTRING
NameToString:
	LDAA ZW		; get nfa
	DCR AW,3
	XAY		; Y=cfa-3 (ptr to length & flags)
	LDABA YW	; get length
	LDBL ha_length
	ANDC AW,BW
	STAX ZW,ModBMRB,0 ; store length
	SUB AW,YW	; calc start addr
	STAX ZW,ModNBRB,2 ; store addr	
	RSR

;@6:
; ???handle limited stored chars
;	bit #$80
;	beq @3
;	bra @7
;@6:	lda #'-'
;	jsr EmitA
;@7:	DCR N
;	bpl @6

;	pla
;	jmp Space


 FHdr 'Id.',0 ; ( nfa -- )  Print a definition's name from its code field address.
IdDot:	JSRR NameToString
	JSRD Type
	JMPD Space


 FHdr '[Compile]',ha_immediate 
; Used in a colon-definition in form:
;	: xxx [COMPILE] FORTH ;
; [COMPILE] will force the compilation of an immediate definition, that would otherwise
; execute during compilation.  The above example will select the FORTH vocabulary when xxx
; executes, rather than at compile time.
BCompile:
	JSRD LBracket		; dont' have Tick compile it's results
	JSRD Tick		; lookup the word
;	JSRR CFA		; CFA=NFA in this implementation
	JSRD CompileComma	; compile call
	JMPD RBracket		; back to compiling, & return


 FHdr 'Literal',ha_immediate ; ( n -- ) (compiling)
; If compiling, then compile the stack value n as a 16 bit literal. This
; definition is immediate so that it will execute during a colon definition.
; The intended use is:
;	: xxx [ calculate ] LITERAL ;
; Compilation is suspended for the compile time calculation of a value.
; Compilation is resumed and LITERAL compiles this value.
; https://forth-standard.org/standard/core/LITERAL
Literal:
	LDAD VState		; interpreting?
	BNZ LitComma
	RSR

LitComma:
	JSRD LdaComma		; compile "LDAL n"
PushAComma:			; compile "sta (-z)" 
	LDAL $B582
	JMPD CommaA



 FHdr '2Literal',ha_immediate ; ( d -- d ) (executing)
			     ; ( d --   ) (compiling)
   ; If compiling, compile a stack double number into a literal.  Later execution
   ; of the definition containing the literal will push it to the stack.
   ; If executing, the number will remain on the stack.
   ; https://forth-standard.org/standard/double/TwoLITERAL
TwoLiteral:
	LDAD VState		; interpreting?
	BZ @2242

	JSRD LdbaComma		; compile "ldy #d.hi" "lda #d.lo"
	JSRD PushAComma		; compile "STAX ZW,ModBMRB,0"
	LDAL $F582		; compile "STBX ZW,ModBMRB,0"
	JMPD CommaA

@2242:	RSR			; return


 FHdr '[Char]',ha_immediate ; compile a character literal
   ; compile: ( "c" -- )
   ; run: ( -- c )
   ; Also: Number interprets 'c' as a character literal.
; https://forth-standard.org/standard/core/BracketCHAR
BChar:	JSRR Char
	JMPR Literal		; make a literal, & return


 FHdr 'Char',0 ; ( "<spaces>name" -- char )  Get value of ASCII char
   ; https://forth-standard.org/standard/core/CHAR
   ; Skip leading space delimiters. Parse name delimited by a space. Put the value of its first character onto the stack.
Char:	JSRD Bl			; get next word
	JSRD Word
	LDBD VDP		; point at counted string
	CLA			; get 1st char
	LDABX BW,ModNBRB,1
	STAX ZW,ModBMRB,0	; push it
	RSR


 FHdr "[']",ha_immediate ; compile a word address literal
   ; https://forth-standard.org/standard/core/BracketTick
BTB:	JSRD Tick
	JMPR Literal


 FHdr ';S',0 ; ( -- )  Stop interpretation of a screen.
   ; Not anymore!: ;S was also the run-time word compiled at the
   ; end of a colon-defintion which returns execution to the calling procedure.
SemiS:	LDXX SW,ModBRPB,0 ; drop our RSR addr, so we'll return to Interpret's caller
	RSR		; return


 FHdr 0,ha_immediate ; ( -- )  end-of-buffer
   ; This is the dictionary entry for a name of one char of ASCII null.
   ; It is the execution procedure to terminate interpretation of a line of text from the terminal
   ; or within a disc buffer, as disk buffers always have a null just beyond the end.
X_:	LDAD VBlk	; terminal?
	BZ SemiS

	CLA
	STAD VIn	; at the beginning of the Blk
	LDAD VBlk	; step to next Blk
	INR AW
	STAD VBlk
	STAX ZW,ModBMRB,0 ; push Blk
	JSRD Zero	;   as a double
	JSRD BScr	; divide by blocks/screen
	JSRD UMSlashMod	;  ( u_rem u_quot )
	INR ZW,2	; drop quot
	LDAX ZW,ModBRPB,0 ; at end_of_screen?
	BNZ @1828
	JSRD QExec	;   verify we're interpreting
	LDXX SW,ModBRPB,0 ;   pop my RSR addr, so we'll return to Interpret's caller
@1828:	RSR		; return


 FHdr 'Interpret',0 ; 
   ; The other text interpreter which sequentially executes or compiles text from the
   ; input stream (terminal or disc) depending on STATE .  If the word name cannot be
   ; found after a search of CONTEXT and then CURRENT it is converted to a number
   ; according to the current base.  That also failing, an error message echoing the
   ; name with a " ?" will be given.
   ; Text input will be taken according to the convention for WORD.  If a decimal point
   ; is found as part of a number, a double number value will be left.  The decimal
   ; point has no other purpose than to force this action.
   ; See NUMBER
Interpret:
@2272:	JSRD QStack		; check stack bounds

	LDABD VLineComment	; ignore remainder of line?
	BZ @49
	CLA
	STABD VLineComment
	LDBD VBlk		; reading from disk?
	BNZ @51
	JSRR X_			;  do end-of-line
@51:	LDAD VIn		; go fwd to next C/L boundary
	LDBL 64-1		; C/L 1-
	AAB
	LDAL $FFC0		; C/L Invert
	NAB
	STBD VIn
@49:
	JSRD DFind		; get next word from input & lookup
	LDAX ZW,ModBRPB,0	; found?
	BZ @2289
	LDAX ZW,ModBRPB,0	; get flags & name_length
	LDBD VState		; compiling?
	BZ @2284
	LDBBL ha_immediate	; immediate flag set?
	NABB
	BNZ @2284
;	JSRD CFA		; pfa to cfa
	JSRD CompileComma	; compile a jsr to it
	JMPR @2272		; next word

@2284:
;	JSRD CFA		; pfa to cfa
	JSRD Execute		; execute it
	JMPR @2272		; next word

@2289:	JSRD Here		; convert it to a number
	JSRD Number
	LDAD VDPL		; contained a '.'?
	INA
	BZ @2299
	JSRD TwoLiteral		; compile a double-cell literal
	JMPR @2272		; next word

@2299:	INR ZW,2		; convert double-cell number to single-cell (drop hi cell)
	JSRD Literal		; compile a single-cell literal
	JMPR @2272


 FHdr 'Vocabulary',0 ; ( "name" -- )
   ; A defining word used in the form:
   ;	VOCABULARY cccc
   ; to create a vocabulary definition cccc .  Subsequent use of cccc will make it the CONTEXT
   ; vocabulary which is searched first by INTERPRET .  The sequence "cccc DEFINITIONS" will
   ; also make ccc the CURRENT vocabulary into which new definitions are placed.
   ;
   ; In fig-FORTH, cccc will be so chained as to include all definitions of the
   ; vocabulary in which cccc is itself defined.  All vocabularys ultimately chain back to
   ; Forth .  By convention, vocabulary names are to be declared IMMEDIATE .
   ; See VOC-LINK
   ; See Forth for a sample vocabulary word.
Vocabulary:
	JSRD HeaderComma	; compile a word header
	JSRD Immediate		; make it immediate
	LDAL DoVoc		; compile "jsr DoVoc"
	JSRD JsrCommaA

	LDAI VCurrent		; compile dictionary anchor
	JSRD CommaA
	LDBD VDP		; link into vocabulary chain
	LDAD VVoc_Link
	STBD VVoc_Link
	JMPD CommaA


DoVoc: ; set Context to this vocabulary
	STXD VContext
	LDXX SW,ModBRPB,0	; pop pfa
	RSR			; return


 FHdr 'Forth',ha_immediate ; The primary vocabulary.
   ; Execution makes FORTH the CONTEXT vocabulary.
   ; Until additional user vocabularies are defined, new user definitions become part
   ; of FORTH .  FORTH is immediate, so it will execute during the creation of a
   ; colon-definition, to select this vocabularty at compile time.
Forth:	JSRD DoVoc	; use direct addressing, so PFA offset looks like other Vocab words
XFor:	.dbyt 0		; points to latest word in this vocabulary
	.dbyt 0		; vocab link, ends at zero


 FHdr 'Definitions',0 ; Set the CURRENT vocabulary to the CONTEXT vocabulary.
   ; Used in the form:
   ;	cccc DEFINITIONS
   ; In the example, executing vocabulary name cccc made it the CONTEXT vocabulary
   ; and executing DEFINITIONS made both specify vocabulary cccc .
   ; https://forth-standard.org/standard/search/DEFINITIONS
Definitions:
	LDAD VContext		; get context dictionary
	STAD VCurrent		; set as current dictionary
	RSR


 FHdr '(',ha_immediate ; 
   ; Used in the form:
   ;	( cccc)
   ; Ignore a comment that will be delimited by a right parenthesis on the same line.
   ; May occur during execution or in a colon-definition.
   ; A blank after the leading parenthesis is required.
   ; https://forth-standard.org/standard/core/p
OParen:	LDAL ')'	; push ')'
	STAX ZW,ModBMRB,0
	JMPD Word	; get the string delimited by ')', & return


 FHdr '\',ha_immediate ; ignore rest of input line
   ; https://forth-standard.org/standard/block/bs
   ; https://forth-standard.org/standard/core/bs
	CLR AW,1
	STABD VLineComment
	RSR


	.if 0
 FHdr 'Refill',0 ; ( -- flag )
   ; Attempt to fill the input buffer from the input source, returning a true flag if successful.
   ; When the input source is the user input device, attempt to receive input into the terminal input buffer.
   ; If successful, make the result the input buffer, set >IN to zero, and return true.
   ; Receipt of a line containing no characters is considered successful.
   ; If there is no input available from the current input source, return false.
   ;
   ; When the input source is a string from EVALUATE, return false and perform no other action.
   ; https://forth-standard.org/standard/block/REFILL
	JSRD Abort ;???
	.endif


 FHdr 'Quit',0 ; ( -- )
   ; Clear the return stack, stop compilation, and return control to the operators
   ; terminal.  No message is given.
   ; https://forth-standard.org/standard/core/QUIT
Quit:	CLA
	STABD VLineComment	; disable line ignore
	STAD VBlk		; input from console
	STAD VState		; interpret mode
@2388:				; begin
	JSRD EmptyRStack	;   empty return stack
	JSRD CR			;   newline
	JSRD Query		;   get string to TIB
	JSRD Interpret		;   interpret words in the string
	LDAD VState		;   compiling?
	BNZ @2399
	JSRD PDotQuote		;     type " OK"
	.byte 3,' OK'
@2399:
	JMPR @2388		;  again


 FHdr 'Abort"',ha_immediate ; Abort with inline message
   ; compile: ( "string" -- )
   ; run: ( f -- )
AbortQ:	JSRD QComp		; verify we're compiling
	LDAL @Run		; compile JSR
	JSRD JsrCommaA
	JMPD CountedStringComma

@Run: ; runtime
	CLA			; get inline string length
	LDABX XW,ModBRPB,0
	LDBX ZW,ModBRPB,0	; pop f
	BNZ @RunErr
	ADD XW,AW		; skip inline string
	RSR

@RunErr: STBX ZW,ModBMRB,0	; push string addr
	STAX ZW,ModBMRB,0	; push string length
	JSRD Type		; type it
	JMPR Abort		; abort


 FHdr 'Abort',0 ; 
   ; Clears the stacks and enter the execution state.  Return control to the
   ; operators terminal, printing a message appropriate to the installation.
Abort:	JSRD EmptyStack		; empty the param stack
	JSRD RAt		; type address that called us
	JSRD EX4
	JSRD Decimal		; set base to decimal
	JSRD DR0		; select disc drive 0
	JSRD CR			; newline
	JSRD PDotQuote		; type literal
	.byte 25,'fig-FORTH CPU6 subroutine'
	JSRD Forth		; make Forth vocabulary current
	JSRD Definitions	;   & definitions
	JMPD Quit		; restart the interpreter


 FHdr 'Cold',0 ;	Cold start the system.
   ; May be called from the terminal to remove application programs and restart.
Cold:
;	LDABL $40	; Add & link test 1
;	LDBBL $80
;	AABB
;	BNL @11
;	HLT
;@11:

;	LDABL $40	; Add & link test 2
;	LDBBL $fe
;	AABB
;	BL @12
;	HLT
;@12:

;	LDBBL $40	; Sub & link test 1
;	LDABL 2
;	SABB
;	BNL @13		;   no borrow
;	HLT
;@13:

;	LDBBL $40		; Sub & link test 2
;	LDABL $42
;	SABB
;	BL @14			;   borrow
;	HLT
;@14:

;	LDAL $c000
;	XAS
;	LDAL $8800		; to diag ROM CPU test
;	XAZ
;	JMPD $8849

	CLA			; disable RAM disk
	STAD RamDiskCount

	LDAD ORIG+$0C		; Initialize Forth vocabulary
	STAD XFor
	LDABL 2+VVoc_Link-VUser	; user variables to initialize
	JMPR L2433

Warm: ; warm start the system
	LDABL 2+VWarning-VUser	; user variaboles to initialize
L2433:
	LDXL ORIG+$0c		; init some user variables from cold start area
	LDBL VUser
	XFR YW,BW
@2437:	LDBBX XW,ModBRPB,0
	STBBX YW,ModBRPB,0
	DCAB
	BP @2437

	JSRD EmptyRStack	; empty return stack

	JSRD EmptyStack		; empty param stack
	JSRD Decimal
;	JSRD UMStarTest1
;	JSRD UMSlashModTest1
;	JSRD MSlashModTest1

;	LDAL 12345		; test decimal print
;	STAX ZW,ModBMRB,0
;	JSRD Dot

	JMPD Abort		; And off we go!


	.if 0
 FHdr 'Using',0 ; ( "filename" -- )  Open a block file
Using:	JSRD Bl
	JSRD Word
	HLT ; open the filename as a block file
	RSR
	.endif


 FHdr 'Use',0 ; ( -- addr )  variable:
Use:	LDAL VUse
	STAX ZW,ModBMRB,0
	RSR


 FHdr 'Prev',0 ; ( -- adr )  variable:
Prev:	LDAL VPrev
	STAX ZW,ModBMRB,0
	RSR


 FHdr 'First',0 ; ( -- adr )  constant: address of the first (lowest) block buffer.
First:	LDAL DArea
	STAX ZW,ModBMRB,0
	RSR


FHdr 'Limit',0 ; ( -- adr )  constant: address just above the highest memory available
		; for a disc buffer.
Limit:	LDAL DAreaEnd
	STAX ZW,ModBMRB,0
	RSR


 FHdr '+Buf',0 ; ( addr1 -- addr2 f )
; Advance the disc buffer address addr1 to the address of the next buffer addr2.
; Bool f is false when addr2 is the buffer presently pointed to by variable PREV.
PBuf:	LDAL 2+SectorSize+2	 ; hold block #, one sector, ??? two num
	LDBA ZW
	ADD AW,BW
	LDBD Limit+1
	SAB
	BL @2691
	LDAD First+1
@2691:	STAA ZW
	LDBD VPrev
	ORE AW,BW
	STAX ZW,ModBMRB,0
	RSR


 FHdr 'Update',0 ; ( -- )
   ; Marks the most recently referenced block (pointed to by PREV ) as altered.
   ; The block will subsequently be transferred automatically to disc should its
   ; buffer be required for storage of a different block.
   ; https://forth-standard.org/standard/block/UPDATE
Update:	LDBL $8000	; set the hi bit of the block # in the PREV block
	LDAD VPrev
	XAY
	LDAA YW
	ORI AW,BW
	STAA YW
	RSR


	.if 0
 FHdr 'Save-Buffers',0 ; ( -- )  Transfer the contents of each UPDATEd block buffer to mass storage. Mark all buffers as unmodified.
   ; https://forth-standard.org/standard/block/SAVE-BUFFERS
Save_Buffers:
	JSRD Abort ;???
	.endif


 FHdr 'Flush',0 ; ( -- )  Flush modified blocks back to disk
   ; https://forth-standard.org/standard/block/FLUSH
Flush:	LDAD First+1		; for each available block buffer
@2835:	STAX SW,ModBMRB,0
	LDAL $7FFF		;   alloc a buffer for block $7fff
	STAX ZW,ModBMRB,0	;     ( removing the existing contents )
	JSRD Buffer
	INR ZW,2		;   drop the addr
	LDAX SW,ModBRPB,0	;  next available block buffer
	LDBL SectorSize+4
	ADD AW,BW
	LDBD Limit+1
	SAB
	BNL @2835
	RSR			; return


 FHdr "Empty-Buffers",0 ; ( -- )  Mark all block-buffers as empty
   ; not necessarily affecting the contents.
   ; Updated blocks are not written to the disc.
   ; This is also an initialization procedure before first use of the disc.
   ; https://forth-standard.org/standard/block/EMPTY-BUFFERS
Empty_Buffers:
	LDAD First+1		; init Use & Prev
	STAD VUse
	STAD VPrev

	JSRD First	; zero all the disc buffer bytes, & return
	JSRD Limit
	JSRD Over
	JSRD Subtract
	JMPD Erase


	FHdr 'DR0',0 ; ( -- )  select disc drive 0
DR0:	CLA
DRA:	STAD VOffset	; Offset=0
	RSR		; return


	FHdr 'DR1',0 ; ( -- )  select disc drive 1
DR1:	LDAL Sectors	; Offset=sectors	(sectors per drive)
	JMPR DRA


 FHdr 'Buffer',0 ; ( n -- addr )  Obtain the next memory buffer, assigning it to block n.
   ; If the contents of the buffer is marked as updated, it is written to the disk.
   ; The block is not read from the disc.
   ; The address left is the first cell within the buffer for data storage.
   ; https://forth-standard.org/standard/block/BUFFER
Buffer:	LDAD VUse
	STAX ZW,ModBMRB,0
@2758:	JSRD PBuf
	LDAX ZW,ModBRPB,0
	BZ @2758

	LDBD VUse		;modified?
	LDAA BW
	BP @2776
	INR BW,2		;  write old buffer contents
	STBX ZW,ModBMRB,0
	LDBL $7fff
	NAB
	STBX ZW,ModBMRB,0
	JSRD Zero
	JSRD RSlashW
@2776:

	LDAX ZW,ModBRPB,0	; save this block buffer address
	STAD VUse
	XAY

	LDBX ZW,ModBRPB,0	; store block #
	STBA YW
	LDBL 2+SectorSize	; insert terminating nulls
	AAB
	CLA
	STAA BW
	XFR AW,YW
	STAD VPrev

	INA			; return data buffer addr
	INA
	STAX ZW,ModBMRB,0
	RSR


 FHdr 'Block',0 ; ( n -- addr )  Leave the memory address of the block buffer containing block n.
   ; If the block
   ; is not already in memory, it is transferred from disc to which ever buffer was
   ; least recently written.  If the block occupying that buffer has been marked as
   ; updated, it is rewritten to disc before block n is read into the buffer.
   ; See also BUFFER, R/W UPDATE FLUSH
   ; https://forth-standard.org/standard/block/BLOCK
Block:	LDAX ZW,ModBRPB,0	; calc physical block #
	LDBD VOffset
	AAB
	STAX SW,ModBMRB,0

	LDAD VPrev		; Start at VPrev
	STAX ZW,ModBRPB,0
	LDAA ZW			; if not block match
	LDAA AW
	LDBA SW
	ORE AW,BW
	SLA
	BZ @2830

@2805:				;   begin
	JSRD PBuf		;     step to next buffer
	LDAX ZW,ModBRPB,0	;     if it is VUse
	BNZ @2818
	INR ZW,2		;       drop
	JSRD RAt		;       allocate buffer
	JSRD Buffer
	JSRD Dup		;       read contents
	JSRD RAt
	JSRD One
	JSRD RSlashW
	LDBA ZW			;       point at header
	DCR BW,2
	STBA ZW
	LDAL 2+SectorSize	;       insert terminating nulls
	AAB
	CLA
	STAA BW
@2818:				;      then
	LDAA ZW			;    until block match
	LDAA AW
	LDBA SW
	ORE AW,BW
	SLA
	BNZ @2805
	LDAA ZW			;   set VPrev
	STAD VPrev

@2830:				;  then
	INR SW,2		; rdrop
	JMPD TwoPlus		; point at data


 FHdr '(Line)',0 ; ( n_line n_screen -- addr count )
   ; Convert the line number n_line and the screen n_screen to the disc buffer address
   ; containing the data.  A count of 64 indicates the full line text length.
PLine:	JSRD ToR		; save n_screen
	JSRD CSlashL		; get chars per line
	JSRD BBuf		; get bytes per disc buffer
	JSRD StarSlashMod	; convert n_line to disc block # & offset
	JSRD RFrom		; get n_screen
	JSRD BScr		; get disc blocks per screen
	JSRD Star		; convert screen to disc blocks
	JSRD Plus		; add screen blocks to line blocks
	JSRR Block		; read the disc block
	JSRD Plus		; add offset
	JMPD CSlashL		; get chars per line, & return


 FHdr '.Line',0 ; ( n_line n_screen -- )
DotLine:
	JSRD PLine
	JSRD DTrailing
	JMPD Type


 FHdr 'Message',0 ; ( n -- )
   ; Print on the selected output device the text of line n relative to screen 4
   ; of drive 0.  n may be positive or negative.  MESSAGE may be used to print
   ; incidental text such as report headers.  If WARNING is zero, the message will
   ; simply be printed as a number (disc unavailable).
Message:
	LDAA ZW		; n=0 gives no message
	BZ @2886
	LDBL @IndexCount ; built-in message?
	SAB
	BNL @Int
@Ext:	LDBD VWarning	; short messages?
	BZ @2888
	LDAL 4		; messages start in block 4
	STAX ZW,ModBMRB,0
	LDAD VOffset
	STAX ZW,ModBMRB,0
	JSRD BScr
	JSRD Slash
	JSRD Subtract
	JMPR DotLine	; type the line, & return

@2886:	INR ZW,2	; drop n
	RSR		; return

@2888:	JSRD PDotQuote	; type literal
	.byte 6,'Msg # '
	JMPD Dot	; type n, & return


@Int:	; internal message text?
	LDBL @Index	; get index
	AAB
	CLA
	LDABA BW
	BZ @Ext		; if we don't have one, try external
	LDBL @Msg
	AAB
	STBA ZW
	JSRD Count
	JMPD Type

@Index:	.byte 0,@Msg1-@Msg,@Msg2-@Msg,0
	.byte @Msg4-@Msg,0,@Msg6-@Msg,@Msg7-@Msg
	.byte @Msg8-@Msg,0,0,0
	.byte 0,0,0,0
	.byte 0,@Msg17-@Msg,@Msg18-@Msg,@Msg19-@Msg
	.byte @Msg20-@Msg,@Msg21-@Msg,@Msg22-@Msg
@IndexCount = *-@Index

@Msg:	.byte 0
@Msg1:	.byte 11,'Empty stack'
@Msg2:	.byte 15,'Dictionary full'
@Msg4:	.byte 12,"Isn't unique"
@Msg6:	.byte 10,'Disc range'
@Msg7:	.byte 14,"Stack overflow"
@Msg8:	.byte 12,"Disk I/O err"
@Msg17:	.byte 12,'Compile only'
@Msg18:	.byte 12,'Execute only'
@Msg19:	.byte 23,'Conditionals not paired'
@Msg20:	.byte 23,'Definition not finished'
@Msg21:	.byte 23,'In protected dictionary'
@Msg22:	.byte 21,'Use only when loading'


MessageA: ; entry with n in A
	STAX ZW,ModBMRB,0
	JMPD Message


	.if 0

 FHdr 'Source',0 ; ( -- c-addr u )
   ; c-addr is the address of, and u is the number of characters in, the input buffer.
   ; https://forth-standard.org/standard/core/SOURCE
	JSRD Abort ;???


 FHdr 'Source-Id',0 ; ( -- 0 | -1 )
   ; Identifies the input source as follows:
   ; SOURCE-ID	Input source
   ;   -1	String (via EVALUATE)
   ;    0	User input device
   ; https://forth-standard.org/standard/core/SOURCE-ID
	JSRD Abort ;???


 FHdr 'Restore-Input',0 ; ( xn ... x1 n -- flag )
   ; Attempt to restore the input source specification to the state described by x1 through xn.
   ; flag is true if the input source specification cannot be so restored.
   ;
   ; An ambiguous condition exists if the input source represented by the arguments is not the same as the current input source.
   ; https://forth-standard.org/standard/core/RESTORE-INPUT
	JSRD Abort ;???


 FHdr 'Save-Input',0 ; ( -- xn ... x1 n )
   ; x1 through xn describe the current state of the input source specification for later use by RESTORE-INPUT.
   ; https://forth-standard.org/standard/core/SAVE-INPUT
	JSRD Abort ;???


 FHdr 'Evaluate',0 ; ( i * x c-addr u -- j * x )
   ; https://forth-standard.org/standard/block/EVALUATE
   ; https://forth-standard.org/standard/core/EVALUATE
Evaluate:
	JSRD Abort ;???

	.endif


 FHdr 'Load',0 ; ( n -- )  Begin interpretation of screen n.
   ; Loading will terminate at the end of the screen or at ;S .
   ; See ;S -->
   ; https://forth-standard.org/standard/block/LOAD
Load:	LDAD VBlk	; save existing Blk & In
	STAX SW,ModBMRB,0
	LDAD VIn
	STAX SW,ModBMRB,0
	CLA
	STAD VIn	; In=0
	JSRD BScr	; Blk=n*(blocks_per_screen)
	JSRD Star
	LDAX ZW,ModBRPB,0
	STAD VBlk

	JSRD Interpret	; interpret the disc block

	LDAX SW,ModBRPB,0 ; restore Blk & In
	STAD VIn
	LDAX SW,ModBRPB,0
	STAD VBlk
	RSR		; return


 FHdr '-->',ha_immediate ; ( -- )  Continue interpretation with the next disc screen.
NextB:	JSRD QLoad	; verify that we're LOADing
	CLA
	STAD VIn	; offset in block =0
	JSRD BScr	; move Blk to start of next screen
	LDAD VBlk
	STAX ZW,ModBMRB,0
	JSRD Over
	JSRD Mod
	JSRD Subtract
	JSRD Blk
	JMPD PlusStore


	.if 0
 FHdr 'Thru',0 ; ( i * x u1 u2 -- j * x )
   ; LOAD the mass storage blocks numbered u1 through u2 in sequence.
   ; Other stack effects are due to the words LOADed.
   ; https://forth-standard.org/standard/block/THRU
Thru:	JSRD Abort ;???
	.endif


	.if 0
 FHdr 'Include',0 ; ( "filename" -- )  Interpret text from the file
	JSRD Abort ; ???do something
	RSR
	.endif


 FHdr 'R/W',0 ; ( addr blk f -- )  The fig-FORTH standard disc read-write linkage.
   ; addr specifies the source or destination block buffer,
   ; blk is the sequential number of the referenced block;
   ; and f is a flag for f=0 write and f=1 read.
   ; R/W determines the location on mass storage, performs the read-write and
   ; performs any error checking.
RSlashW:
	LDBD RamDiskCount	; is the RAM disk initialized?
	BNZ @RD

	; we have no disk yet!
@Abort:	JSRD Abort

@RD: ; Use RAM disk
	LDAX ZW,ModNBRB,2	; block # in range?
	SAB
	BL @Abort
	SLR AW,8		; cvt to bytes
	LDBD RamDiskStart
	AAB
	LDAA ZW			; get f
	BZ @RdWrite

@RdRead:			; move from RAM disk to buffer
	LDAX ZW,ModNBRB,4
	STBX ZW,ModNBRB,4
	STAX ZW,ModNBRB,2
@Rd2:	LDAL 256
	JMPD CMove

@RdWrite:			; move from buffer to RAM disk
	STBX ZW,ModNBRB,2
	JMPR @Rd2


 FHdr 'RamDisk',0 ; ( n -- )  alloc n blocks of RAM disk, & init
	LDBD VDP		; remember where RAM disk starts
	STBD RamDiskStart
	LDAA ZW
	STBX ZW,ModBMRB,0
	STAD RamDiskCount
	SLR AW,8
	STAA ZW
	STAX ZW,ModBMRB,0
	JSRD Allot
	JMPD Erase


 FHdr 'Forget',0 ; ( "name" -- )
   ; https://forth-standard.org/standard/tools/FORGET
   ; Executed in the form:
   ;	FORGET cccc
   ; Deletes definition named cccc from the dictionary with all entries
   ; physically following it.  In fig-FORTH, an error message will occur
   ; if the CURRENT and CONTEXT vocabularies are not currently the same.
Forget:	JSRD Tick		; get "name" text & look up in dictionary
	LDAA ZW			; check Fence (assumes startup image is below user dictionary space)
	LDBD VFence
	SAB
	BL @3
	LDBL Err_InProtectedDictionary
	JSRD ErrorY
@3:

@3220:	LDAA ZW			; while addr < latest vocabulary word
	LDBD VVoc_Link
	SAB
	BL @3225
	JSRD Forth
	JSRD Definitions
	LDAD VVoc_Link		;   unlink
	LDAA AW
	STAD VVoc_Link
	JMPR @3220
@3225:

	LDAX ZW,ModBRPB,0	; pop forgotten word ptr
	XAY
	DCR YW,3		; point at flags & length byte

	CLA
	LDABA YW		; fix VDP
	LDBBL ha_length
	NAB
;	cmp VWidth		;   name truncated?

	SUB BW,YW
	DCR BW,1		;  -1 for junk name length count
	STBD VDP

	LDAX YW,ModNBRB,1	; fix dictionary
	LDBD VVoc_Link
	STAX BW,ModNBRB,$fe

	RSR


	.if 0
 FHdr 'Marker',0 ; ( "<spaces>name" -- )
   ;   Skip leading space delimiters. Parse name delimited by a spac'e.
   ;   Create a definition for name with the execution semantics defined below.
   ; name Execution:
   ;   ( -- )
   ;   Restore all dictionary allocation and search order pointers to the state they had just prior to the definition of name.
   ;   Remove the definition of name and all subsequent definitions. Restoration of any structures still existing that could refer to deleted definitions or deallocated data space is not necessarily provided. No other contextual information such as numeric base is affected.
Marker:	JSRD Abort ;???
	.endif


	.if 0
 FHdr 'TraverseE-WordList',0 ; ( i * x xt wid -- j * x )
   ; Remove wid and xt from the stack. Execute xt once for every word in the wordlist wid, passing the name token nt of the word to xt,
   ; until the wordlist is exhausted or until xt returns false.
   ;
   ; The invoked xt has the stack effect ( k * x nt -- l * x flag ).
   ;
   ; If flag is true, TRAVERSE-WORDLIST will continue with the next name, otherwise it will return.
   ; TRAVERSE-WORDLIST does not put any items other than nt on the stack when calling xt,
   ; so that xt can access and modify the rest of the stack.
   ;
   ; TRAVERSE-WORDLIST may visit words in any order, with one exception: words with the same name are called in the order
   ; newest-to-oldest (possibly with other words in between).
   ;
   ; An ambiguous condition exists if words are added to or deleted from the wordlist wid during the execution of TRAVERSE-WORDLIST.
   ; https://forth-standard.org/standard/tools/TRAVERSE-WORDLIST
Traverse_WordList:
	JSRD Abort ;???
	.endif


 FHdr 'List',0 ; ( n -- )  Display the ASCII text of screen n on the selected output device.
   ; SCR contains the screen number during and after this process.
   ; https://forth-standard.org/standard/block/LIST
List:	JSRD Decimal	; Base=decimal
	JSRD CR		; newline
	LDAA ZW		; Scr=n
	STAD VScr
	JSRD PDotQuote	; type literal
	.byte 6,'SCR # '
	JSRD Dot	; type n
	CLA		; for line=0 to 16
@3620:	STAX SW,ModBMRB,0 ;   save line#
	JSRD CR		;   newline
	JSRD RAt	;   type current line# in 3 chars
	JSRD Three
	JSRD DotR
	JSRD Space	;   type a space
	JSRD RAt	;   type the line
	LDAD VScr
	STAX ZW,ModBMRB,0
	JSRD DotLine
	LDAX SW,ModBRPB,0 ;  next line
	INA
	LDBBL 16
	SABB
	BNZ @3620
	JMPD CR		; newline, & return


 FHdr 'Index',0 ; ( from to -- )  Print the first line of each screen over the range from, to.
   ; This is used to view the comment lines of an area on disc screens.
Index:	JSRD CR		; newline
	LDAA ZW		; to++
	INA
	STAA ZW
@3647:			; for screen#=from to to
	JSRD CR		;   newline
	JSRD Over	;   type screen# in 3 chars
	JSRD Three
	JSRD DotR
	JSRD Space	;   type space
	JSRD Zero	;   type 1st line of screen
	JSRD Over
	JSRD DotLine
	JSRD QTerminalA	;   console key available?
	BNZ @break
	LDAX ZW,ModNBRB,2 ;  next
	INA
	STAX ZW,ModNBRB,2
	LDBA ZW
	SAB
	BL @3647
@break:	INR ZW,4	; drop parameters
	LDABL $0C	; form feed for printer, & return
	JMPD EmitA


 FHdr 'Triad',0 ; ( scr -- )
   ; Display on the selected output device the three screens which include that numbered
   ; scr, beginning with a screen evenly divisable by 3.  Output is suitable for source text
   ; records, and includes a reference line at the bottom taken from line 15 of screen 4.
Triad:	JSRD Three	; floor scr to multiple of 3
	JSRD Slash
	JSRD Three
	JSRD Star
	JSRD Three	; end=scr+3
	JSRD Over
	JSRD Plus
	JSRD Swap
	JSRD PDo		; (Do)
@3681:
	JSRD CR		;   newline
	JSRD I		;   type screen I
	JSRD List
	JSRD PLoop	;  (Loop)
	BM @3681
	JSRD CR		; newline
	LDAL Err_TriadFooter ; type message $F 
	JSRD MessageA
	JSRD CR		; newline
	LDABL $0C	; form feed for printer, & return
	JMPD EmitA


	.if 0

 FHdr 'Parse-Name',0 ; ( "<spaces>name<space>" -- c-addr u )
   ; Skip leading space delimiters. Parse name delimited by a space.
   ;
   ; c-addr is the address of the selected string within the input buffer and u is its length in characters.
   ; If the parse area is empty or contains only white space, the resulting string has length zero.
   ; https://forth-standard.org/standard/core/PARSE-NAME


 FHdr 'Parse',0 ; ( char "ccc<char>" -- c-addr u )  Parse ccc delimited by the delimiter char.
   ;
   ; c-addr is the address (within the input buffer) and u is the length of the parsed string.
   ; If the parse area was empty, the resulting string has a zero length.
   ; https://forth-standard.org/standard/core/PARSE

	.endif


 FHdr 'VList',0 ; ( -- )  FIG alias
	JMPR Words


 FHdr 'Words',0 ; ( -- )  List the names of the definitions in the context vocabulary.
   ; https://forth-standard.org/standard/tools/WORDS
Words:	LDAI VContext	; start at head of dictionary in Context vocabulary 
	STAX ZW,ModBMRB,0
	JMPR @3710

@3706:	LDAD VOut	; out of screen width?
	LDBD CSlashL+1
	SAB
	BNL @3716
@3710:	JSRD CR		;   newline
	CLA
	STAD VOut	;   Out=0
@3716:
	JSRD Dup	; type name
	JSRD IdDot
	JSRD Space	; type space
	JSRD QTerminalA	; terminal input char?
	BNZ @9
	LDAA ZW		; goto next dictionary entry
	LDAX AW,ModNBRB,$fe
	STAA ZW
	BNZ @3706	; end of dictionary?
@9:	INR ZW,2	; drop addr
	RSR		; return


	FHdr 'Bye',0 ; ( - )  Exit to the system monitor, leaving a re-entry to Forth, if possible.
   ; https://forth-standard.org/standard/tools/BYE
Bye:
	HLT		; stop the simulator
	RSR		; return


;----------------------------------------------------------------------
; Additional words


 FHdr '.S',0 ; ( ... -- ... ) non-destructive param stack print
   ; https://forth-standard.org/standard/tools/DotS
DotS:	LDAD VS0		;start at top-of-stack
	JMPR @8

@1:	LDBX AW,ModBMRB,0	; get next cell value
	STAX SW,ModBMRB,0	; save ptr
	STBX ZW,ModBMRB,0	; print value
	JSRD Dot
	LDAX SW,ModBRPB,0	; restore ptr
@8:	XFR BW,ZW		; done?
	SAB
	BNZ @1

	RSR


; FHdr 'EX1',0 ; ( n -- )  type 1 hex digit
EX1:	LDAX ZW,ModBRPB,0	; pop n
EX1A:	LDBL $f			; get lo 4 bits
	ANDC AW,BW
	LDBBL 10		; convert to ASCII char
	SABB
	BNL @3
	LDBBL 7
	ADDB AL,BL
@3:	LDBBL '0'
	ADDB AL,BL
	JMPD EmitA		; type, & return


 FHdr 'EX2',0 ; ( n -- )  type 2 hex digits
EX2:	LDAX ZW,ModBRPB,0
EX2A:	STAX ZW,ModBMRB,0
	SRR AW,4
	JSRR EX1A
	JMPR EX1


 FHdr 'EX4',0 ; ( n -- ) type 4 hex digits
EX4:	LDABA ZW		; type hi byte
	JSRR EX2A
	JMPR EX2		; type lo byte, & return

EX4A:	STAX ZW,ModBMRB,0
	JMPR EX4


 FHdr 'Dump',0 ; ( adr len -- )  Dump memory range
   ; https://forth-standard.org/standard/tools/DUMP
Dump:
@11:				; begin
	JSRD CR			;   newline
	JSRD Over		;   type addr
	JSRR EX4
	LDBBL 16		;   for each byte in line
@21:	STBBX SW,ModBMRB,0
	JSRD Space
	LDBX ZW,ModNBRB,2	;     get byte
	LDABX BW,ModBRPB,0
	STBX ZW,ModNBRB,2
	JSRR EX2A		;     type byte
	LDBBX SW,ModBRPB,0
	LDAA ZW			;     decrement len
	DCA
	STAA ZW
	BZ @end
	DCRB BL			;    next byte in line
	BNZ @21
	JMPR @11		;  next line

@end:	INR ZW,4		; drop len & adr
	JMPD Space


 FHdr 'SeeLatest',0 ; ( -- )  dump latest word's code
SeeLatest:
	LDBI VCurrent		; start of last word
	STBX ZW,ModBMRB,0
	LDAD VDP		; length
	SAB
	STBX ZW,ModBMRB,0
	JMPR Dump		; dump, & return


; FHdr 'CC@',0 ; ( -- ud )  Get emulator cycle counter
;CCAt:	cop?? $f5	; get simulator cycle count in BA
;	STAX ZW,ModBMRB,0 ; push it
;	STBX ZW,ModBMRB,0
;	RSR



	.if 0
 FHdr 'Modify',0 ; ( adr -- )  \ Centurion TOS-like memory modify
	JSRD Abort
@l:
	JSRD Space
	LDABX ZW,ModABRB,0	; type existing value
	JSRD EX2A

	CLR ZW,0    ; get the byte
	JSRR @HKey
	BL @9
	JSRR @HKey
	BL @9

	






@HKey:	PUSH YW,2
	JSRD KeyA
	POP YW,2
	LDBBL 'A'		; alpha?
	SABB
	BNL @HKNum
	LDABL $5f		; uppercase
	NABB
	LDABL 10
	ADDB AL,BL
	LDBBL 16
	SABB
	BNL @HKOK
@HKErr:	SL
	RSR

@HKOK:	SHL YW,4
	ORIB YL,BL
	RL
	RSR

@HkNum:	LDBBL '0'
	SABB
	BNL @HKErr
	XFRB AL,BL
	LDABL 10
	SABB
	BNL @HKOK
	JMPR @HKErr

	.endif

;-----------------------------------------------------------------------------
; CCDP interface
; https://github.com/tergav17/CCDP

; status
;	0: Successful, 0 bytes returned
;	1: Successful, 16 bytes returned
;	2: Successful, 256 bytes returned
;	254: Execution Failure, 0 bytes returned
;	255: Communication Failure, 0 bytes returned

combuf		= $1C0  ; command line text

 FHdr 'Sys_Done',0 ; ( -- )  Returns to the CCDP command prompt
	JMPD $100	; return to CCDP (also just RSR)

 FHdr 'Tty_PutC',0 ; ( c -- )  Puts a character on the terminal
Tty_PutC:
	LDBX ZW,ModBRPB,0	; pop c
Tty_PutC_A:
	JMPD $103

 FHdr 'Tty_PutB',0 ; ( n -- )  Puts a byte in hex on the terminal
Tty_PutB:
	LDBX ZW,ModBRPB,0	; pop n
	JMPD $106

 FHdr 'Tty_PutW',0 ; ( n -- )  Puts a word in hex on the terminal
Tty_PutW:
	LDBX ZW,ModBRPB,0	; pop n
	JMPD $109

 FHdr 'Tty_PutS',0 ; ( adr -- )  Puts a string on the terminal (zero terminated)
Tty_PutS:
	LDBX ZW,ModBRPB,0	; pop adr
	JMPD $10C	; type .asciz string pointed to by BW

 FHdr 'Tty_GetC',0 ; ( -- c )  Gets a character from the terminal
Tty_GetC_A = $10f
Tty_GetC:
	JSRD Tty_GetC_A
TtPs1:	CLRB AH
	STAX ZW,ModBMRB,0	; push c
	RSR

 FHdr 'Tty_GetS',0 ; ( adr len -- )  Gets a line of characters from the terminal
Tty_GetS:
	LDAX ZW,ModBRPB,0	; pop len
	DCA
	LDBX ZW,ModBRPB,0	; pop adr
	JMPD $112

 FHdr 'Tty_Next',0 ; ( -- f )  Is there is a character to read?
Tty_Next_A = $12d
Tty_Next:
	JSRD Tty_Next_A
	JMPR TtPs1		; push f

 FHdr 'Fs_Open',0 ; ( fn_addr -- status )  Opens up a file for use, any currently opened file is closed
Fs_Open:
	LDBA ZW			; get fn_addr
	JSRD $115
	JMPR FsSt1		; store status

 FHdr 'Fs_Close',0 ; ( -- status )
Fs_Close:
	JSRD $118
	JMPR TtPs1		; push status

 FHdr 'Fs_Make',0 ; ( fn_addr -- status )  Makes a new file, but does not open it
Fs_Make:
	LDBA ZW			; get fn_addr
	JSRD $11B
	JMPR FsSt1		; store status

 FHdr 'Fs_Delete',0 ; ( fn_addr -- status )  Deletes an existing file
Fs_Delete:
	LDBA ZW			; get fn_addr
	JSRD $11E
	JMPR FsSt1		; store status

 FHdr 'Fs_List',0 ; ( n_entry buf_addr -- status )  Lists a filename and size from the directory
Fs_List:
	LDBX ZW,ModBRPB,0	; pop buf_adddr
	LDAA ZW			; get n_entry
	JSRD $121
	JMPR FsSt1		; store status

 FHdr 'Fs_Read',0 ; ( buf_addr block -- status )  Reads a block from a file
Fs_Read:
	LDAX ZW,ModBRPB,0	; pop block
	LDBA ZW			; get buf_addr
	JSRD $124
FsSt1:	CLRB AH			; store status
	STAA ZW
	RSR

 FHdr 'Fs_Write',0 ; ( buf_addr block -- status )  Writes a block to a file
Fs_Write:
	LDAX ZW,ModBRPB,0	; pop block
	LDBA ZW			; get buf_addr
	JSRD $127
	JMPR FsSt1

 FHdr 'Gen_HToL',0 ; ( ascii -- u )  Converts a hex number in ASCII into a value
Gen_HToL:
	LDBA ZW		; get ascii
	JSRD $12A
	JMPR FsSt1	; store u

;-----------------------------------------------------------------------------
; Assembler & disassembler


 FHdr 'Sym',0 ; ( adr -- )  Type symbolic version of any adr
Sym:	LDAX ZW,ModBRPB,0
SymA:	STAX SW,ModBMRB,0
	DCR SW,@adr		; alloc work area
@adr	 = 12 ; adr to convert
@voc	 = 10 ;	adr of vocabulary
@cur	 =  8 ; adr of current word (nfa, cfa)
@off	 =  6 ; offset this time
@bestadr =  4 ; adr of best word (nfa, cfa)
@bestoff =  2 ; offset from best word
@type	 =  0 ; type of word

	LDAL .loword(-1)
	STAX SW,ModNBRB,@bestoff

	LDAD VVoc_Link		;for each vocabulary
@71:	STAX SW,ModNBRB,@voc

	LDAX AW,ModNBRB,$fe	;  for each word in the vocabulary
@01:	STAX SW,ModNBRB,@cur
	BZ @09
	XAY

	LDBX SW,ModNBRB,@adr	;    check current word
	XFR AW,YW
	SUB AW,BW
	LDBX SW,ModNBRB,@bestoff
	SAB
	BL @04
	STAX SW,ModNBRB,@bestoff
	XFR BW,YW
	STBX SW,ModNBRB,@bestadr	
	CLA
	STAX SW,ModNBRB,@type
@04:

;	LDABA YW		;  a special kind of word?
;	LDBBL $79		;    (jsrd)
;	SABB
;	BZ @21
;	LDBBL $90		;    (ldal)
;	SABB
;	BNZ @06

;	LDAX YW,ModNBRB,3	;  a literal?
;	HLT ;LDBL $??		;    STAX ZW,ModBMRB,0
;	BNZ @06
;	LDABX YW,ModNBRB,5
;	LDBBL $09		;    RSR
;	SABB
;	BNZ @06
; HLT ;??	lda @adr		;    check literal value
;	sec
;	sbc a:1,y
;	sec
;	bra @27

;@21:	rep #pm			;  a variable?
;	lda a:1,y
;	cmp #PCreate
;	bne @06
;	lda @adr
;	sec
;	sbc @cur
;	dec a
;	dec a
;	dec a

;@27:	cmp @bestoff
;	bcs @06
;	sta @bestoff
;	sty @bestadr	
;	lda #$8000
;	sta @type

@06:	LDAX YW,ModNBRB,$fe	;  next word
	BNZ @01
	LDBX SW,ModNBRB,@voc	; next vocabulary
	LDAA BW
	BNZ @71
@09:
;-------------------
	LDAX SW,ModNBRB,@bestoff
	XFRB AH,AH
	BNZ @69

	JSRD PDotQuote
	.byte 3," { "

;	bit @type
;	bpl @8
;	JSRD DotQuoteR
;	.byte 2,"' "
;@8:
	LDAX SW,ModNBRB,@bestadr ; type name
	STAX ZW,ModBMRB,0
	JSRD IdDot

	LDAX SW,ModNBRB,@bestoff
	BZ @7
	LDABL '+'
	JSRD EmitA
	LDAX SW,ModNBRB,@bestoff
	JSRD EX4A
@7:
	JSRD PDotQuote
	.byte 1,"}"
@69:
	
	INR SW,@adr+2		; rdrop work area
	RSR


	.if 0

 FHdr "See",0 ; ( â€œ(spaces)nameâ€ -- )	; https://forth-standard.org/standard/tools/SEE
   ; Display a disassembly of the named wordâ€™s definition.
See:	JSRD Tick
	JSRR DisAsm
	INR ZW,2
	RSR


 FHdr "SeeLatest",0 ; ( -- ) ; disassemble latest word
SeeLatest:
	LDAI VCurrrent
	STAX ZW,ModBMRB,0
@1:	JSRD Disasm1
	LDAA ZW
	LDBD MPtr
	SAB
	BNL @1
	INR ZW,2
	JSRD CR
	JMPD CR


 FHdr "DisAsm",0 ; ( adr -- adr )	Disasemble a run of code
DisAsm:	LDAL 100
@2:	STAX SW,ModBMRB,0	; Y=adr
	LDAA ZW
	XAY
	LDABA AW		; get opcode
	LDBBL $71		;  JMPD
	SABB
	BZ @jmp
	LDBBL $73		;  JMPR
	SAB
	BZ @4
	LDBBL $09		;  RSR
	SABB
	BZ @4
;	LDBBL $79		;  JSRD
;	SABB
;	BNZ @5
;	LDAX YW,ModNBRB,1
;	LDBL FConsR
;	SAB
;	BZ @4
;	jsr PushAddrQ
;	bne @5
@4:	LDBBL 1
	STBA SW
@5:
	JSRD ADsm
;	JSRD dsn
	LDAX SW,ModBRPB,0
	DCA
	BNZ @2
	JMPD CR

@jmp:	LDAX YW,ModNBRB,$fe
	LDBL $fff0
	NAB
	LDABL $1003
	SAB
	BNZ @4
	JMPR @5	

;---------------------------------------------------------------------------

 FHdr "Disasm1",0 ; ( addr-1 -- addr-2 )  Disassemble 1 CPU6 instruction
   ; Using self contained tables
Disasm1:
	JSRD CR			; new line
	JSRD PDotQuote		; tab over hex part
	.byte 2,9,9
	LDBA ZW			; save starting addr
	STBX SW,ModBMRB,0

	JSRD @Fetch1		; fetch opcode
	SLA			; get @Code table entry
	LDBL @Code
	AAB
	LDBA BW
	STBX ZW,ModBMRB,0

	CLA			;type opcode name
	XFR AL,BH
	LDBL @Mnemonics
	AAB
	JMPR @18
@11:	STBX SW,ModBMRB,0
	JSRD EmitA
	LDBX SW,ModBMRB,0
@18:	LDABX BW,ModBRPB,0
	BNZ @11

	JSRD Space

	LDAX ZW,ModNBRB,1	; get format entry from @Code entry
	CLRB AH
	LDBL @Formats
	AAB
@FmtN2:	CLA			; get next format char
	LDABX BW,ModBRPB,0
	BZ @Fmt99
	STBX ZW,ModBMRB,0
	LDBBL $20		; a function?
	SABB
	BNL @FEmit

	LDBL @Formats		; call format routine
	AAB
	JSRX BW,ModBRB,0
@FmtN8:	LDBX ZW,ModBRPB,0	; get fmt ptr
	JMPR @FmtN2

@FEmit:	JSRD EmitA
	JMPR @FmtN8

@Fmt99:				; end of format string


 HLT ;	??pla		;discard opcode
	JSRD PDotQuote	;to begin of line
	.byte 1,$0d
	LDAA ZW		;type addr
	JSRD EX4A
	JSRD Space
 HLT ;???	pla
	ldy #5
@22:	phy
	pha
	tay
	lda a:0,y	;type bytes
	jsr EX2A
	pla
	ply
	dey
	beq @28
	ina
	cmp 0,x
	bcc @22
@28:	rts ; jmp CR


@Fetch1: ; fetch next byte
	LDBA SW
	CLA
	LDABX BW,ModBRPB,0
	STBA SW
	RSB

@Fetch2: ; fetch next word
	LDBA SW
	LDAX BW,ModBRPB,0
	STBA SW
	RSB


@Formats:
	.dbyt 0,@Fmt1,@Fmt2,@Fmt3
	.dbyt @Fmt4,@Fmt5,@Fmt6,@Fmt7
	.dbyt @Fmt8,@Fmt9,@Fmt10,@Fmt11
	.dbyt @Fmt12,@Fmt13,@Fmt14

@Fmt1: ; 1 byte literal
	JSRD @Fetch1		; fetch a byte
	JSRD EX2A
	JMPD @FmtNext

@Fmt2: ; 2 byte literal
	JSRD @Fetch2		; fetch a word
	JSRD EX4A
	JMPD @FmtNext

@Fmt3: ; 1byte relative
	JSRD @Fetch1		; fetch a signed byte
	XFRB AH,AL
	SRR AW,8
	AAB			; add to location
	JSRD EX4A
	JMPD @FmtNext
 
@Fmt4: ; byte register
	JSRD @Fetch1		; fetch a byte
	STABX ZW,ModBMRB,0	; save a copy
	JSRR @RegB		; do dest reg
	LDABL ','
	JSRD EmitA
	LDAX ZW,ModBRPB,0	; do src reg
	SLL AW,4
	JSRD @RegB
	JMPD @FmtNext

@RegR:	STABX SW,ModBMRB,0	; save
	SRA			; do register letter
	LDAL 7
	NAB
	LDAL @RegRA
	AAB
	LDAA BW
	JSRD EmitA
	LDABX SW,ModBMRB,0	; do register part
	RSR

@RegRA:	.byte 'ABXYZSCP'

@RegB:	JSRR @RegR
	SRA
	LDABL 'H'
	BNL @RegB3
	LDABL 'L'
@RegB3:	JMPD EmitA

@Fmt5: ; word register & constant+1
	HLT ;???

@Fmt6: ; word register & constant
	HLT ;???

@Fmt7: ; dest byte registers
	HLT ;???

@Fmt8: ; src byte register
	HLT ;???

@Fmt9: ; dest word register
	HLT ;???

@Fmt10: ; src word register
	HLT ;???

@Fmt11: ; word indexed
	HLT ;???

@Fmt12: ; byte indexed
	HLT ;???

@Fmt13: ; register in opcode
	LDBA SW			; get opcode again
	CLA
	LDABX BW,ModBMRB,0
	SLA
	JSRD @RegR
 HLT ;???



; https://github.com/Nakazoto/CenturionComputer/wiki/Instructions


; Modifier	Note
;  0 ; (r)	Index
;  1 ; (r+)	Index; Index returned, incremented by ^
;  2 ; (-r)	Decrement and Index
;  4 ; @(r)	Index indirect
;  5 ; @(r+)	Index indirect; Index returned, incremented by ^
;  6 ; @(-r)	Decrement and index indirect
;  8 ; n(r)	Index with displacement
;  9 ; n(r+)	Index with displacement; Index returned, incremented by ^
; $A ; n(-r)	Decrement and index with displacement
; $C ; @n(r)	Index with displacement indirect
; $D ; @n(r+)	Index with displacement indirect, Index returned, incremented by ^
; $E ; @n(-r)	Decrement and index with displacement indirect

@Inh:	.byte 0 ; inherent
@Rel:	.byte " ",3 ; 8bit relative
@RelInd: .byte " (",3,")",0 ; 8bit relative indirect
@BReg:	.byte " ",4,0 ; byte register
@WReg1:	.byte " ",5,0 ; word register & constant+1
@WReg:	.byte " ",6,0 ; word register & constant
@DRB:	.byte " ",7,",",8,0 ; src & dest byte registers
@DRW:	.byte " ",9,",",10,0 ; src & dest word registers (& extensions)
@LitW:	.byte " #",2,0 ; literal word
@LitB:	.byte " #",1,0 ; literal byte
@Direct: .byte " ",2,0 ; direct
@Indirect: .byte " (",2,")",0 ; indirect
@WX:	.byte " ",11,0 ; word indexed
@BX:	.byte " ",12,0 ; byte indexed
@A:	.byte " ",13,0 ; register in opcode


@Mnemonics:
@mIll:	.byte "??",0
@mHlt:	.byte "HLT",0
@mNop:	.byte "NOP",0
@mSF:	.byte "SF",0
@mRF:	.byte "RF",0
@mEI:	.byte "EI",0
@mDI:	.byte "DI",0
@mSL:	.byte "SL",0
@mRL:	.byte "RL",0
@mCL:	.byte "CL",0
@mRSR:	.byte "RSR",0
@mRI:	.byte "RI",0
@mRIM:	.byte "RIM",0
@mELO:	.byte "ELO",0
@mPCX:	.byte "PCX",0
@mDLY:	.byte "DLY",0
@mRSys:	.byte "RSYS",0

@mBL:	.byte "BL",0
@mBNL:	.byte "BNL",0
@mBF:	.byte "BF",0
@mBNF:	.byte "BNF",0
@mBZ:	.byte "BZ",0
@mBNZ:	.byte "BNZ",0
@mBM:	.byte "BM",0
@mBF:	.byte "BF",0
@mBGZ:	.byte "BGZ",0
@mBLE:	.byte "BLE",0
@mBS1:	.byte "BS1",0
@mBS2:	.byte "BS2",0
@mBS3:	.byte "BS3",0
@mBS4:	.byte "BS4",0
@mBTM:	.byte "BTM",0
@mBEP:	.byte "BEP",0

@mINRB:	.byte "INRB",0
@mDCRB:	.byte "DCRB",0
@mCLRB:	.byte "CLRB",0
@mIVRB:	.byte "IVRB",0
@mSRRB:	.byte "SRRB",0
@mSLRB:	.byte "SLRB",0
@mRRRB:	.byte "RRRB",0
@mRLRB:	.byte "RLRB",0
@mINAB:	.byte "INAB",0
@mDCAB:	.byte "DCAB",0
@mCLAB:	.byte "CLAB",0
@mIVAB:	.byte "IVAB",0
@mSRAB:	.byte "SRAB",0
@mSLAB:	.byte "SLAB",0

@mINR:	.byte "INR",0
@mDCR:	.byte "DCR",0
@mCLR:	.byte "CLR",0
@mIVR:	.byte "IVR",0
@mSRR:	.byte "SRR",0
@mSLR:	.byte "SLR",0
@mRRR:	.byte "RRR",0
@mRLR:	.byte "RLR",0
@mINA:	.byte "INA",0
@mDCA:	.byte "DCA",0
@mCLA:	.byte "CLA",0
@mIVA:	.byte "IVA",0
@mSRA:	.byte "SRA",0
@mSLA:	.byte "SLA",0
@mINX:	.byte "INX",0
@mDCX:	.byte "DCX",0

@mADDB:	.byte "ADDB",0
@mSUBB:	.byte "SUBB",0
@mANDB:	.byte "ANDB",0
@mORIB:	.byte "ORIB",0
@mOREB:	.byte "OREB",0
@mXFRB:	.byte "XFRB",0
@mAABB:	.byte "AABB",0
@mSABB:	.byte "SABB",0
@mNABB:	.byte "NABB",0
@mXAXB:	.byte "XAXB",0
@mXAYB:	.byte "XAYB",0
@mXABB:	.byte "XABB",0
@mXAZB:	.byte "XAZB",0
@mXASB:	.byte "XASB",0

@mADD:	.byte "ADD",0
@mSUB:	.byte "SUB",0
@mAND:	.byte "AND",0
@mORI:	.byte "ORI",0
@mORE:	.byte "ORE",0
@mXFR:	.byte "XFR",0
@mAAB:	.byte "AAB",0
@mSAB:	.byte "SAB",0
@mNAB:	.byte "NAB",0
@mXAX:	.byte "XAX",0
@mXAY:	.byte "XAY",0
@mXAB:	.byte "XAB".0
@mXAZ:	.byte "XAZ",0
@mXAS:	.byte "XAS",0

@mLDX:	.byte "LDX",0
@mSTX:	.byte "STX",0
@mJMP:	.byte "JMP",0
@mSYSCALL: .byte "SYSCALL",0
@mJSR:	.byte "JSR",0

@mLDAB:	.byte "LDAB",0
@mLDA:	.byte "LDA",0

@mSTAB:	.byte "STAB",0
@mSTA:	.byte "STA",0

@mLDBB:	.byte "LDBB",0
@mLDB:	.byte "LDB",0

@mSTBB:	.byte "STBB",0
@mSTB:	.byte "STB",0

@mPUSH:	.byte "PUSH",0
@mPOP:	.byte "POP",0

@mMUL:	.byte "MUL",0
@mDIV:	.byte "DIV",0


  .macro CodeE Mnem,Fmt
	.byte Mnem-@Mnem,Fmt
	.endmacro

@Code: ; indexed by 1st opcode byte
  CodeE @mHlt,@Inh	;00
  CodeE @mNop,@Inh	;01
  CodeE @mSF,@Inh	;02
  CodeE @mRF,@Inh	;03
  CodeE @mEI,@Inh	;04
  CodeE @mDI,@Inh	;05
  CodeE @mSL,@Imh	;06
  CodeE @mRL,@Inh	;07
  CodeE @mCL,@Inh	;08
  CodeE @mRSR,@Inh	;09
  CodeE @mRI,@Inh	;0a
  CodeE @mRIM,@Inh	;0b
  CodeE @mELO,@Inh	;0c
  CodeE @mPCX,@Inh	;0d
  CodeE @mDLY,@Inh	;0e
  CodeE @mRSys,@Inh	;0f
  CodeE @mBL,@Rel	;10
  CodeE @mBNL,@Rel	;11
  CodeE @mBF,@Rel	;12
  CodeE @mBNF,@Rel	;13
  CodeE @mBZ,@Rel	;14
  CodeE @mBNZ,@Rel	;15 BNZ adr ; Branch if V (Z) flag clear
  CodeE @mBM,@Rel	;16 BM adr ; Branch if Minus flag set
  CodeE @mBF,@Rel	;17 BP adr ; Branch on Positive (Minus flag clear)
  CodeE @mBGZ,@Rel	;18 BGZ adr ; Branch if Greater Than 0 (!V && !Minus)
  CodeE @mBLE,@Rel	;19 BLE adr ; Branch if Less Than or Equal to 0 (V | Minus)
  CodeE @mBS1,@Rel	;1a BS1 adr ; Branch if Sense Switch 1 Set
  CodeE @mBS2,@Rel	;1b BS2 adr ; Branch if Sense Switch 2 Set
  CodeE @mBS3,@Rel	;1c BS3 adr ; Branch if Sense Switch 3 Set
  CodeE @mBS4,@Rel	;1d BS4 adr ; Branch if Sense Switch 4 Set
  CodeE @mBTM,@Rel	;1e BTM Rel ; Branch on TTY Mark (Changed for CPU6?)
  CodeE @mBEP,@Rel	;1f BEP Rel ; Branch on Even Parity (Changed for CPU6?)
  CodeE @mINRB,@BReg	;20 increment register upper byte or lower byte
  CodeE @mDCRB,@BReg	;21 decrement register upper byte or lower byte
  CodeE @mCLRB,@BReg	;22 clear register upper byte or lower byte
  CodeE @mIVRB,@BReg	;23 invert register byte
  CodeE @mSRRB,@BReg	;24 shift register byte right (sign extend)
  CodeE @mSLRB,@BReg	;25 shift register byte left (0 shifted in)
  CodeE @mRRRB,@BReg	;26 rotate register byte right (thru link flag)
  CodeE @mRLRB,@BReg	;27
  CodeE @mINAB,@Inh	;28 Increment AL register
  CodeE @mDCAB,@Inh	;29 Decrement AL register
  CodeE @mCLAB,@Inh	;2a Clear AL register
  CodeE @mIVAB,@Inh	;2b Invert AL register
  CodeE @mSRAB,@Inh	;2c Shift AL register right (sign extend)
  CodeE @mSLAB,@Inh	;2d Shift AL register left (0 shifted in)
  CodeE @mIll,@Inh	;2e Memory mapping
  CodeE @mIll,@Inh	;2f DMA
  CodeE @mINR,@WReg1	;30 increment register word
  CodeE @mDCR,@WReg1	;31 decrement register word
  CodeE @mCLR,@WReg	;32 clear register word
  CodeE @mIVR,@WReg	;33 invert register word
  CodeE @mSRR,@WReg1	;34 shift register right (sign extend)
  CodeE @mSLR,@WReg1	;35 shift register left (0 shifted in)
  CodeE @mRRR,@WReg1	;36 rotate register right (thru link flag)
  CodeE @mRLR,@WReg1	;37 rotate register left (thru link flag)
  CodeE @mINA,@Inh	;38 Increment AW register
  CodeE @mDCA,@Inh	;39 Decrement AW register
  CodeE @mCLA,@Inh	;3a Clear AW register
  CodeE @mIVA,@Inh	;3b Invert AW register
  CodeE @mSRA,@Inh	;3c Shift AW register right (sign extend)
  CodeE @mSLA,@Inh	;3d Shift AW register left (0 shifted in)
  CodeE @mINX,@Inh	;3e Increment XW register
  CoddE @mDCX,@Inh	;3f Decrement XW register
  CodeE @mADDB,@DRB	;40 DestReg,SrcReg ; Add byte Src to Dest
  CodeE @mSUBB,@DRB	;41 DestReg,SrcReg ; Subtract byte Src to Dest
  CodeE @mANDB,@DRB	;42 DestReg,SrcReg ; AND byte Src to Dest
  CodeE @mORIB,@DRB	;43 DestReg,SrcReg ; OR byte Src to Dest
  CodeE @mOREB,@DRB	;44 DestReg,SrcReg ; XOR byte Src to Dest
  CodeE @mXFRB,@DRB	;45 DestReg,SrcReg ; Copy byte of Src register into byte of Dest register
  CodeE @mIll,@Inh	;46	
  CodeE @mIll,@Inh	;47
  CodeE @mAABB,@Inh	;48 BL+=AL
  CodeE @mSABB,@Inh	;49 BL=AL-BL
  CodeE.@mNABB,@Inh	;4a BL&=AL
  CodeE @mXAXB,@Inh	;4b XL=AL
  CodeE @mXAYB,@Inh	;4c YL=AL
  CodeE @mXABB,@Inh	;4d BL=AL
  CodeE @mXAZB,@Inh	;4e ZL=AL
  CodeE @mXASL,@Inh	;4f SL=AL
  CodeE @mADD,@DRW	;50 DestReg,SrcReg ; Add word Src to Dest
  CoddE @mSUB,@DRW	;51 DestReg,SrcReg ; Subtract byte Src to Dest
  CodeE @mANDC,@DRW	;52 DestReg,SrcReg ; AND word Src to Dest
  CodeE @mORI,@DRW	;53 DestReg,SrcReg ; OR word Src to Dest
  CodeE @mORE,@DRW	;54 DestReg,SrcReg ; XOR word Src to Dest
  CodeE @mXFR,@DRW	;55 DestReg,SrcReg ; Copy Src register into Dest register
  CodeE @mIll,@Inh	;56 ??
  CodeE @mIll,@Inh	;57 ??
  CodeE @mAAB,@Inh	;58 BW+=AW
  CodeE @mSAB,@Inh	;59 BW=AW-BW
  CodeE @mNAB,@Inh	;5a BW&=AW
  CodeE @mXAX,@Inh	;5b XW=AW
  CodeE @mXAY,@Inh	;5c YW=AW
  CodeE @mXAB,@Inh	;5d BW=AW
  CodeE @mXAZ,@Inh	;5e ZW=AW
  CodeE @mXAS,@Inh	;5f SW=AW
  CodeE @mLDX,@LitW	;60 Load immediate into XW
  CodeE @mLDX,@Direct	;61 Load direct address into XW
  CodeE @mLDX,@Indirect	;62 Load indirect address into XW
  CodeE @mLDX,@Rel	;63 Load direct Program Counter offset by N address into XW
  CodeE @mLDX,@RelInd	;64 Load indirect Program Counter offset by N address into XW
  CodeE @mLDX,@WX	;65 Load indexed mode register into XW
  CodeE @mIll,@Inh	;66 ??
  CodeE @mIll,@Inh	;67 ??
  CodeE @mSTX,@LitW	;68 Store XW into literal address (Not possible?)
  CoddE @mSTX,@Direct	;69 Store XW into direct address
  CodeE @mSTX,@Indirect	;6a Store XW into indirect address
  CodeE @mSTX,@Rel	;6b Store XW into direct Program Counter offset by N address
  CodeE @mSTX,@RelInd	;6c Store XW into indirect Program Counter offset by N address
  CodeE @mSTX,@WX	;6d Store XW into indexed register
  CodeE @mIll,@Inh	;6E ??
  CodeE @mIll,@Inh	;6F ??
  CodeE @mIll,@Inh	;70 ??
  CodeE @mJMP,@Direct	;71 Jump to direct address
  CodeE @mJMP,@Indirect	;72 Jump to indirect address
  CodeE @mJMP,@Rel	;73 Jump to direct Program Counter offset by N address
  CodeE @mJMP,@RelInd	;74 Jump to indirect Program Counter offset by N address
  CodeE @mJMP,@WX	;75 WReg,Mod,Offset ;Jump to indexed mode register
  CodeE @mSYSCALL,@Inh	;76 Call interrupt level 15
  CodeE @mMUL,@Inh	;77	multiply
  CodeE @mDIV,@Inh	;78	divide
  CodeE @mJSR,@Direct	,79
  CodeE @mJSR,@Indirect	;7a
  CodeE @mJSR,@Rel	;7b
  CodeE @mJSR,@RelInd	;7c
  CodeE @mJSR,@WX	;7d	WReg,Mod,Offset ; Jump to subroutine at indexed mode register
  CodeE @mPUSH,@Inh	;7e	RegCountM1
  CodeE @mPOP,@Inh	;7f	RegCountM1
  CodeE @mLDAB,@LitB	;80	Load literal address into AL register
  CodeE @mLDAB,@Direct	;81	Load direct address into AL register
  CodeE @mLDAB,@Indirect ;82	Load indirect address into AL register
  CodeE @mLDAB,@Rel	;83	Load direct Program Counter offset by N address into AL register
  CodeE @mLDAB,@RelInd	;84	Load indirect Program Counter offset by N address into byte of AL register
  CodeE @mLDAB,@BX	;85	WReg,Mod,Offset ; Load indexed register into byte of AL register
  CodeE @mIll,@Inh	;86	??
  CodeE @mIll,@Inh	;87	??
  CodeE @mLDAB,@A	;88	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDAB,@A	;89	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDAB,@A	;8a	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDAB,@A	;8b	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDAB,@A	;8c	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDAB,@A	;8d	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDAB,@A	;8e	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDAB,@A	;8f	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDA,@LitW	;90	Load literal address into full word of AW register
  CodeE @mLDA,@Direct	;91	Load direct address into full word of AW register
  CodeE @mLDA,@Indirect	;92	Load indirect address into full word of AW register
  CodeE @mLDA,@Rel	;93	Load direct Program Counter offset by N address into full word of AW register
  CodeE @mLDA,@RelInd	;94	Load indirect Program Counter offset by N address into full word of AW register
  CodeE @mLDA,@WX	;95	WReg,Mod,Offset ; Load indexed register into full word of AW register
  CodeE @mIll,@Inh	;96	??
  CodeE @mIll,@Inh	;97	??
  CodeE @mLDA,@A	;98	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDA,@A	;99	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDA,@A	;9a	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDA,@A	;9b	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDA,@A	;9c	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDA,@A	;9d	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDA,@A	;9e	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mLDA,@A	;9f	WReg ; Load byte from memory address stored in WReg into AL register
  CodeE @mSTAB,@LitB	;a0	Store byte of AL register into literal address (Not possible?)
  CodeE @mSTAB,@Direct	;a1	Store byte of AL register into direct address
  CodeE @mSTAB,@Indirect ;a2	Store byte of AL register into indirect address
  CodeE @mSTAB,@Rel	;a3	Store byte of AL register into direct Program Counter offset by N address
  CodeE @mSTAB,@RelInd	;a4	Store byte of AL register into indirect Program Counter offset by N address
  CodeE @mSTAB,@BX	;a5	WReg,Mod,Offset ; Store byte of AL register into indexed register
  CodeE @mIll,@Inh	;A6	??
  CodeE @mIll,@Inh	;A7	??
  CodeE @mSTAB,@A	;a8	Store AL register to memory address stored in WReg
  CodeE @mSTAB,@A	;a9	Store AL register to memory address stored in WReg
  CodeE @mSTAB,@A	;aa	Store AL register to memory address stored in WReg
  CodeE @mSTAB,@A	;ab	Store AL register to memory address stored in WReg
  CodeE @mSTAB,@A	;ac	Store AL register to memory address stored in WReg
  CodeE @mSTAB,@A	;ad	Store AL register to memory address stored in WReg
  CodeE @mSTAB,@A	;ae	Store AL register to memory address stored in WReg
  CodeE @mSTAB,@A	;af	Store AL register to memory address stored in WReg
  CodeE @mSTA,@LitW	;b0	Store word of AW register into literal address (Not possible?)
  CodeE @mSTA,@Direct	;b1	Store word of AW register into direct address
  CodeE @mSTA,@Indirect	;b2	Store word of AW register into indirect address
  CodeE @mSTA,@Rel	;b3	Store word of AW register into direct Program Counter offset by N address
  CodeE @mSTA,@RelInd	;b4	Store word of AW register into indirect Program Counter offset by N address
  CodeE @mSTA,@WX	;b5	WReg,Mod,Offset ; Store word of AW register into indexed register
  CodeE @mIll,@Inh	;b6	??
  CodeE @mIll,@Inh	;b7	??
  CodeE @mSTA,@A	;b8	WReg ; Store AW register to memory address stored in WReg
  CodeE @mSTA,@A	;b9	WReg ; Store AW register to memory address stored in WReg
  CodeE @mSTA,@A	;ba	WReg ; Store AW register to memory address stored in WReg
  CodeE @mSTA,@A	;bb	WReg ; Store AW register to memory address stored in WReg
  CodeE @mSTA,@A	;bc	WReg ; Store AW register to memory address stored in WReg
  CodeE @mSTA,@A	;bd	WReg ; Store AW register to memory address stored in WReg
  CodeE @mSTA,@A	;be	WReg ; Store AW register to memory address stored in WReg
  CodeE @mSTA,@A	;bf	WReg ; Store AW register to memory address stored in WReg
  CodeE @mLDBB,@LitB	;c0	Load literal address into BL register
  CodeE @mLDBB,@Direct	;c1	Load direct address into BL register
  CodeE @mLDBB,@Indirect ;c2	Load indirect address into BL register
  CodeE @mLDBB,@Rel	;c3	Load direct Program Counter offset by N address into BL register
  CodeE @mLDBB,@RelInd	;c4	Load indirect Program Counter offset by N address into BL register
  CodeE @mLDBB,@BX	;c5	WReg,Mod,Offset ; Load indexed register into BL register
  CodeE @mIll,@Inh	;C6	??
  CodeE @mIll,@Inh	;C7	??
  CodeE @mLDBB,@A	;c8	Load byte from memory address stored in WReg into BL register
  CodeE @mLDBB,@A	;c9	Load byte from memory address stored in WReg into BL register
  CodeE @mLDBB,@A	;ca	Load byte from memory address stored in WReg into BL register
  CodeE @mLDBB,@A	;cb	Load byte from memory address stored in WReg into BL register
  CodeE @mLDBB,@A	;cc	Load byte from memory address stored in WReg into BL register
  CodeE @mLDBB,@A	;cd	Load byte from memory address stored in WReg into BL register
  CodeE @mLDBB,@A	;ce	Load byte from memory address stored in WReg into BL register
  CodeE @mLDBB,@A	;cf	Load byte from memory address stored in WReg into BL register
  CodeE @mLDB,@LitW	;d0	Load literal address into BW register
  CodeE @mLDB,@Direct	;d1	Load direct address into BW register
  CodeE @mLDB,@Indirect	;d2	Load indirect address into BW register
  CodeE @mLDB,@Rel	;d3	Load direct Program Counter offset by N address into BW register
  CodeE @mLDB,@RelInd	;d4	Load indirect Program Counter offset by N address into BW register
  CodeE @mLDB,@WX	;d5	WReg,Mod,Offset ; Load indexed register into BW register
  CodeE @mIll,@Inh	;D6	??
  CodeE @mIll,@Inh	;D7	??
  CodeE @mLDB,@A	;d8	Load word from memory address stored in WReg into BW register
  CodeE @mLDB,@A	;d9	Load word from memory address stored in WReg into BW register
  CodeE @mLDB,@A	;da	Load word from memory address stored in WReg into BW register
  CodeE @mLDB,@A	;db	Load word from memory address stored in WReg into BW register
  CodeE @mLDB,@A	;dc	Load word from memory address stored in WReg into BW register
  CodeE @mLDB,@A	;dd	Load word from memory address stored in WReg into BW register
  CodeE @mLDB,@A	;de	Load word from memory address stored in WReg into BW register
  CodeE @mLDB,@A	;df	Load word from memory address stored in WReg into BW register
  CodeE @mSTBB,@LitB	;e0	Store byte of BL register into literal address (Not possible?)
  CodeE @mSTBB,@Direct	;e1	Store BL into direct address
  CodeE @mSTBB,@Indirect ;e2	Store BL into indirect address
  CodeE @mSTBB,@Rel	;e3	Store BL into direct Program Counter offset by N address
  CodeE @mSTBB,@RelInd	;e4	Store BL into indirect Program Counter offset by N address
  CodeE @mSTBB,@BX	;e5	WReg,Mod,Offset ; Store BL into indexed register
  CodeE @mIll,@Inh	;E6	??
  CodeE @mIll,@Inh	;E7	??
  CodeE @mSTBB,@A	;e8	Store byte from BL register to memory address stored in WReg
  CodeE @mSTBB,@A	;e9	Store byte from BL register to memory address stored in WReg
  CodeE @mSTBB,@A	;ea	Store byte from BL register to memory address stored in WReg
  CodeE @mSTBB,@A	;eb	Store byte from BL register to memory address stored in WReg
  CodeE @mSTBB,@A	;ec	Store byte from BL register to memory address stored in WReg
  CodeE @mSTBB,@A	;ed	Store byte from BL register to memory address stored in WReg
  CodeE @mSTBB,@A	;ee	Store byte from BL register to memory address stored in WReg
  CodeE @mSTBB,@A	;ef	Store byte from BL register to memory address stored in WReg
  CodeE @mSTB,@LitW	;f0	Store BW into literal address (Not possible?)
  CodeE @mSTB,@Direct	;f1	Store BW into direct address
  CodeE @mSTB,@Indirect	;f2	Store BW into indirect address
  CodeE @mSTB,@Rel	;f3	Store BW into direct Program Counter offset by N address
  CodeE @mSTB,@RelInd	;f4	Store BW into indirect Program Counter offset by N address
  CodeE @mSTB,@WX	;f5	WReg,Mod,Offset ; Store BW into indexed register
  CodeE @mIll,@Inh	;f6	??
  CodeE @mIll,@Inh	;f7	??
  CodeE @mSTB,@A	;f8	Store BW to memory address stored in WReg
  CodeE @mSTB,@A	;f9	Store BW to memory address stored in WReg
  CodeE @mSTB,@A	;fa	Store BW to memory address stored in WReg
  CodeE @mSTB,@A	;fb	Store BW to memory address stored in WReg
  CodeE @mSTB,@A	;fc	Store BW to memory address stored in WReg
  CodeE @mSTB,@A	;fd	Store BW to memory address stored in WReg
  CodeE @mSTB,@A	;fe	Store BW to memory address stored in WReg
  CodeE @mSTB,@A	;ff	Store BW to memory address stored in WReg



;---------------------------------------

RegNames: .byte "AABBXXYYZZSSCCPP"
; AW = $0
; AH = $0
; AL = $1
 FHdr 'AW',0 ; ( -- n )  word register
	LDABL 0
	JMPR PushA4
 FHdr 'AH',0 ; ( -- n )  byte register
	LDABL 0
	JMPR PushA4
 FHdr 'AL',0 ; ( -- n )  byte register
	LDABL 1
	JMPR PushA4

 FHdr 'BW',0 ; ( -- n )  word register
	LDABL 2
	JMPR PushA4
 FHdr 'BH',0 ; ( -- n )  byte register
	LDABL 2
	JMPR PushA4
 FHdr 'BL',0 ; ( -- n )  byte register
	LDABL 3
	JMPR PushA4

 FHdr 'XW',0 ; ( -- n )  word register
	LDABL 4
	JMPR PushA4
 FHdr 'XH',0 ; ( -- n )  byte register
	LDABL 4
	JMPR PushA4
 FHdr 'XL',0 ; ( -- n )  byte register
	LDABL 5
;	JMPR PushA4

PushA4:	LDBBL 0
	XFR AH,BL
	STAX ZW,ModBMRB,0
	RSR

 FHdr 'YW',0 ; ( -- n )  word register
	LDABL 6
	JMPR PushA4
 FHdr 'YH',0 ; ( -- n )  byte register
	LDABL 6
	JMPR PushA4
 FHdr 'YL',0 ; ( -- n )  byte register
	LDABL 7
	JMPR PushA4

 FHdr 'ZW',0 ; ( -- n )  word register
	LDABL 8
	JMPR PushA4
 FHdr 'ZH',0 ; ( -- n )  byte register
	LDABL 8
	JMPR PushA4
 FHdr 'ZL',0 ; ( -- n )  byte register
	LDABL 9
	JMPR PushA4

 FHdr 'SW',0 ; ( -- n )  word register
	LDABL 10
	JMPR PushA4

 FHdr 'CW',0 ; ( -- n )  word register
	LDABL 12
	JMPR PushA4

 FHdr 'PW',0 ; ( -- n )  word register
	LDABL 14
	JMPR PushA4


; Addressing Modes
; Instructions can be either 1-byte, 2-byte or 3-byte depending on the type of instruction.
; The second or third byte (if present) are related to addressing, or directing the instruction as to which location in memory to act upon.
; Addressing can be either implicit or explicit.
; Implicit means that no addressing is specified, and that specific instruction operates on only one specific location.
; Explicit means the programmer must state which location they will perform the operation on.

; In the chart below, the addressing mode and what is expected at each nibble of each operation is shown.

; HB = High Byte; MB = Mid Byte; LB = Low Byte

; HN = High Nibble; LN = Low Nibble

; HB_HN      	HB_LN      	MB_HN  	MB_LN  	LB_HN  	LB_LN  	Note
; 0	Op (0-F)					Control Operations
; 1	Op (0-F)	Displace	Displace			Branch Operations
; 2	Op (0-7)	Source Reg.				Single Register Explicit Byte Operation
; 2	Op (8-F)					Single Register Implicit Byte Operation
; 3	Op (0-7)	Source Reg.				Single Register Explicit Word Operation
; 3	Op (8-F)					Single Register Implicit Word Operation
; 4	Op (0-7)	Source Reg.	Dest. Reg.			Double Register Explicit Byte Operation
; 4	Op (8-F)					Double Register Implicit Byte Operation
; 5	Op (0-7)	Source Reg.	Dest. Reg.			Double Register Explicit Word Operation
; 5	Op (8-F)					Double Register Implicit Word Operation
; Op (6-F)	0	Literal	Literal			Literal Memory Address Byte Operation
; Op (6-F)	0	Literal	Literal	Literal	Literal	Literal Memory Address Word Operation
; Op (6-F)	1	Direct	Direct	Direct	Direct	Direct Memory Address Operation
; Op (6-F)	2	Indirect	Indirect	Indirect	Indirect	Indirect Memory Address Operation
; Op (6-F)	3	Displace	Displace			Relative to Current Location Memory Address Operation
; Op (6-F)	4	Displace	Displace			Indirect Relative to Current Location Memory Address Operation
; Op (6-F)	5	Register	Modifier	Displace	Displace	Indexed Addressing (Modifier Table Below)
; Op (6-F)	8-F					Implicit Indexing (8 - F => A - P Reg.)

AMode:	.res 1

AModeSet: ; remember indexed addr mode for next instruction
	; AL=mode
	LDBBD AMode
	BP @AlreadySet
	STABD AMode
	RSB

@AlreadySet:
	JSRD PDotQuote
	.byte 16,"Mode already set"
	JMPD Abort

 FHdr "(r)",0 ; Index
	LDABL 0
	JMPR AModeSet

 FHdr "(r+)",0 ; Index returned, incremented by ^
	LDABL 1
	JMPR AModeSet

 FHdr "(-r)",0 ; Decrement and Index
	LDABL 2
	JMPR AModeSet

 FHdr "@(r)",0 ; indirect
	LDABL 4
	JMPR AModeSet

 FHdr "@(r+)",0 ; Index returned, incremented by ^
	LDABL 5
	JMPR AModeSet

 FHdr "@(-r)",0 ; Decrement and index indirect
	LDABL 6
	JMPR AModeSet

 FHdr "n(r)",0 ; Index with displacement
	LDABL 8
	JMPR AModeSet

 FHdr "n(r+)",0 ; Index with displacement; Index returned, incremented by ^
	LDABL 9
	JMPR AModeSet

 FHdr "n(-r)",0 ; Decrement and index with displacement
	LDABL $a
	JMPR AModeSet

 FHdr "@n(r)",0 ; Index with displacement indirect
	LDABL $c
	JMPR AModeSet

 FHdr "@n(r+)",0 ; Index with displacement indirect, Index returned, incremented by ^
	LDABL $d
	JMPR AModeSet

 FHdr "@n(-r)",0 ; Decrement and index with displacement indirect
	LDABL $e
	JMPR AModeSet

  .macro ModBytes WReg,Mod,Offset
	.if (WReg&$fff1)<>0
	  .error "WReg must be a word register"
	 .endif
	.if (Mod=ModBRB) | (Mod=ModBRPB) | (Mod=ModBMRB) | (Mod=ModABRB) | (Mod=ModABRPB) | (Mod=ModABMRB)
	  .byte (WReg<<4)|Mod
	 .else
	  .if (Mod=ModNBRB) | (Mod=ModNBRPB) | (Mod=ModNBMRB) | (Mod=ModANBRB) | (Mod=ModANBRPB) | (Mod=ModANBMRB)
	    .byte (WReg<<4)|Mod,Offset ; is offset signed or unsigned???
           .else
	    .error "Unknown Mod"
	   .endif
	 .endif
	.endmacro


	.dbyt D_Inherent ; disassembly routine
A_Inherent:
	LDABA XW		; get opcode
	JSRD CCommaA
	LDXX SW,ModBRPB,0	; pop X
	RSB


 FHdr "HLT,",0 ; Wait for Interrupt (Halt)
	JSRD A_Inherent
	.byte $00

 FHdr "NOP,",0 ; No Operation
	JSRD A_Inherent
	.byte $01

 FHdr "SF,",0 ; Set Fault flag
	JSRD A_Inherent
	.byte $02

 FHdr "RF,",0 ; Reset Fault flag
	JSRD A_Inherent
	.byte $03

 FHdr "EI,",0 ; Enable the Interrupt System (allow interrupts)
	JSRD A_Inherent
	.byte $04

 FHdr "DI,",0 ; Disable the Interrupt System (disable interrupts)
	JSRD A_Inherent
	.byte $05

 FHdr "SL,",0 ; Set the Link (carry) Flag
	JSRD A_Inherent
	.byte $06

 FHdr "RL,",0 ; Reset the Link (carry) Flag
	JSRD A_Inherent
	.byte $07

 FHdr "CL,",0 ; Complement Link flag
	JSRD A_Inherent
	.byte $08

 FHdr "RSR,",0 ; Return from subroutine
	JSRD A_Inherent
	.byte $09

 FHdr "RI,",0 ; Return from interrupt
	JSRD A_Inherent
	.byte $0A

 FHdr "RIM,",0 ; Return from Interrupt Modified
	JSRD A_Inherent
	.byte $0B

 FHdr "ELO,",0 ; Enable Link Out - teletype_tx=Link
	JSRD A_Inherent
	.byte $0C

 FHdr "PCX,",0 ; Transfer PC to X - X=address of next instruction
	JSRD A_Inherent
	.byte $0D

 FHdr "DLY,",0 ; Delay 4.55 ms - for TTY bit timing
	JSRD A_Inherent
	.byte $0E

 FHdr 'RSYS,',0 ; Return from Syscall
	JSRD A_Inherent
	.byte $0F

	.dbyt D_Relative ; disassembly routine
A_Relative: ; ( adr -- ) do instruction with relative addressing
	LDABA XW		; get opcode
	JSRD CCommaA		; store opcode
	INR BW
	LDAAX ZW,ModBRPB,0	; pop adr
	SUB AW,BW		; calc displacement
	LDBL $80		; < $80
	SAB
	BL @OK
	LDBL $FF80		; > $FF80
	SAB
	BNL @Err
@OK:	JMPD CCommAA

@Err:	LDBL ERR_OutOfRange	; error
	JSRD ErrorY	


 FHdr "BL,",0  ; ( adr -- ) Branch if Link (Carry) Set
	JSRD A_Relative
	.byte $10

 FHdr "BNL,",0 ; ( adr -- ) Branch if Link (Carry) not Set
	JSRD A_Relative
	.byte $11

 FHdr "BF,",0 ; ( adr -- ) Branch if Fault Set
	JSRD A_Relative
	.byte $12

 FHdr "BNF,",0 ; ( adr -- ) Branch if Fault not Set
	JSRD A_Relative
	.byte $13

 FHdr "BZ,",0 ; ( adr -- ) Branch if V (Z) flag set
	JSRD A_Relative
	.byte $14

 FHdr "BNZ,",0 ; ( adr -- ) Branch if V (Z) flag clear
	JSRD A_Relative
	.byte $15

 FHdr "BM,",0 ; ( adr -- ) Branch if Minus flag set
	JSRD A_Relative
	.byte $16

 FHdr "BP,",0 ; ( adr -- ) Branch on Positive (Minus flag clear)
	JSRD A_Relative
	.byte $17

 FHdr "BGZ,",0 ; ( adr -- ) Branch if Greater Than 0 (!V && !Minus)
	JSRD A_Relative
	.byte $18

 FHdr "BLE,",0 ; ( adr -- ) Branch if Less Than or Equal to 0 (V | Minus)
	JSRD A_Relative
	.byte $19

 FHdr "BS1,",0 ; ( adr -- ) Branch if Sense Switch 1 Set
	JSRD A_Relative
	.byte $1a

 FHdr "BS2,",0 ; ( adr -- ) Branch if Sense Switch 2 Set
	JSRD A_Relative
	.byte $1b

 FHdr "BS3,",0 ; ( adr -- ) Branch if Sense Switch 3 Set
	JSRD A_Relative
	.byte $1c

 FHdr "BS4,",0 ; ( adr -- ) Branch if Sense Switch 4 Set
	JSRD A_Relative
	.byte $1d

; FHdr "BTM",0 ; ( adr -- ) Branch on TTY Mark (Changed for CPU6?)
;	JSRD A_Relative
;	.byte $1e

 FHdr "RSYS,",0 ; ( adr -- ) Branch on Even Parity (Changed for CPU6?)
	JSRD A_Relative
	.byte $1f


	.dbyt Abort ;???  ; disassembly routine
A_RegW: ; ( Reg -- )
	LDABA XW		; get opcode
	JSRD CCommaA
	LDAX ZW,ModBRPB,0	; get Reg
	; test for valid word register?
	SLA
	SLA
	SLA
	SLA
	JMPD CCommaA

	.dbyt Abort ;???  ; disassembly routine
A_RegB:	JMPR A_RegW

 FHdr "INR,",0 ; ( n WReg -- ) increment register word
	JSRD RegWV
	.byte $30

 FHdr "INRB,",0 ; ( BReg -- ) increment byte register
	JSRD RegB
	.byte $20

 FHdr "INAB,",0 ; ( -- ) Increment AL register
	JSR M_Inherent
	.byte $28

 FHdr "INA,",0 ; ( -- ) Increment AW register
	JSR M_Inherent
	.byte $38

 FHdr "DCR,",0 ; ( n WReg -- ) decrement register word
	JSR RegWV
	.byte $31

 FHdr "DCRB,",0 ; ( BReg -- ) decrement byte register
	JSRD RegB
	.byte $21

 FHdr "DCAB,",0 ; ( -- ) Decrement AL register
	JSRD A_Inherent
	.byte $29

 FHdr "DCA,",0 ; ( -- ) Decrement AW register
	JSRD A_Inherent
	.byte $39

 FHdr "CLR,",0 ; ( n WReg -- ) clear register word
	JSRD RegWV
	.byte $32

 FHdr "CLRB,",0 ; ( BReg -- ) clear byte register
	JSRD RegB
	.byte $22

 FHdr "CLAB,",0 ; ( -- ) Clear AL register
	JSRD A_Inherent
	.byte $2A

 FHdr "CLA,",0 ; ( -- ) Clear AW register
	JSRD A_Inherent
	.byte $3A

 FHdr "IVR,",0 ( n WReg -- ) invert register word
	JSRD RegWV
	.byte $33

 FHdr "IVRB,",0 ( BReg -- ) invert register byte
	JSRD RegB
	.byte $23

 FHdr "IVAB,",0 ; ( -- ) Invert AL register
	JSRD A_Inherent
	.byte $2B

 FHdr "IVA,",0 ; ( -- ) Invert AW register
	JSRD A_Inherent
	.byte $3B

 FHdr "SRR,",0 ; ( n WReg -- ) shift register right (sign extend)
	JSRD RegWVp1
	.byte $34

 FHdr "SRRB,",0 ; ( BReg -- ) shift register byte right (sign extend)
	JSRD RegB
	.byte $24

 FHdr "SRAB,",0 ; ( -- ) Shift AL register right (sign extend)
	JSRD A_Inherent
	.byte $2C

 FHdr "SRA,",0 ; ( -- ) Shift AW register right (sign extend)
	JSRD A_Inherent
	.byte $3C

 FHdr "SLR,",0 ; ( n WReg -- ) shift register left (0 shifted in)
	JSRD RegWVp1
	.byte $35

 FHdr "SLRB,",0 ; ( BReg -- ) shift register byte left (0 shifted in)
	JSRD RegBW
	.byte $25

 FHdr "SLAB,",0 ; ( -- ) Shift AL register left (0 shifted in)
	JSRD A_Inherent
	.byte $2D

 FHdr "SLA,",0 ; ( -- ) Shift AW register left (0 shifted in)
	JSRD A_Inherent
	.byte $3D

 FHdr "RRR,",0 ; ( n WReg -- ) rotate register right (thru link flag)
	JSRD RegWVp1
	.byte $36

 FHdr "RRRB,",0 ; ( BReg -- ) rotate register byte right (thru link flag)
	JSRD RegB
	.byte $26

 FHdr "RLR,",0 ; ( n WReg -- ) rotate register left (thru link flag)
	JSRD RegWVp1
	.byte $37

 FHdr "RLRB,",0 ; ( BReg -- )
	JSRD RegBW
	.byte $27

;  .macro ?? 
;	.byte $2E ; Memory mapping?
;	.endmacro
;  .macro ?? 
;	.byte $2F ; DMA?
;	.endmacro

 FHdr "INX,",0 ; ( -- ) Increment XW register
	JSRD A_Inherent
	.byte $3E

 FHdr "DCX,",0 ; ( -- ) Decrement XW register
	JSRD A_Inherent
	.byte $3F


A_RegReg: ; ( DestReg SrcReg -- ) 2 registers
	LDAX ZW,ModBRPB,0	; pop SrcReg
	SLA
	SLA
	SLA
	SLA
	LDBX ZW,ModBRPB,0	; pop DestReg
	ORI BL,AL
	JMPD CCommaA	; ((SrcReg&$f)<<4)+(DestReg&$f)

 FHdr "ADD,",0 ; ( DestReg SrcReg -- ) Add word Src to Dest
	JSRD A_RegReg
	.byte $50
 FHdr "ADDB,",0 ; ( DestReg SrcReg -- ) Add byte Src to Dest
	JSRD A_RegReg
	.byte $40
 FHdr "AABB,",0 ; ( -- ) BL+=AL
	JSRD A__Inherent
	.byte $48
 FHdr "AAB",,0 ; ( -- ) BW+=AW
	JSRD A__Inherent
	.byte $58

 FHdr "SUB,",0 ; ( DestReg SrcReg -- ) Subtract byte Src to Dest
	JSRD A_RegReg
	.byte $51
 FHdr "SUBB,",0 ; ( DestReg SrcReg -- ) Subtract byte Src to Dest
	JSRD A_RegReg
	.byte $41
 FHdr "SABB,",0 ; ( -- ) BL=AL-BL
	JSRD A_Inherent
	.byte $49
 FHdr "SAB,",0 ; ( -- ) BW=AW-BW
	JSRD A_Inherent
	.byte $59

 FHdr "ANDW,",0 ; ( DestReg SrcReg -- ) AND word Src to Dest
	JSRD A_RegReg
	.byte $52
 FHdr "ANDB,",0 ; ( DestReg SrcReg -- ) AND byte Src to Dest
	JSRD A_egReg
	.byte $42
 FHdr "NABB,",0 ; ( -- ) BL&=AL
	JSRD A_Inherent
	.byte $4A
 FHdr "NAB,",0 ; ( -- ) BW&=AW
	JSRD A_Inherent
	.byte $5A

 FHdr "ORI,",0 ; ( DestReg SrcReg -- ) OR word Src to Dest
	JSRD A_RegReg
	.byte $53
 FHdr "ORIB,",0 ; ( DestReg SrcReg -- ) OR byte Src to Dest
	JSRD A_RegReg
	.byte $43

 FHdr "ORE,",0 ; ( DestReg SrcReg -- ) XOR word Src to Dest
	JSRD A_RegReg
	.byte $54
 FHdr "OREB,",0 ; ( DestReg SrcReg -- ) XOR byte Src to Dest
	JSRD A_RegReg
	.byte $44  ;,((SrcReg&$f)<<4)+(DestReg&$f)

 FHdr "XFR,",0 ; ( DestReg SrcReg -- ) Copy Src register into Dest register
	JSRD A_RegReg
	.byte $55 ;,((SrcReg&$f)<<4)+(DestReg&$f)
 FHdr "XFRB,",0 ; ( DestReg SrcReg -- ) Copy byte of Src register into byte of Dest register
	JSRD A_RegReg
	.byte $45 ;,((SrcReg&$f)<<4)+(DestReg&$f)

;  .macro ??
;	.byte $46	; memory block ops

;  .macro ?? ; string ops
;	.byte $47


 FHdr "XAXB,",0 ; ( -- ) XL=AL  ???
	JSRD A_Inherent
	.byte $4B
 FHdr "XAX,",0 ; ( -- ) XW=AW
	JSRD A_Inherent
	.byte $5B
 FHdr "XAYB,",0 ; ( -- ) YL=AL
	JSRD A_Inherent
	.byte $4C
 FHdr "XAY,",0 ; ( -- ) YW=AW
	JSRD A_Inherent
	.byte $5C
 FHdr "XABB,",0 ; ( -- ) BL=AL
	JSRD A_Inherent
	.byte $4D
 FHdr "XAB,",0 ; ( -- ) BW=AW
	JSRD A_Inherent
	.byte $5D
 FHdr "XAZB,",0 ; ( -- ) ZL=AL
	JSRD A_Inherent
	.byte $4E
 FHdr "XAZ,",0 ; ( -- ) ZW=AW
	JSRD A_Inherent
	.byte $5E
 FHdr "XASB,",0 ; ( -- ) SL=AL
	JSRD A_Inherent
	.byte $4F
 FHdr "XAS,",0 ; ( -- ) SW=AW
	JSRD A_Inherent
	.byte $5F
;  .macro ??	; 56	0101 0110	??			
;  .macro ??	; 57	0101 0111	??			Execute micro code?

 FHdr "LDABL,",0 ; ( n -- ) Load literal address into AL register
	JSRD A_LitB
	.byte $80
 FHdr "LDAL,",0 ; ( n -- ) Load literal address into full word of AW register
	JSRD A_LitW
	.byte $90
 FHdr "LDABD,",0 ; ( adr -- ) Load direct address into AL register
	JSRD A_Direct
	.byte $81
 FHdr "LDAD,",0 ; ( adr -- ) Load direct address into full word of AW register
	JSRD A_Direct
	.byte $91
 FHdr "LDABI,",0 ; ( adr -- ) Load indirect address into AL register
	JSRD A_Indirect
	.byte $82
 FHdr "LDAI,",0 ; ( adr -- ) Load indirect address into full word of AW register
	JSRD A_Indirect
	.byte $92
 FHdr "LDABR,",0 ; ( adr -- ) Load direct Program Counter offset by N address into AL register
	JSRD A_Relative
	.byte $83
 FHdr "LDAR,",0 ; ( adr -- ) Load direct Program Counter offset by N address into full word of AW register
	JSRD A_Relative
	.byte $93
 FHdr "LDABRI,",0 ; ( adr -- ) Load indirect Program Counter offset by N address into byte of AL register
	JSRD A_RelativeIndirect
	.byte $84
 FHdr "LDARI,",0 ; ( adr -- ) Load indirect Program Counter offset by N address into full word of AW register
	JSRD A_RelativeIndirect
	.byte $94
 FHdr "LDABX,",0 ; ( WReg Mod Offset -- ) Load indexed register into byte of AL register
	JSRD A_IndexB
	.byte $85
 FHdr "LDAX,",0 ; ( WReg Mod Offset -- ) Load indexed register into full word of AW register
	JSRD A_IndexW
	.byte $95
;  .macro ?? ; 86	1000 0110	??
;  .macro ?? ; 87	1000 0111	??
 FHdr "LDABA,",0 ; ( WReg -- ) Load byte from memory address stored in WReg into AL register
	JSRD A_RegIndirect
	.byte $88 ;+((WReg/2)&7)
 FHdr "LDAA,",0 ; ( WReg -- ) Load byte from memory address stored in WReg into AL register
	JSRD A_RegIndirect
	.byte $98 ;+((WReg/2)&7)
;  .macro ?? ; 96	1001 0110	??			
;  .macro ?? ; 97	1001 0111	??

 FHdr "STABL,",0 ; ( n -- ) Store byte of AL register into literal address (Not possible?)
	JSRD A_LitB
	.byte $A0
 FHdr "STAL,",0 ; ( n -- ) Store word of AW register into literal address (Not possible?)
	JSRD A_LitW
	.byte $B0
 FHdr "STABD,",0 ; ( adr -- ) Store byte of AL register into direct address
	JSRD A_Direct
	.byte $A1
 FHdr "STAD,",0 ; ( adr -- ) Store word of AW register into direct address
	JSRD A_Direct
	.byte $B1
 FHdr "STABI,",0 ; ( adr -- ) Store byte of AL register into indirect address
	JSRD A_Indirect
	.byte $A2
 FHdr "STAI,",0 ; ( adr -- ) Store word of AW register into indirect address
	JSRD A_Indirect
	.byte $B2
 FHdr "STABR,",0 ; ( adr -- ) Store byte of AL register into direct Program Counter offset by N address
	JSRD A_Relative
	.byte $a3
 FHdr "STAR,",0 ; ( adr -- ) Store word of AW register into direct Program Counter offset by N address
	JSRD A_Relative
	.byte $b3
 FHdr "STABRI,",0 ; ( adr -- ) Store byte of AL register into indirect Program Counter offset by N address
	JSRD A_RelativeIndirect
	.byte $a4
 FHdr "STARI,",0 ; ( adr -- ) Store word of AW register into indirect Program Counter offset by N address
	JSRD A_RelativeIndirect
	.byte $b4
 FHdr "STABX,",0 ; ( WReg Mod Offset -- ) Store byte of AL register into indexed register
	JSRD A_Index
	.byte $A5
 FHdr "STAX,",0 ; ( WReg Mod Offset -- ) Store word of AW register into indexed register
	JSRD A_Index
	.byte $B5
;  .macro ?? ; A6	1010 0110	??
;  .macro ?? ; A7	1010 0111	??
 FHdr "STABA,",0 ; ( WReg -- ) Store AL register to memory address stored in WReg
	JSRD A_RegA
	.byte $A8 ;+((WReg/2)&7)
 FHdr "STAA,",0 ; ( WReg -- ) Store AW register to memory address stored in WReg
	JSRD A_RegA
	.byte $B8 ;+((WReg/2)&7)
; .macro ?? ; B6	1011 0110	??
; .macro ?? ; B7	1011 0111	??

 FHdr "LDBBL,",0 ; ( n -- ) Load literal address into BL register
	JSRD A_LitB
	.byte $C0
 FHdr "LDBL,",0 ; ( n -- ) Load literal address into BW register
	JSRD A_LitW
	.byte $D0
 FHdr "LDBBD,",0 ; ( adr -- ) Load direct address into BL register
	JSRD A_Direct
	.byte $C1
 FHdr "LDBD,",0 ; ( adr -- ) Load direct address into BW register
	JSRD A_Direct
	.byte $D1
 FHdr "LDBBI,",0 ; ( adr -- ) Load indirect address into BL register
	JSRD A_Indirect
	.byte $C2
 FHdr "LDBI,",0 ; ( adr -- ) Load indirect address into BW register
	JSRD A_Indirect
	.byte $D2
 FHdr "LDBBR,",0 ; ( adr -- ) Load direct Program Counter offset by N address into BL register
	JSRD A_Relative
	.byte $c3
 FHdr "LDBR,",0 ; ( adr -- ) Load direct Program Counter offset by N address into BW register
	JSRD A_Relative
	.byte $d3
 FHdr "LDBBRI,",0 ; ( adr -- ) Load indirect Program Counter offset by N address into BL register
	JSRD A_RelativeIndirect
	.byte $c4
 FHdr "LDBRI,",0 ; ( adr -- ) Load indirect Program Counter offset by N address into BW register
	JSRD A_RelativeIndirect
	.byte $d4
 FHdr "LDBBX,",0 ; ( WReg Mod Offset -- ) Load indexed register into BL register
	JSRD A_IndexB
	.byte $C5
 FHdr "LDBX,",0 ( WReg Mod Offset ) Load indexed register into BW register
	JSRD A_IndexW
	.byte $D5
;  .macro ?? ; C6	1100 0110	??
;  .macro ?? ; C7	1100 0111	??

 FHdr "LDBBA,",0 ; ( WReg -- ) Load byte from memory address stored in WReg into BL register
	JSRD A_RegA
	.byte $C8 ;+((WReg/2)&7)
 FHdr "LDBA,",0 ; ( WReg -- ) Load word from memory address stored in WReg into BW register
	JSRD A_RegA
	.byte $D8 ;+((WReg/2)&7)
;  .macro ?? ; D6	1101 0110	??			
;  .macro ?? ; D7	1101 0111	??			

 FHdr "STBBL,",0 ; ( n -- ) Store byte of BL register into literal address (Not possible?)
	JSRD A_LitB
	.byte $E0
 FHdr "STBL,",0 ; ( n -- ) Store BW into literal address (Not possible?)
	JSRD A_LitW
	.byte $F0
 FHdr "STBBD,",0 ; ( adr -- ) Store BL into direct address
	JSRD A_Direct
	.byte $E1
 FHdr "STBD,",0 ; ( adr -- ) Store BW into direct address
	JSRD A_Direct
	.byte $F1
 FHdr "STBBI,",0 ; ( adr -- ) Store BL into indirect address
	JSRD A_Indirect
	.byte $E2
 FHdr "STBI,",0 ; ( adr -- ) Store BW into indirect address
	JSRD A_Indirect
	.byte $F2
 FHdr "STBBR,",0 ; ( adr -- ) Store BL into direct Program Counter offset by N address
	JSRD A_Relative
	.byte $e3
 FHdr "STBR,",0 ; ( adr -- ) Store BW into direct Program Counter offset by N address
	JSRD A_Relative
	.byte $f3
 FHdr "STBBRI,",0 ; ( adr -- ) Store BL into indirect Program Counter offset by N address
	JSRD A_RelativeIndirect
	.byte $e4
 FHdr "STBRI,",0 ; ( adr -- ) Store BW into indirect Program Counter offset by N address
	JSRD A_RelativeIndirect
	.byte $f4
 FHdr "STBBX,",0 ; ( WReg Mod Offset -- ) Store BL into indexed register
	JSRD A_Index
	.byte $E5
;	ModBytes WReg,Mod,Offset
 FHdr "STBX,",0 ; ( WReg Mod Offset -- ) ; Store BW into indexed register
	JSRD A_Index
	.byte $F5
;  .macro ?? ; E6	1110 0110	??
;  .macro ?? ; E7	1110 0111	??
 FHdr "STBBA,",0 ; ( WReg -- ) Store byte from BL register to memory address stored in WReg
	JSRD A_RegB
	.byte $E8 ;+((WReg/2)&7)
 FHdr "STBA,",0 ; ( WReg -- ) Store BW to memory address stored in WReg
	JSRD A_RegW
	.byte $F8 ;+((WReg/2)&7)
;  .macro ?? ; F6	1111 0110	??
;  .macro ?? ; F7	1111 0111	??


 FHdr "LDXL,",0 ; ( n -- ) Load immediate into XW
	JSRD A_LitW
	.byte $60
 FHdr "LDXD,",0 ; ( adr -- ) Load direct address into XW
	JSRD A_Direct
	.byte $61
 FHdr "LDXI,",0 ; ( adr -- ) Load indirect address into XW
	JSRD A_Indirect
	.byte $62
 FHdr "LDXR,",0 ; ( adr -- ) Load direct Program Counter offset by N address into XW
	JSRD A_Relative
	.byte $63
 FHdr "LDXRI,",0 ; ( adr -- ) Load indirect Program Counter offset by N address into XW
	JSRD A_RelativeIndirect
	.byte $64
 FHdr "LDXX,",0 ; ( WReg Mod Offset -- ) Load indexed mode register into XW
	JSRD A_Index
	.byte $65
;  .macro ??	; 66	0110 0110	??
;  .macro ??	; 67	0110 0111	??
 FHdr "STXL,",0 ; ( n -- ) Store XW into literal address (Not possible?)
	JSRD A_LitW
	.byte $68
 FHdr "STXD,",0 ; ( adr -- ) Store XW into direct address
	JSRD A_Direct
	.byte $69
 FHdr "STXI,",0 ; ( adr -- ) Store XW into indirect address
	JSRD A_Indirect
	.byte $6A
 FHdr "STXR,",0 ; ( adr -- ) Store XW into direct Program Counter offset by N address
	JSRD A_Relative
	.byte $6b
 FHdr "STXRI,",0 ; ( adr -- ) Store XW into indirect Program Counter offset by N address
	JSRD A_RelativeIndirect
	.byte $6c
 FHdr "STXX,",0 ; ( WReg Mod Offset -- ) Store XW into indexed register
	JSRD A_Index
	.byte $6D
;  .macro ??	; 6E	0110 1110	??
;  .macro ??	; 6F	0110 1111	??

;  .macro ??	; $70
 FHdr "JMPD,",0 ; ( adr -- ) Jump to direct address
	JSRD A_Direct
	.byte $71
 FHdr "JMPI,",0 ; ( adr -- ) Jump to indirect address
	JSRD A_Indirect
	.byte $72
 FHdr "JMPR,",0 ; ( adr -- ) Jump to direct Program Counter offset by N address
	JSRD A_Relative
	.byte $73
 FHdr "JMPRI,",0 ; ( adr -- ) Jump to indirect Program Counter offset by N address
	JSRD A_RelativeIndirect
	.byte $74
 FHdr "JMPX,",0 ; ( WReg Mod Offset -- ) Jump to indexed mode register
	JSRD A_Index
	.byte $75
 FHdr "SYSCALL,",0 ( -- ) Call interrupt level 15
	JSRD A_Inherent
	.byte $76
;  .macro ?? ; 77	??

;  .macro ?? ; 78 ??
 FHdr "JSRD,",0 ; ( adr -- ) Jump to subroutine at direct address
	JSRD A_Direct
	.byte $79
 FHdr "JSRI,",0 ; ( adr -- ) Jump to subroutine at indirect address
	JSRD A_Indirect
	.byte $7A
 FHdr "JSRR,",0 ; ( adr -- ) Jump to subroutine at Program Counter offset by N address
	JSRD A_Relative
	.byte $7b
 FHdr "JSRRI,",0 ; ( adr -- ) Jump to subroutine at indirect Program Counter offset by N address
	JSRD A_RelativeIndirect
	.byte $7c
 FHdr "JSRX,",0 ; ( WReg Mod Offset -- ) Jump to subroutine at indexed mode register
	JSRD A_IndexB
	.byte $7D

 FHdr "PUSH,",0 ; ( BReg n -- )  push registers
	JSRD A_ ;???
	.byte $7e
 FHdr "POP,",0 ; ( BReg n -- )  pop registers
	JSRD A_ ;???
	.byte $7f


 .endif ; assembler & disassembler

	.if 0
;-------------------------------------------------------------------------
; 12. The optional Floating-Point word set
; https://forth-standard.org/standard/float




	.endif  ; floating point

NTOP	= DictLink
TOP:


;	.org $fc00 ; bootstrap ROM for simulator ------------------------------------
;
;	LDAL ReEnter	; set restart vector
;	STAD $1a
;	JMPD Enter	; just jmp to FORTH

	.end
